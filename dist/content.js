/*!
 * rovalra v2.4.10
 * License: GPL-3.0
 * Repository: https://github.com/NotValra/RoValra
 * This extension is provided AS-IS without warranty.
 */
(() => {
  var __defProp = Object.defineProperty;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: !0 });

  // src/content/core/observer.js
  var observerInitialized = !1, observationRequests = [], globalObserver = null, attributeListeners = /* @__PURE__ */ new Map();
  function initializeObserver() {
    observerInitialized || (globalObserver = new MutationObserver((mutationsList) => {
      for (let req of observationRequests)
        if (req.active)
          if (req.multiple && req.elements.size > 0)
            for (let element of [...req.elements])
              document.body.contains(element) || (req.elements.delete(element), typeof req.onRemove == "function" && req.onRemove(element));
          else !req.multiple && req.element && !document.body.contains(req.element) && (typeof req.onRemove == "function" && req.onRemove(), req.element = null);
      for (let mutation of mutationsList) {
        if (mutation.type === "attributes") {
          let listener = attributeListeners.get(mutation.target);
          listener && listener(mutation);
          continue;
        }
        if (mutation.addedNodes.length !== 0) {
          for (let addedNode of mutation.addedNodes)
            if (addedNode.nodeType === Node.ELEMENT_NODE) {
              for (let req of observationRequests)
                if (req.active) {
                  if (!req.multiple && !req.element)
                    if (addedNode.matches(req.selector))
                      req.element = addedNode, req.callback(addedNode);
                    else {
                      let foundElement = addedNode.querySelector(req.selector);
                      foundElement && (req.element = foundElement, req.callback(foundElement));
                    }
                  req.multiple && (addedNode.matches(req.selector) && !req.elements.has(addedNode) && (req.elements.add(addedNode), req.callback(addedNode)), addedNode.querySelectorAll(req.selector).forEach((child) => {
                    req.elements.has(child) || (req.elements.add(child), req.callback(child));
                  }));
                }
            }
        }
      }
    }), observerInitialized = !0);
  }
  __name(initializeObserver, "initializeObserver");
  var observeElement = /* @__PURE__ */ __name((selector, callback, options = {}) => {
    let isMultiple = options.multiple || !1, request = {
      selector,
      callback,
      onRemove: options.onRemove,
      multiple: isMultiple,
      active: !0,
      ...isMultiple ? { elements: /* @__PURE__ */ new Set() } : { element: null }
    };
    if (observationRequests.push(request), isMultiple)
      document.querySelectorAll(selector).forEach((element) => {
        request.elements.has(element) || (request.elements.add(element), callback(element));
      });
    else {
      let existingElement = document.querySelector(selector);
      existingElement && !request.element && (request.element = existingElement, callback(existingElement));
    }
    return request;
  }, "observeElement"), observeAttributes = /* @__PURE__ */ __name((element, callback, attributeFilter = []) => (observerInitialized || initializeObserver(), attributeListeners.set(element, callback), globalObserver.observe(element, { attributes: !0, attributeFilter }), {
    disconnect: /* @__PURE__ */ __name(() => {
      attributeListeners.delete(element);
    }, "disconnect")
  }), "observeAttributes");
  function startObserving() {
    return observerInitialized || initializeObserver(), globalObserver ? document.body ? (globalObserver.observe(document.body, { childList: !0, subtree: !0 }), "active") : (window.addEventListener("DOMContentLoaded", () => {
      globalObserver.observe(document.body, { childList: !0, subtree: !0 });
    }, { once: !0 }), "deferred") : (console.error("RoValra: Observer initialization failed."), "failed");
  }
  __name(startObserving, "startObserving");

  // src/content/core/theme.js
  var cachedTheme = null, getCurrentTheme = /* @__PURE__ */ __name(() => cachedTheme || "light", "getCurrentTheme"), THEME_CONFIG = {
    light: {
      content: "rgb(247, 247, 248)",
      text: "rgb(73, 77, 90)",
      header: "rgb(32, 34, 39)",
      sliderOn: "#444",
      sliderOff: "rgba(0, 0, 0, 0.1)",
      sliderButton: "#24292e",
      buttonText: "rgb(57, 59, 61)",
      buttonBg: "rgb(242, 244, 245)",
      buttonHover: "rgb(224, 226, 227)",
      buttonActive: "rgb(210, 212, 213)",
      buttonBorder: "0 solid rgba(0, 0, 0, 0.1)",
      discordLink: "#3479b7",
      githubLink: "#1e722a",
      robloxLink: "#c13ad9"
    },
    dark: {
      content: "rgb(39, 41, 48)",
      text: "rgb(213, 215, 221)",
      header: "white",
      sliderOn: "#ddd",
      sliderOff: "rgba(0, 0, 0, 0.1)",
      sliderButton: "white",
      buttonText: "rgba(255, 255, 255, 0.9)",
      buttonBg: "rgb(45, 48, 51)",
      buttonHover: "rgb(57, 60, 64)",
      buttonActive: "rgb(69, 73, 77)",
      buttonBorder: "0px solid rgba(255, 255, 255, 0.1)",
      discordLink: "#7289da",
      githubLink: "#2dba4e",
      robloxLink: "#c13ad9"
    }
  };
  function detectTheme() {
    let cacheElement = document.getElementById("rovalra-theme-cache");
    return cacheElement?.dataset.theme ? Promise.resolve(cacheElement.dataset.theme) : new Promise((resolve) => {
      let body = document.body, checkThemeClass = /* @__PURE__ */ __name((targetNode) => targetNode.classList.contains("dark-theme") ? "dark" : targetNode.classList.contains("light-theme") ? "light" : null, "checkThemeClass"), initialTheme = checkThemeClass(body);
      if (initialTheme) {
        cachedTheme = initialTheme;
        let cacheDiv = document.getElementById("rovalra-theme-cache");
        cacheDiv || (cacheDiv = document.createElement("div"), cacheDiv.id = "rovalra-theme-cache", cacheDiv.style.display = "none", document.body.appendChild(cacheDiv)), cacheDiv.dataset.theme = initialTheme, resolve(initialTheme);
        return;
      }
      let themeObserver = new MutationObserver((mutations) => {
        for (let mutation of mutations)
          if (mutation.type === "attributes" && mutation.attributeName === "class") {
            let theme = checkThemeClass(mutation.target);
            if (theme) {
              cachedTheme = theme;
              let cacheDiv = document.getElementById("rovalra-theme-cache");
              cacheDiv || (cacheDiv = document.createElement("div"), cacheDiv.id = "rovalra-theme-cache", cacheDiv.style.display = "none", document.body.appendChild(cacheDiv)), cacheDiv.dataset.theme = theme, themeObserver.disconnect(), resolve(theme);
              return;
            }
          }
      });
      themeObserver.observe(body, { attributes: !0 });
    });
  }
  __name(detectTheme, "detectTheme");
  function dispatchThemeEvent(theme) {
    let themeEvent = new CustomEvent("themeDetected", {
      detail: { theme }
    });
    window.dispatchEvent(themeEvent), document.body.classList.toggle("dark-theme", theme === "dark"), document.body.classList.toggle("light-theme", theme === "light");
  }
  __name(dispatchThemeEvent, "dispatchThemeEvent");

  // src/content/core/ui/closeButton.js
  function createCloseButton({ onClick: onClick2 } = {}) {
    let closeButton = document.createElement("button");
    closeButton.type = "button", closeButton.setAttribute("aria-label", "Close"), closeButton.className = "foundation-web-close-affordance flex stroke-none bg-none cursor-pointer relative clip group/interactable focus-visible:outline-focus disabled:outline-none bg-over-media-100 padding-medium radius-circle";
    let closeButtonHoverEffect = document.createElement("div");
    closeButtonHoverEffect.setAttribute("role", "presentation"), closeButtonHoverEffect.className = "absolute inset-[0] transition-colors group-hover/interactable:bg-[var(--color-state-hover)] group-active/interactable:bg-[var(--color-state-press)] group-disabled/interactable:bg-none";
    let closeButtonIcon = document.createElement("span");
    return closeButtonIcon.setAttribute("role", "presentation"), closeButtonIcon.className = "grow-0 shrink-0 basis-auto icon icon-regular-x size-[var(--icon-size-large)]", closeButton.append(closeButtonHoverEffect, closeButtonIcon), onClick2 && closeButton.addEventListener("click", onClick2), closeButton;
  }
  __name(createCloseButton, "createCloseButton");

  // src/content/core/assets.js
  var assetPaths = {
    rovalraIcon: "public/Assets/icon-128.png",
    ratBadgeIcon: "https://www.rovalra.com/static/img/return_request.png",
    fishConfetti: "https://www.rovalra.com/static/img/fishstrap.png",
    rolimonsIcon: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1094 1466.2"><path fill="#0084dd" d="M1094 521.6 0 0v469.5l141-67.4 250 119.2L0 707.8v369.7l815.6 388.7L315 893l779-371.4z"></path></svg>')}`,
    onboarding: "public/Assets/onboarding.png",
    serverListJson: "public/Assets/data/ServerList.json",
    itemsJson: "public/Assets/data/items.json",
    globeInitializer: "public/Assets/data/globe_initializer.js",
    mapDark: "public/Assets/data/map_dark.png",
    mapLight: "public/Assets/data/map_light.png",
    // countriesJson: 'public/Assets/data/countries.json',
    verifiedBadge: "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 28 28' fill='none'%3E%3Cg clip-path='url(%23clip0_8_46)'%3E%3Crect x='5.88818' width='22.89' height='22.89' transform='rotate(15 5.88818 0)' fill='%230066FF'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M20.543 8.7508L20.549 8.7568C21.15 9.3578 21.15 10.3318 20.549 10.9328L11.817 19.6648L7.45 15.2968C6.85 14.6958 6.85 13.7218 7.45 13.1218L7.457 13.1148C8.058 12.5138 9.031 12.5138 9.633 13.1148L11.817 15.2998L18.367 8.7508C18.968 8.1498 19.942 8.1498 20.543 8.7508Z' fill='white'/%3E%3C/g%3E%3Cdefs%3E%3CclipPath id='clip0_8_46'%3E%3Crect width='28' height='28' fill='white'/%3E%3C/clipPath%3E%3C/defs%3E%3C/svg%3E",
    downloadIcon: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 20h14v-2H5zM19 9h-4V3H9v6H5l7 7z"></path></svg>')}`,
    priceFloorIcon: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8"></path></svg>')}`,
    TerminalIcon: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="white" d="M20 4H4c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.89-2-2-2m0 14H4V8h16zm-2-1h-6v-2h6zM7.5 17l-1.41-1.41L8.67 13l-2.59-2.59L7.5 9l4 4z"></path></svg>')}`,
    qolIcon: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M3 13h2v-2H3zm0 4h2v-2H3zm0-8h2V7H3zm4 4h14v-2H7zm0 4h14v-2H7zM7 7v2h14V7z"></path></svg>')}`,
    blahaj: "https://www.rovalra.com/static/img/blahaj.png"
  }, resolvedAssets = null;
  function getAssets() {
    if (resolvedAssets)
      return resolvedAssets;
    resolvedAssets = {};
    for (let key in assetPaths) {
      let path = assetPaths[key];
      path.startsWith("data:") || path.startsWith("http:") || path.startsWith("https:") ? resolvedAssets[key] = path : resolvedAssets[key] = chrome.runtime.getURL(path);
    }
    return resolvedAssets;
  }
  __name(getAssets, "getAssets");

  // src/content/core/ui/general/toast.js
  function createAssetIcon({ assetName = "rovalraIcon", altText = "Icon", width = "24px", height = "24px" } = {}) {
    let assets3 = getAssets();
    if (!assets3[assetName]) return null;
    let icon = document.createElement("img");
    return icon.src = assets3[assetName], icon.alt = altText, icon.style.width = width, icon.style.height = height, icon;
  }
  __name(createAssetIcon, "createAssetIcon");

  // node_modules/dompurify/dist/purify.es.mjs
  var {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor
  } = Object, {
    freeze,
    seal,
    create
  } = Object, {
    apply,
    construct
  } = typeof Reflect < "u" && Reflect;
  freeze || (freeze = /* @__PURE__ */ __name(function(x2) {
    return x2;
  }, "freeze"));
  seal || (seal = /* @__PURE__ */ __name(function(x2) {
    return x2;
  }, "seal"));
  apply || (apply = /* @__PURE__ */ __name(function(func, thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
      args[_key - 2] = arguments[_key];
    return func.apply(thisArg, args);
  }, "apply"));
  construct || (construct = /* @__PURE__ */ __name(function(Func) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
      args[_key2 - 1] = arguments[_key2];
    return new Func(...args);
  }, "construct"));
  var arrayForEach = unapply(Array.prototype.forEach), arrayLastIndexOf = unapply(Array.prototype.lastIndexOf), arrayPop = unapply(Array.prototype.pop), arrayPush = unapply(Array.prototype.push), arraySplice = unapply(Array.prototype.splice), stringToLowerCase = unapply(String.prototype.toLowerCase), stringToString = unapply(String.prototype.toString), stringMatch = unapply(String.prototype.match), stringReplace = unapply(String.prototype.replace), stringIndexOf = unapply(String.prototype.indexOf), stringTrim = unapply(String.prototype.trim), objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty), regExpTest = unapply(RegExp.prototype.test), typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      thisArg instanceof RegExp && (thisArg.lastIndex = 0);
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)
        args[_key3 - 1] = arguments[_key3];
      return apply(func, thisArg, args);
    };
  }
  __name(unapply, "unapply");
  function unconstruct(Func) {
    return function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)
        args[_key4] = arguments[_key4];
      return construct(Func, args);
    };
  }
  __name(unconstruct, "unconstruct");
  function addToSet(set, array) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
    setPrototypeOf && setPrototypeOf(set, null);
    let l = array.length;
    for (; l--; ) {
      let element = array[l];
      if (typeof element == "string") {
        let lcElement = transformCaseFunc(element);
        lcElement !== element && (isFrozen(array) || (array[l] = lcElement), element = lcElement);
      }
      set[element] = !0;
    }
    return set;
  }
  __name(addToSet, "addToSet");
  function cleanArray(array) {
    for (let index = 0; index < array.length; index++)
      objectHasOwnProperty(array, index) || (array[index] = null);
    return array;
  }
  __name(cleanArray, "cleanArray");
  function clone(object) {
    let newObject = create(null);
    for (let [property, value] of entries(object))
      objectHasOwnProperty(object, property) && (Array.isArray(value) ? newObject[property] = cleanArray(value) : value && typeof value == "object" && value.constructor === Object ? newObject[property] = clone(value) : newObject[property] = value);
    return newObject;
  }
  __name(clone, "clone");
  function lookupGetter(object, prop) {
    for (; object !== null; ) {
      let desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get)
          return unapply(desc.get);
        if (typeof desc.value == "function")
          return unapply(desc.value);
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue() {
      return null;
    }
    return __name(fallbackValue, "fallbackValue"), fallbackValue;
  }
  __name(lookupGetter, "lookupGetter");
  var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), text = freeze(["#text"]), html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm), ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm), TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm), DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/), ARIA_ATTR = seal(/^aria-[\-\w]+$/), IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  ), IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i), ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  ), DOCTYPE_NAME = seal(/^html$/i), CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i), EXPRESSIONS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT,
    DATA_ATTR,
    DOCTYPE_NAME,
    ERB_EXPR,
    IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR,
    TMPLIT_EXPR
  }), NODE_TYPE = {
    element: 1,
    attribute: 2,
    text: 3,
    cdataSection: 4,
    entityReference: 5,
    // Deprecated
    entityNode: 6,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9,
    documentType: 10,
    documentFragment: 11,
    notation: 12
    // Deprecated
  }, getGlobal = /* @__PURE__ */ __name(function() {
    return typeof window > "u" ? null : window;
  }, "getGlobal"), _createTrustedTypesPolicy = /* @__PURE__ */ __name(function(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes != "object" || typeof trustedTypes.createPolicy != "function")
      return null;
    let suffix = null, ATTR_NAME = "data-tt-policy-suffix";
    purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME) && (suffix = purifyHostElement.getAttribute(ATTR_NAME));
    let policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html2) {
          return html2;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch {
      return console.warn("TrustedTypes policy " + policyName + " could not be created."), null;
    }
  }, "_createTrustedTypesPolicy"), _createHooksMap = /* @__PURE__ */ __name(function() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  }, "_createHooksMap");
  function createDOMPurify() {
    let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal(), DOMPurify = /* @__PURE__ */ __name((root) => createDOMPurify(root), "DOMPurify");
    if (DOMPurify.version = "3.3.1", DOMPurify.removed = [], !window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element)
      return DOMPurify.isSupported = !1, DOMPurify;
    let {
      document: document2
    } = window2, originalDocument = document2, currentScript = originalDocument.currentScript, {
      DocumentFragment,
      HTMLTemplateElement,
      Node: Node2,
      Element,
      NodeFilter,
      NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser: DOMParser2,
      trustedTypes
    } = window2, ElementPrototype = Element.prototype, cloneNode = lookupGetter(ElementPrototype, "cloneNode"), remove = lookupGetter(ElementPrototype, "remove"), getNextSibling = lookupGetter(ElementPrototype, "nextSibling"), getChildNodes = lookupGetter(ElementPrototype, "childNodes"), getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement == "function") {
      let template = document2.createElement("template");
      template.content && template.content.ownerDocument && (document2 = template.content.ownerDocument);
    }
    let trustedTypesPolicy, emptyHTML = "", {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document2, {
      importNode
    } = originalDocument, hooks = _createHooksMap();
    DOMPurify.isSupported = typeof entries == "function" && typeof getParentNode == "function" && implementation && implementation.createHTMLDocument !== void 0;
    let {
      MUSTACHE_EXPR: MUSTACHE_EXPR2,
      ERB_EXPR: ERB_EXPR2,
      TMPLIT_EXPR: TMPLIT_EXPR2,
      DATA_ATTR: DATA_ATTR2,
      ARIA_ATTR: ARIA_ATTR2,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
      ATTR_WHITESPACE: ATTR_WHITESPACE2,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT2
    } = EXPRESSIONS, {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS, ALLOWED_TAGS = null, DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]), ALLOWED_ATTR = null, DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]), CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
      tagNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      attributeNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: !1
      }
    })), FORBID_TAGS = null, FORBID_ATTR = null, EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {
      tagCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      attributeCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      }
    })), ALLOW_ARIA_ATTR = !0, ALLOW_DATA_ATTR = !0, ALLOW_UNKNOWN_PROTOCOLS = !1, ALLOW_SELF_CLOSE_IN_ATTR = !0, SAFE_FOR_TEMPLATES = !1, SAFE_FOR_XML = !0, WHOLE_DOCUMENT = !1, SET_CONFIG = !1, FORCE_BODY = !1, RETURN_DOM = !1, RETURN_DOM_FRAGMENT = !1, RETURN_TRUSTED_TYPE = !1, SANITIZE_DOM = !0, SANITIZE_NAMED_PROPS = !1, SANITIZE_NAMED_PROPS_PREFIX = "user-content-", KEEP_CONTENT = !0, IN_PLACE = !1, USE_PROFILES = {}, FORBID_CONTENTS = null, DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), DATA_URI_TAGS = null, DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]), URI_SAFE_ATTRIBUTES = null, DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", HTML_NAMESPACE = "http://www.w3.org/1999/xhtml", NAMESPACE = HTML_NAMESPACE, IS_EMPTY_INPUT = !1, ALLOWED_NAMESPACES = null, DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString), MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]), HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]), COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]), PARSER_MEDIA_TYPE = null, SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"], DEFAULT_PARSER_MEDIA_TYPE = "text/html", transformCaseFunc = null, CONFIG2 = null, formElement = document2.createElement("form"), isRegexOrFunction = /* @__PURE__ */ __name(function(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    }, "isRegexOrFunction"), _parseConfig = /* @__PURE__ */ __name(function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!(CONFIG2 && CONFIG2 === cfg)) {
        if ((!cfg || typeof cfg != "object") && (cfg = {}), cfg = clone(cfg), PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE, transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase, ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS, ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR, ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES, URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES, DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS, FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS, FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({}), FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({}), USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : !1, ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== !1, ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== !1, ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || !1, ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== !1, SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || !1, SAFE_FOR_XML = cfg.SAFE_FOR_XML !== !1, WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || !1, RETURN_DOM = cfg.RETURN_DOM || !1, RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || !1, RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || !1, FORCE_BODY = cfg.FORCE_BODY || !1, SANITIZE_DOM = cfg.SANITIZE_DOM !== !1, SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || !1, KEEP_CONTENT = cfg.KEEP_CONTENT !== !1, IN_PLACE = cfg.IN_PLACE || !1, IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI, NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE, MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS, HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS, CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {}, cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck), cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), SAFE_FOR_TEMPLATES && (ALLOW_DATA_ATTR = !1), RETURN_DOM_FRAGMENT && (RETURN_DOM = !0), USE_PROFILES && (ALLOWED_TAGS = addToSet({}, text), ALLOWED_ATTR = [], USE_PROFILES.html === !0 && (addToSet(ALLOWED_TAGS, html$1), addToSet(ALLOWED_ATTR, html)), USE_PROFILES.svg === !0 && (addToSet(ALLOWED_TAGS, svg$1), addToSet(ALLOWED_ATTR, svg), addToSet(ALLOWED_ATTR, xml)), USE_PROFILES.svgFilters === !0 && (addToSet(ALLOWED_TAGS, svgFilters), addToSet(ALLOWED_ATTR, svg), addToSet(ALLOWED_ATTR, xml)), USE_PROFILES.mathMl === !0 && (addToSet(ALLOWED_TAGS, mathMl$1), addToSet(ALLOWED_ATTR, mathMl), addToSet(ALLOWED_ATTR, xml))), cfg.ADD_TAGS && (typeof cfg.ADD_TAGS == "function" ? EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS : (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS && (ALLOWED_TAGS = clone(ALLOWED_TAGS)), addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc))), cfg.ADD_ATTR && (typeof cfg.ADD_ATTR == "function" ? EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR : (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR && (ALLOWED_ATTR = clone(ALLOWED_ATTR)), addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc))), cfg.ADD_URI_SAFE_ATTR && addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc), cfg.FORBID_CONTENTS && (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS && (FORBID_CONTENTS = clone(FORBID_CONTENTS)), addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc)), cfg.ADD_FORBID_CONTENTS && (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS && (FORBID_CONTENTS = clone(FORBID_CONTENTS)), addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc)), KEEP_CONTENT && (ALLOWED_TAGS["#text"] = !0), WHOLE_DOCUMENT && addToSet(ALLOWED_TAGS, ["html", "head", "body"]), ALLOWED_TAGS.table && (addToSet(ALLOWED_TAGS, ["tbody"]), delete FORBID_TAGS.tbody), cfg.TRUSTED_TYPES_POLICY) {
          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML != "function")
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL != "function")
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY, emptyHTML = trustedTypesPolicy.createHTML("");
        } else
          trustedTypesPolicy === void 0 && (trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript)), trustedTypesPolicy !== null && typeof emptyHTML == "string" && (emptyHTML = trustedTypesPolicy.createHTML(""));
        freeze && freeze(cfg), CONFIG2 = cfg;
      }
    }, "_parseConfig"), ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]), ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]), _checkValidNamespace = /* @__PURE__ */ __name(function(element) {
      let parent = getParentNode(element);
      (!parent || !parent.tagName) && (parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      });
      let tagName = stringToLowerCase(element.tagName), parentTagName = stringToLowerCase(parent.tagName);
      return ALLOWED_NAMESPACES[element.namespaceURI] ? element.namespaceURI === SVG_NAMESPACE ? parent.namespaceURI === HTML_NAMESPACE ? tagName === "svg" : parent.namespaceURI === MATHML_NAMESPACE ? tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) : !!ALL_SVG_TAGS[tagName] : element.namespaceURI === MATHML_NAMESPACE ? parent.namespaceURI === HTML_NAMESPACE ? tagName === "math" : parent.namespaceURI === SVG_NAMESPACE ? tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName] : !!ALL_MATHML_TAGS[tagName] : element.namespaceURI === HTML_NAMESPACE ? parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName] || parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName] ? !1 : !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]) : !!(PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) : !1;
    }, "_checkValidNamespace"), _forceRemove = /* @__PURE__ */ __name(function(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });
      try {
        getParentNode(node).removeChild(node);
      } catch {
        remove(node);
      }
    }, "_forceRemove"), _removeAttribute = /* @__PURE__ */ __name(function(name, element) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: element.getAttributeNode(name),
          from: element
        });
      } catch {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: element
        });
      }
      if (element.removeAttribute(name), name === "is")
        if (RETURN_DOM || RETURN_DOM_FRAGMENT)
          try {
            _forceRemove(element);
          } catch {
          }
        else
          try {
            element.setAttribute(name, "");
          } catch {
          }
    }, "_removeAttribute"), _initDocument = /* @__PURE__ */ __name(function(dirty) {
      let doc = null, leadingWhitespace = null;
      if (FORCE_BODY)
        dirty = "<remove></remove>" + dirty;
      else {
        let matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE && (dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>");
      let dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE)
        try {
          doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch {
        }
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch {
        }
      }
      let body = doc.body || doc.documentElement;
      return dirty && leadingWhitespace && body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null), NAMESPACE === HTML_NAMESPACE ? getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0] : WHOLE_DOCUMENT ? doc.documentElement : body;
    }, "_initDocument"), _createNodeIterator = /* @__PURE__ */ __name(function(root) {
      return createNodeIterator.call(
        root.ownerDocument || root,
        root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
        null
      );
    }, "_createNodeIterator"), _isClobbered = /* @__PURE__ */ __name(function(element) {
      return element instanceof HTMLFormElement && (typeof element.nodeName != "string" || typeof element.textContent != "string" || typeof element.removeChild != "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute != "function" || typeof element.setAttribute != "function" || typeof element.namespaceURI != "string" || typeof element.insertBefore != "function" || typeof element.hasChildNodes != "function");
    }, "_isClobbered"), _isNode = /* @__PURE__ */ __name(function(value) {
      return typeof Node2 == "function" && value instanceof Node2;
    }, "_isNode");
    function _executeHooks(hooks2, currentNode, data) {
      arrayForEach(hooks2, (hook) => {
        hook.call(DOMPurify, currentNode, data, CONFIG2);
      });
    }
    __name(_executeHooks, "_executeHooks");
    let _sanitizeElements = /* @__PURE__ */ __name(function(currentNode) {
      let content = null;
      if (_executeHooks(hooks.beforeSanitizeElements, currentNode, null), _isClobbered(currentNode))
        return _forceRemove(currentNode), !0;
      let tagName = transformCaseFunc(currentNode.nodeName);
      if (_executeHooks(hooks.uponSanitizeElement, currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      }), SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent) || currentNode.nodeType === NODE_TYPE.progressingInstruction || SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data))
        return _forceRemove(currentNode), !0;
      if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)))
          return !1;
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          let parentNode = getParentNode(currentNode) || currentNode.parentNode, childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            let childCount = childNodes.length;
            for (let i = childCount - 1; i >= 0; --i) {
              let childClone = cloneNode(childNodes[i], !0);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1, parentNode.insertBefore(childClone, getNextSibling(currentNode));
            }
          }
        }
        return _forceRemove(currentNode), !0;
      }
      return currentNode instanceof Element && !_checkValidNamespace(currentNode) || (tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML) ? (_forceRemove(currentNode), !0) : (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text && (content = currentNode.textContent, arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        content = stringReplace(content, expr, " ");
      }), currentNode.textContent !== content && (arrayPush(DOMPurify.removed, {
        element: currentNode.cloneNode()
      }), currentNode.textContent = content)), _executeHooks(hooks.afterSanitizeElements, currentNode, null), !1);
    }, "_sanitizeElements"), _isValidAttribute = /* @__PURE__ */ __name(function(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement))
        return !1;
      if (!(ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName))) {
        if (!(ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName))) {
          if (!(EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag))) {
            if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
              if (
                // First condition does a very basic check if a) it's basically a valid custom element tagname AND
                // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                !(_isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
              ) return !1;
            } else if (!URI_SAFE_ATTRIBUTES[lcName]) {
              if (!regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) {
                if (!((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])) {
                  if (!(ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, "")))) {
                    if (value)
                      return !1;
                  }
                }
              }
            }
          }
        }
      }
      return !0;
    }, "_isValidAttribute"), _isBasicCustomElement = /* @__PURE__ */ __name(function(tagName) {
      return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
    }, "_isBasicCustomElement"), _sanitizeAttributes = /* @__PURE__ */ __name(function(currentNode) {
      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
      let {
        attributes
      } = currentNode;
      if (!attributes || _isClobbered(currentNode))
        return;
      let hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: void 0
      }, l = attributes.length;
      for (; l--; ) {
        let attr = attributes[l], {
          name,
          namespaceURI,
          value: attrValue
        } = attr, lcName = transformCaseFunc(name), initValue = attrValue, value = name === "value" ? initValue : stringTrim(initValue);
        if (hookEvent.attrName = lcName, hookEvent.attrValue = value, hookEvent.keepAttr = !0, hookEvent.forceKeepAttr = void 0, _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent), value = hookEvent.attrValue, SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name") && (_removeAttribute(name, currentNode), value = SANITIZE_NAMED_PROPS_PREFIX + value), SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (lcName === "attributename" && stringMatch(value, "href")) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (hookEvent.forceKeepAttr)
          continue;
        if (!hookEvent.keepAttr) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        SAFE_FOR_TEMPLATES && arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          value = stringReplace(value, expr, " ");
        });
        let lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (trustedTypesPolicy && typeof trustedTypes == "object" && typeof trustedTypes.getAttributeType == "function" && !namespaceURI)
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        if (value !== initValue)
          try {
            namespaceURI ? currentNode.setAttributeNS(namespaceURI, name, value) : currentNode.setAttribute(name, value), _isClobbered(currentNode) ? _forceRemove(currentNode) : arrayPop(DOMPurify.removed);
          } catch {
            _removeAttribute(name, currentNode);
          }
      }
      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    }, "_sanitizeAttributes"), _sanitizeShadowDOM = /* @__PURE__ */ __name(function _sanitizeShadowDOM2(fragment) {
      let shadowNode = null, shadowIterator = _createNodeIterator(fragment);
      for (_executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null); shadowNode = shadowIterator.nextNode(); )
        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null), _sanitizeElements(shadowNode), _sanitizeAttributes(shadowNode), shadowNode.content instanceof DocumentFragment && _sanitizeShadowDOM2(shadowNode.content);
      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    }, "_sanitizeShadowDOM");
    return DOMPurify.sanitize = function(dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, body = null, importedNode = null, currentNode = null, returnNode = null;
      if (IS_EMPTY_INPUT = !dirty, IS_EMPTY_INPUT && (dirty = "<!-->"), typeof dirty != "string" && !_isNode(dirty))
        if (typeof dirty.toString == "function") {
          if (dirty = dirty.toString(), typeof dirty != "string")
            throw typeErrorCreate("dirty is not a string, aborting");
        } else
          throw typeErrorCreate("toString is not a function");
      if (!DOMPurify.isSupported)
        return dirty;
      if (SET_CONFIG || _parseConfig(cfg), DOMPurify.removed = [], typeof dirty == "string" && (IN_PLACE = !1), IN_PLACE) {
        if (dirty.nodeName) {
          let tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (dirty instanceof Node2)
        body = _initDocument("<!---->"), importedNode = body.ownerDocument.importNode(dirty, !0), importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY" || importedNode.nodeName === "HTML" ? body = importedNode : body.appendChild(importedNode);
      else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf("<") === -1)
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        if (body = _initDocument(dirty), !body)
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
      body && FORCE_BODY && _forceRemove(body.firstChild);
      let nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      for (; currentNode = nodeIterator.nextNode(); )
        _sanitizeElements(currentNode), _sanitizeAttributes(currentNode), currentNode.content instanceof DocumentFragment && _sanitizeShadowDOM(currentNode.content);
      if (IN_PLACE)
        return dirty;
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT)
          for (returnNode = createDocumentFragment.call(body.ownerDocument); body.firstChild; )
            returnNode.appendChild(body.firstChild);
        else
          returnNode = body;
        return (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) && (returnNode = importNode.call(originalDocument, returnNode, !0)), returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      return WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name) && (serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + `>
` + serializedHTML), SAFE_FOR_TEMPLATES && arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        serializedHTML = stringReplace(serializedHTML, expr, " ");
      }), trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    }, DOMPurify.setConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _parseConfig(cfg), SET_CONFIG = !0;
    }, DOMPurify.clearConfig = function() {
      CONFIG2 = null, SET_CONFIG = !1;
    }, DOMPurify.isValidAttribute = function(tag, attr, value) {
      CONFIG2 || _parseConfig({});
      let lcTag = transformCaseFunc(tag), lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    }, DOMPurify.addHook = function(entryPoint, hookFunction) {
      typeof hookFunction == "function" && arrayPush(hooks[entryPoint], hookFunction);
    }, DOMPurify.removeHook = function(entryPoint, hookFunction) {
      if (hookFunction !== void 0) {
        let index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
        return index === -1 ? void 0 : arraySplice(hooks[entryPoint], index, 1)[0];
      }
      return arrayPop(hooks[entryPoint]);
    }, DOMPurify.removeHooks = function(entryPoint) {
      hooks[entryPoint] = [];
    }, DOMPurify.removeAllHooks = function() {
      hooks = _createHooksMap();
    }, DOMPurify;
  }
  __name(createDOMPurify, "createDOMPurify");
  var purify = createDOMPurify();

  // src/content/core/ui/overlay.js
  function createOverlay({
    title,
    bodyContent,
    actions = [],
    maxWidth = "550px",
    maxHeight = "calc(100vh - 60px)",
    showLogo = !1,
    preventBackdropClose = !1,
    onClose,
    overflowVisible = !1
  }) {
    let overlay = document.createElement("div");
    overlay.className = "rovalra-global-overlay";
    let content = document.createElement("div");
    content.className = "rovalra-overlay-content", content.setAttribute("role", "dialog"), content.style.maxWidth = maxWidth, content.style.maxHeight = maxHeight, content.style.display = "flex", content.style.flexDirection = "column", overflowVisible ? content.style.overflow = "visible" : (content.style.overflow = "clip", content.style.overflowClipMargin = "30px");
    let closeButtonContainer = document.createElement("div");
    closeButtonContainer.className = "rovalra-overlay-close";
    let body = document.createElement("div");
    body.className = "rovalra-overlay-body", body.style.flex = "1", overflowVisible ? body.style.overflowY = "visible" : body.style.overflowY = "auto", body.style.minHeight = "0";
    let titleElement = document.createElement("div");
    if (titleElement.className = "rovalra-overlay-header", titleElement.style.display = "flex", titleElement.style.alignItems = "center", titleElement.style.flexShrink = "0", showLogo) {
      let assetName = typeof showLogo == "string" ? showLogo : "rovalraIcon", logo = createAssetIcon({
        assetName,
        altText: assetName === "rovalraIcon" ? "RoValra Logo" : "Icon",
        width: "24px",
        height: "24px"
      });
      logo && (logo.style.marginRight = "8px", logo.style.flexShrink = "0", titleElement.prepend(logo));
    }
    let titleSpan = document.createElement("span");
    if (titleSpan.textContent = title, titleSpan.style.wordBreak = "break-word", titleSpan.style.minWidth = "0", titleElement.appendChild(titleSpan), content.appendChild(titleElement), typeof bodyContent == "string") {
      let bodyContentContainer = document.createElement("div");
      bodyContentContainer.innerHTML = purify.sanitize(bodyContent), body.appendChild(bodyContentContainer);
    } else bodyContent instanceof HTMLElement && body.appendChild(bodyContent);
    if (content.appendChild(body), actions.length > 0) {
      let footer = document.createElement("div");
      footer.className = "rovalra-overlay-footer", footer.style.flexShrink = "0", actions.forEach((button) => footer.appendChild(button)), content.appendChild(footer);
    }
    overlay.appendChild(content), document.body.appendChild(overlay), document.body.style.overflow = "hidden";
    let close = /* @__PURE__ */ __name(() => {
      overlay.remove(), document.body.style.overflow = "", typeof onClose == "function" && onClose();
    }, "close"), closeButton = createCloseButton({ onClick: close });
    return closeButtonContainer.appendChild(closeButton), content.appendChild(closeButtonContainer), preventBackdropClose || overlay.addEventListener("click", (e) => {
      e.target === overlay && close();
    }), { overlay, close };
  }
  __name(createOverlay, "createOverlay");

  // src/content/core/ui/buttons.js
  function createButton(text2, type = "secondary", options = {}) {
    let button = document.createElement("button");
    button.textContent = text2;
    let baseClass = "btn-control-md";
    return type === "primary" ? baseClass = "btn-primary-md" : (type === "alert" || type === "primary-destructive") && (baseClass = "btn-alert-md"), button.className = `${baseClass} rovalra-ui-btn rovalra-btn-${type}`, options.id && (button.id = options.id), typeof options.onClick == "function" && button.addEventListener("click", options.onClick), options.disabled && (button.disabled = !0), button;
  }
  __name(createButton, "createButton");

  // src/content/features/onboarding/onboarding.js
  function init() {
    chrome.storage.local.get({ onboardingShown: !1 }, function(settings) {
      if (!settings.onboardingShown) {
        let bodyContent = document.createElement("div"), assets3 = getAssets();
        bodyContent.style.maxHeight = "calc(90vh - 150px)", bodyContent.style.overflowY = "auto", bodyContent.innerHTML = `
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    Thank you for installing <strong>RoValra</strong>!
                </p>

                <p style="line-height: 1.6; margin-bottom: 15px;">
                    To change settings and explore all features, you can:
                </p>
                <ul style="list-style-type: disc; margin-left: 20px; margin-bottom: 15px; line-height: 1.6;">
                    <li>Click the <strong>gear icon</strong> in the Roblox header, and then click on "RoValra Setting".</li>
                   
                </ul>

                <img src="${assets3.onboarding}" alt="A guide showing where to find the RoValra settings button on the Roblox website." style="max-width: 100%; height: auto; display: block; margin: 5px auto 20px auto; border-radius: 8px; border: 1px solid var(--rovalra-overlay-border-primary, #D9DADB);"/>

                <p style="line-height: 1.6;">
                    RoValra is a forever free Roblox extension trying to provide quality of life to everyone!
                </p>
            `;
        let acknowledgeOnboarding = /* @__PURE__ */ __name(() => {
          chrome.storage.local.set({ onboardingShown: !0 }, function() {
            console.log("RoValra: Onboarding acknowledged and marked as shown.");
          });
        }, "acknowledgeOnboarding"), gotItButton = createButton("Got It!", "primary"), { close } = createOverlay({
          title: "Welcome to RoValra!",
          bodyContent,
          actions: [gotItButton],
          maxWidth: "min(550px, 90vw)",
          showLogo: !0,
          preventBackdropClose: !0,
          onClose: acknowledgeOnboarding
        });
        gotItButton.addEventListener("click", () => {
          close();
        });
      }
    });
  }
  __name(init, "init");

  // src/content/core/idExtractor.js
  function getPlaceIdFromUrl(url = window.location.href) {
    try {
      let urlObj = new URL(url, window.location.origin), queryPlaceId = urlObj.searchParams.get("PlaceId");
      if (queryPlaceId)
        return queryPlaceId;
      let match2 = urlObj.pathname.match(/^(?:\/[a-z]{2}(?:-[a-z]{2})?)?\/(?:games|catalog|bundles|library|game-pass)\/(\d+)/i);
      if (match2 && match2[1])
        return match2[1];
    } catch (e) {
      console.warn("RoValra: URL parsing failed", e);
    }
    let match = url.match(/\/(?:games|catalog|bundles|library|game-pass)\/(\d+)/);
    return match ? match[1] : null;
  }
  __name(getPlaceIdFromUrl, "getPlaceIdFromUrl");
  function getAssetIdFromUrl(url = window.location.href) {
    try {
      let match2 = new URL(url, window.location.origin).pathname.match(/^(?:\/[a-z]{2}(?:-[a-z]{2})?)?\/store\/asset\/(\d+)/i);
      if (match2 && match2[1])
        return match2[1];
    } catch (e) {
      console.warn("RoValra: URL parsing failed", e);
    }
    let match = url.match(/\/store\/asset\/(\d+)/);
    return match ? match[1] : null;
  }
  __name(getAssetIdFromUrl, "getAssetIdFromUrl");
  function getUserIdFromUrl(url = window.location.href) {
    try {
      let match2 = new URL(url, window.location.origin).pathname.match(/^(?:\/[a-z]{2}(?:-[a-z]{2})?)?\/users\/(\d+)\/profile/i);
      if (match2 && match2[1])
        return match2[1];
    } catch (e) {
      console.warn("RoValra: URL parsing failed", e);
    }
    let match = url.match(/\/users\/(\d+)\/profile/);
    return match ? match[1] : null;
  }
  __name(getUserIdFromUrl, "getUserIdFromUrl");

  // src/content/core/utils.js
  var getCsrfToken = (() => {
    let csrfToken = null, pendingPromise2 = null, fetchToken = /* @__PURE__ */ __name(async () => {
      try {
        let metaTag = document.querySelector('meta[name="csrf-token"]');
        if (metaTag?.dataset?.token)
          return csrfToken = metaTag.dataset.token, csrfToken;
      } catch (error) {
        return console.error("RoValra (Utils): Failed to get CSRF token.", error), pendingPromise2 = null, null;
      }
    }, "fetchToken"), getToken = /* @__PURE__ */ __name(() => csrfToken ? Promise.resolve(csrfToken) : pendingPromise2 || (pendingPromise2 = fetchToken()), "getToken");
    return getToken.setToken = (newToken) => {
      csrfToken = newToken, pendingPromise2 = null;
    }, getToken;
  })();
  async function getUsernameFromPageData() {
    let userId = getUserIdFromUrl();
    if (!userId)
      return null;
    try {
      let response = await callRobloxApi({
        subdomain: "users",
        endpoint: `/v1/users/${userId}`,
        method: "GET"
      });
      if (response.ok)
        return (await response.json()).name;
    } catch {
    }
    return null;
  }
  __name(getUsernameFromPageData, "getUsernameFromPageData");
  async function getDisplayNameFromPageData() {
    let userId = getUserIdFromUrl();
    if (!userId)
      return null;
    try {
      let response = await callRobloxApi({
        subdomain: "users",
        endpoint: `/v1/users/${userId}`,
        method: "GET"
      });
      if (response.ok)
        return (await response.json()).displayName;
    } catch {
    }
    return null;
  }
  __name(getDisplayNameFromPageData, "getDisplayNameFromPageData");

  // src/content/core/user.js
  function waitForDom() {
    return new Promise((resolve) => {
      document.readyState !== "loading" ? resolve() : document.addEventListener("DOMContentLoaded", resolve, { once: !0 });
    });
  }
  __name(waitForDom, "waitForDom");
  async function getAuthenticatedUserId() {
    await waitForDom();
    let userDataMeta = document.querySelector('meta[name="user-data"]');
    if (userDataMeta) {
      let userId = userDataMeta.getAttribute("data-userid");
      if (userId)
        return parseInt(userId, 10);
    }
    return null;
  }
  __name(getAuthenticatedUserId, "getAuthenticatedUserId");
  async function getAuthenticatedUsername() {
    await waitForDom();
    let userDataMeta = document.querySelector('meta[name="user-data"]');
    if (userDataMeta) {
      let username = userDataMeta.getAttribute("data-name");
      if (username)
        return username;
    }
    return null;
  }
  __name(getAuthenticatedUsername, "getAuthenticatedUsername");

  // src/content/core/oauth/oauth.js
  var STORAGE_KEY = "rovalra_oauth_verification", TOKEN_EXPIRATION_BUFFER_MS = 300 * 1e3, existenceCache = /* @__PURE__ */ new Map(), prefixCache = /* @__PURE__ */ new Map(), activeOAuthPromise = null;
  async function getValidAccessToken(forceRefresh = !1) {
    let userId = await getAuthenticatedUserId();
    if (!userId) return null;
    let storedVerification = ((await chrome.storage.local.get(STORAGE_KEY))[STORAGE_KEY] || {})[userId];
    if (!storedVerification || !storedVerification.accessToken)
      return await startOAuthFlow(!0) && (await chrome.storage.local.get(STORAGE_KEY))[STORAGE_KEY]?.[userId]?.accessToken || null;
    if (storedVerification.robloxId != userId)
      return await startOAuthFlow(!0) && (await chrome.storage.local.get(STORAGE_KEY))[STORAGE_KEY]?.[userId]?.accessToken || null;
    let isExpired = storedVerification.expiresAt && Date.now() > storedVerification.expiresAt - TOKEN_EXPIRATION_BUFFER_MS;
    if (!forceRefresh && !isExpired)
      return storedVerification.accessToken;
    try {
      let response = await callRobloxApi({
        isRovalraApi: !0,
        subdomain: "apis",
        endpoint: "/v1/auth/badges",
        headers: { Authorization: `Bearer ${storedVerification.accessToken}` },
        skipAutoAuth: !0,
        noCache: !0
      });
      return response.ok ? (await chrome.storage.local.get(STORAGE_KEY))[STORAGE_KEY]?.[userId]?.accessToken || storedVerification.accessToken : (console.warn(`RoValra: Session invalid (Status ${response.status}). Triggering re-auth...`), await startOAuthFlow(!0) && (await chrome.storage.local.get(STORAGE_KEY))[STORAGE_KEY]?.[userId]?.accessToken || null);
    } catch (error) {
      return console.error("RoValra: Network error during token sync:", error), storedVerification.accessToken;
    }
  }
  __name(getValidAccessToken, "getValidAccessToken");
  async function sha256(message) {
    let msgBuffer = new TextEncoder().encode(message), hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
    return Array.from(new Uint8Array(hashBuffer)).map((b2) => b2.toString(16).padStart(2, "0")).join("");
  }
  __name(sha256, "sha256");
  async function checkUserExistence(userId) {
    if (existenceCache.has(userId))
      return existenceCache.get(userId);
    try {
      let userIdHash = await sha256(userId.toString()), prefix = userIdHash.substring(0, 5), matches = prefixCache.get(prefix);
      if (!matches) {
        let response = await callRobloxApi({
          isRovalraApi: !0,
          subdomain: "apis",
          endpoint: `/v1/auth/existence/${prefix}`,
          method: "GET",
          skipAutoAuth: !0
        });
        if (response.ok) {
          let data = await response.json();
          data.status === "success" && Array.isArray(data.matches) && (matches = data.matches, prefixCache.set(prefix, matches));
        }
      }
      if (matches) {
        let exists = matches.includes(userIdHash);
        return existenceCache.set(userId, exists), exists;
      }
    } catch (error) {
      console.error("RoValra: Error checking user existence", error);
    }
    return !1;
  }
  __name(checkUserExistence, "checkUserExistence");
  async function startOAuthFlow(silent = !1) {
    let userId = await getAuthenticatedUserId();
    if (!userId) return !1;
    if (!silent)
      return console.warn("RoValra: Non-silent OAuth flow is not implemented as per the background-only request."), Promise.resolve(!1);
    if (activeOAuthPromise) return activeOAuthPromise;
    activeOAuthPromise = (async () => {
      try {
        let birthResponse = await callRobloxApi({
          subdomain: "users",
          endpoint: "/v1/birthdate",
          method: "GET"
        });
        if (birthResponse.ok) {
          let data = await birthResponse.json(), { birthYear, birthMonth, birthDay } = data, today = /* @__PURE__ */ new Date(), age = today.getFullYear() - birthYear, m2 = today.getMonth() + 1 - birthMonth;
          if ((m2 < 0 || m2 === 0 && today.getDate() < birthDay) && age--, age < 13)
            return console.log("RoValra: User is under 13. Skipping OAuth."), !1;
        }
      } catch (error) {
        console.warn("RoValra: Failed to check birthdate", error);
      }
      if (!await checkUserExistence(userId))
        return !1;
      try {
        console.log("RoValra: Attempting direct OAuth authorization POST request...");
        let response = await callRobloxApi({
          subdomain: "apis",
          endpoint: "/oauth/v1/authorizations",
          method: "POST",
          body: {
            clientId: "5835339573709822795",
            responseTypes: ["Code"],
            redirectUri: "https://apis.rovalra.com/v1/auth/callback",
            scopes: [
              { scopeType: "openid", operations: ["read"] },
              { scopeType: "profile", operations: ["read"] }
            ],
            resourceInfos: [{
              owner: { id: userId.toString(), type: "User" },
              resources: {}
            }]
          }
        });
        if (response.ok) {
          let authResponse = await response.json(), locationUrl = authResponse.location;
          if (!locationUrl)
            return console.error("RoValra: OAuth authorization response did not contain a location URL.", authResponse), !1;
          console.log("RoValra: Got authorization code. Fetching token from callback URL...");
          let tokenResponse = await callRobloxApi({
            fullUrl: locationUrl,
            method: "GET",
            isRovalraApi: !0
          });
          if (!tokenResponse.ok)
            return console.error("RoValra: Failed to get token from callback URL.", await tokenResponse.text()), !1;
          let tokenData = await tokenResponse.json();
          if (tokenData.status === "success" && tokenData.access_token && tokenData.user_id && tokenData.username) {
            console.log("RoValra: OAuth Successful!", tokenData);
            let expiresAt = tokenData.expires_at ? tokenData.expires_at * 1e3 : null, allVerifications = (await chrome.storage.local.get(STORAGE_KEY))[STORAGE_KEY] || {};
            return allVerifications[userId] = {
              verified: !0,
              robloxId: tokenData.user_id,
              username: tokenData.username,
              accessToken: tokenData.access_token,
              expiresAt,
              timestamp: Date.now()
            }, await chrome.storage.local.set({ [STORAGE_KEY]: allVerifications }), !0;
          } else
            return console.error("RoValra: Invalid token data received from backend.", tokenData), !1;
        } else
          return console.error("RoValra: OAuth authorization POST request failed with status " + response.status, await response.text()), !1;
      } catch (error) {
        return console.error("RoValra: Error during direct OAuth authorization request.", error), !1;
      }
    })();
    try {
      return await activeOAuthPromise;
    } finally {
      activeOAuthPromise = null;
    }
  }
  __name(startOAuthFlow, "startOAuthFlow");

  // src/content/core/utils/location.js
  var LOCATION_STORAGE_KEY = "robloxUserLocationCache", CACHE_DURATION_MS = 1e3 * 60 * 60 * 24, hasUpdatedLocation = !1;
  async function resolveGeoNames(lat, lon) {
    try {
      let gridLat = Math.floor(lat), gridLon = Math.floor(lon), response = await callRobloxApi({
        isRovalraApi: !0,
        subdomain: "www",
        endpoint: `/geolocation/${gridLat}.json`,
        method: "GET"
      });
      if (!response.ok) throw new Error("Latitude file not found");
      let locationInfo = (await response.json())[gridLon];
      return {
        country: locationInfo ? locationInfo.country : "Unknown",
        continent: locationInfo ? locationInfo.continent : "Unknown",
        countryCode: locationInfo ? locationInfo.code : "??"
      };
    } catch (e) {
      return console.error("Location Util: Static API lookup failed", e), { country: "Unknown", continent: "Unknown", countryCode: "??" };
    }
  }
  __name(resolveGeoNames, "resolveGeoNames");
  async function getUserLocation(placeId, forceRefresh = !1) {
    if (!forceRefresh)
      try {
        let storedData = await new Promise((resolve) => {
          typeof chrome > "u" || !chrome.storage ? resolve(null) : chrome.storage.local.get(LOCATION_STORAGE_KEY, (result) => {
            resolve(result[LOCATION_STORAGE_KEY]);
          });
        });
        if (storedData && storedData.timestamp && Date.now() - storedData.timestamp < CACHE_DURATION_MS)
          return storedData;
      } catch (e) {
        console.error("Location Util: Error reading storage", e);
      }
    console.log("Location Util: Fetching fresh user location via Roblox API...");
    try {
      let serverListRes = await callRobloxApi({
        subdomain: "games",
        endpoint: `/v1/games/${placeId}/servers/Public?limit=10&excludeFullGames=true`
      });
      if (!serverListRes.ok) return null;
      let servers = (await serverListRes.json()).data || [];
      for (let server of servers.slice(0, 3)) {
        let coords = await probeServerForLocation(placeId, server.id);
        if (coords) {
          let geoNames = await resolveGeoNames(coords.userLat, coords.userLon), cacheObject = {
            ...coords,
            ...geoNames,
            timestamp: Date.now()
          };
          return await new Promise((resolve) => {
            typeof chrome < "u" && chrome.storage ? chrome.storage.local.set({ [LOCATION_STORAGE_KEY]: cacheObject }, resolve) : resolve();
          }), cacheObject;
        }
      }
    } catch (error) {
      console.error("Location Util: Critical Error", error);
    }
    return null;
  }
  __name(getUserLocation, "getUserLocation");
  async function probeServerForLocation(placeId, serverId) {
    try {
      let res = await callRobloxApi({
        subdomain: "gamejoin",
        endpoint: "/v1/join-game-instance",
        method: "POST",
        body: {
          placeId: parseInt(placeId, 10),
          gameId: serverId,
          gameJoinAttemptId: crypto.randomUUID()
        }
      });
      if (!res.ok) return null;
      let info = await res.json();
      if (info.joinScript && info.joinScript.SessionId)
        try {
          let sessionIdStr = info.joinScript.SessionId;
          if (sessionIdStr.startsWith("http")) return null;
          let sessionId = JSON.parse(sessionIdStr);
          if (sessionId.Latitude && sessionId.Longitude)
            return {
              userLat: sessionId.Latitude,
              userLon: sessionId.Longitude
            };
        } catch {
        }
    } catch {
    }
    return null;
  }
  __name(probeServerForLocation, "probeServerForLocation");
  async function updateUserLocationIfChanged(freshCoords) {
    if (!hasUpdatedLocation && !(!freshCoords || typeof freshCoords.userLat != "number")) {
      hasUpdatedLocation = !0;
      try {
        let geoNames = await resolveGeoNames(freshCoords.userLat, freshCoords.userLon), cacheObject = { ...freshCoords, ...geoNames, timestamp: Date.now() };
        typeof chrome < "u" && chrome.storage && await chrome.storage.local.set({ [LOCATION_STORAGE_KEY]: cacheObject });
      } catch (e) {
        console.error("Location Util: Error in update", e);
      }
    }
  }
  __name(updateUserLocationIfChanged, "updateUserLocationIfChanged");

  // src/content/core/api.js
  var activeRequests = /* @__PURE__ */ new Map(), OAUTH_STORAGE_KEY = "rovalra_oauth_verification", CAPTURED_APIS_KEY = "rovalra_captured_apis", seenRequests = /* @__PURE__ */ new Map();
  document.addEventListener("rovalra-traffic-capture", (e) => {
    let { url, method, body } = e.detail;
    try {
      let urlObj = new URL(url), hostname = urlObj.hostname, pathname = urlObj.pathname + urlObj.search, subdomain = "apis", isRovalraApi = !1;
      if (hostname.endsWith(".roblox.com"))
        subdomain = hostname.replace(".roblox.com", "");
      else if (hostname.includes("rovalra.com"))
        isRovalraApi = !0, subdomain = "apis";
      else
        return;
      captureApiCall({
        subdomain,
        endpoint: pathname,
        method,
        isRovalraApi,
        body
      });
    } catch {
    }
  });
  function captureApiCall(options) {
    try {
      let { subdomain = "apis", endpoint, method = "GET", isRovalraApi = !1, body = null } = options;
      if (!endpoint) return;
      let [baseEndpoint] = endpoint.split("?"), category = isRovalraApi ? "rovalra.com" : subdomain || "apis", methodUpper = method.toUpperCase(), key = `${category}|${baseEndpoint}|${methodUpper}`, hasParams = endpoint.includes("?");
      if (seenRequests.has(key) && (seenRequests.get(key) || !hasParams))
        return;
      seenRequests.set(key, hasParams || seenRequests.get(key) || !1), chrome.storage.local.get([CAPTURED_APIS_KEY, "EnableRobloxApiDocs"], (result) => {
        if (!result.EnableRobloxApiDocs) return;
        let data = result[CAPTURED_APIS_KEY] || {}, changed = !1;
        if (data[category] || (data[category] = {}, changed = !0), data[category][baseEndpoint] || (data[category][baseEndpoint] = {}, changed = !0), !data[category][baseEndpoint][methodUpper])
          data[category][baseEndpoint][methodUpper] = {
            exampleBody: body,
            exampleEndpoint: endpoint
          }, changed = !0;
        else {
          let currentDetails = data[category][baseEndpoint][methodUpper];
          hasParams && (!currentDetails.exampleEndpoint || !currentDetails.exampleEndpoint.includes("?")) && (currentDetails.exampleEndpoint = endpoint, changed = !0), body && !currentDetails.exampleBody && (currentDetails.exampleBody = body, changed = !0);
        }
        changed && chrome.storage.local.set({ [CAPTURED_APIS_KEY]: data });
      });
    } catch {
    }
  }
  __name(captureApiCall, "captureApiCall");
  function getRequestKey({ endpoint, subdomain = "apis", method = "GET", isRovalraApi = !1, body = null, fullUrl = null }) {
    let bodyStr = body && typeof body == "object" ? JSON.stringify(body) : body || "";
    return `${fullUrl || `${isRovalraApi}|${subdomain}|${endpoint}`}|${method.toUpperCase()}|${bodyStr}`;
  }
  __name(getRequestKey, "getRequestKey");
  function checkSimulatedDowntime() {
    return new Promise((resolve) => {
      if (typeof chrome > "u" || !chrome.storage || !chrome.storage.local) {
        resolve(!1);
        return;
      }
      chrome.storage.local.get(["simulateRoValraServerErrors"], (result) => {
        resolve(!!result.simulateRoValraServerErrors);
      });
    });
  }
  __name(checkSimulatedDowntime, "checkSimulatedDowntime");
  function checkSimulatedLatency() {
    return new Promise((resolve) => {
      if (typeof chrome > "u" || !chrome.storage || !chrome.storage.local) {
        resolve(!1);
        return;
      }
      chrome.storage.local.get(["simulateRoValraServerLatency"], (result) => {
        resolve(!!result.simulateRoValraServerLatency);
      });
    });
  }
  __name(checkSimulatedLatency, "checkSimulatedLatency");
  async function callRobloxApi(options) {
    captureApiCall(options);
    let requestKey = getRequestKey(options), shouldCache = !options.noCache && options.subdomain !== "gamejoin";
    if (shouldCache && activeRequests.has(requestKey)) {
      let clonedResponse2 = (await activeRequests.get(requestKey)).clone();
      return options.subdomain === "games" && options.endpoint.includes("/servers/") && options.isRovalraApi, clonedResponse2;
    }
    let requestPromise = (async () => {
      let {
        endpoint,
        subdomain = "apis",
        method = "GET",
        isRovalraApi = !1,
        headers = {},
        body = null,
        fullUrl: customFullUrl,
        skipAutoAuth = !1
      } = options;
      if (isRovalraApi) {
        if (endpoint && endpoint.includes("/v1/auth") && !skipAutoAuth) {
          let token = await getValidAccessToken();
          if (token)
            headers.Authorization = `Bearer ${token}`;
          else
            return new Response(JSON.stringify({ status: "error", message: "Unauthorized" }), { status: 401, headers: { "Content-Type": "application/json" } });
        }
        if (await checkSimulatedDowntime())
          return console.warn(`RoValra API: [SIMULATION] 500 Error for ${endpoint}`), new Response(JSON.stringify({
            errors: [{ code: 500, message: "Simulated Internal Server Error" }]
          }), { status: 500, statusText: "Internal Server Error", headers: { "Content-Type": "application/json" } });
        await checkSimulatedLatency() && (console.warn(`RoValra API: [SIMULATION] Adding 5s latency for ${endpoint}`), await new Promise((resolve) => setTimeout(resolve, 5e3)));
      }
      let baseUrl = isRovalraApi ? subdomain === "www" ? "https://www.rovalra.com" : `https://${subdomain}.rovalra.com` : `https://${subdomain}.roblox.com`, fullUrl = customFullUrl || `${baseUrl}${endpoint}`;
      fullUrl.includes("?") ? fullUrl += "&_RoValraRequest=" : fullUrl += "?_RoValraRequest=";
      let isMutatingMethod = ["POST", "PATCH", "DELETE"].includes(method.toUpperCase()), credentials = options.credentials ?? (isRovalraApi ? "omit" : "include"), fetchOptions = {
        method,
        headers: {
          Accept: "application/json",
          ...headers
        },
        credentials
      };
      if (body && (body instanceof FormData ? (fetchOptions.body = body, fetchOptions.headers["Content-Type"] && delete fetchOptions.headers["Content-Type"]) : (fetchOptions.headers["Content-Type"] = "application/json", fetchOptions.body = typeof body == "string" ? body : JSON.stringify(body))), isRovalraApi) {
        let lastResponse, authRetried = !1;
        for (let attempt = 0; attempt < 4; attempt++) {
          try {
            lastResponse = await fetch(fullUrl, fetchOptions);
            let newAccessToken = lastResponse.headers.get("X-New-Access-Token");
            if (newAccessToken)
              try {
                let authedUserId = await getAuthenticatedUserId();
                if (authedUserId) {
                  let allVerifications = (await chrome.storage.local.get(OAUTH_STORAGE_KEY))[OAUTH_STORAGE_KEY] || {}, storedVerification = allVerifications[authedUserId];
                  if (storedVerification) {
                    console.log("RoValra API: New token received from header. Updating storage."), storedVerification.accessToken = newAccessToken, storedVerification.timestamp = Date.now();
                    try {
                      let data = await lastResponse.clone().json();
                      data && data.expires_at && (storedVerification.expiresAt = data.expires_at * 1e3);
                    } catch {
                    }
                    allVerifications[authedUserId] = storedVerification, await chrome.storage.local.set({ [OAUTH_STORAGE_KEY]: allVerifications });
                  }
                }
              } catch (e) {
                console.error("RoValra API: Failed to update new access token.", e);
              }
            if (lastResponse.status === 401 && endpoint && endpoint.includes("/v1/auth") && !skipAutoAuth && !authRetried) {
              console.log("RoValra API: 401 Unauthorized, attempting token refresh..."), authRetried = !0;
              let newToken = await getValidAccessToken(!0);
              if (newToken) {
                fetchOptions.headers.Authorization = `Bearer ${newToken}`;
                continue;
              }
            }
            if (lastResponse.ok)
              return lastResponse;
            if (endpoint && endpoint.includes("/v1/auth")) break;
          } catch (error) {
            if (attempt === 3 || endpoint && endpoint.includes("/v1/auth"))
              throw console.error(`RoValra API: Request to ${fullUrl} failed${attempt === 3 ? " after multiple retries" : ""}.`, error), error;
          }
          attempt < 3 && await new Promise((res) => setTimeout(res, 1e3));
        }
        return lastResponse.ok || console.error(`RoValra API: Request to ${fullUrl} failed with status ${lastResponse.status} after multiple retries.`), lastResponse;
      }
      if (isMutatingMethod) {
        let csrfToken = await getCsrfToken();
        csrfToken && (fetchOptions.headers["X-CSRF-TOKEN"] = csrfToken);
      }
      let response = await fetch(fullUrl, fetchOptions);
      if (response.status === 403 && isMutatingMethod) {
        let newCsrfToken = response.headers.get("x-csrf-token");
        newCsrfToken && (typeof getCsrfToken.setToken == "function" && getCsrfToken.setToken(newCsrfToken), fetchOptions.headers["X-CSRF-TOKEN"] = newCsrfToken, response = await fetch(fullUrl, fetchOptions));
      }
      return response.ok || console.error(`RoValra API: Request to ${fullUrl} failed with status ${response.status}.`), response;
    })();
    shouldCache && (activeRequests.set(requestKey, requestPromise), requestPromise.finally(() => activeRequests.delete(requestKey)));
    let originalResponse = await requestPromise, clonedResponse = originalResponse.clone();
    if (options.subdomain === "gamejoin" && originalResponse.ok && originalResponse.clone().json().then((data) => {
      if (data?.joinScript?.SessionId)
        try {
          if (typeof data.joinScript.SessionId == "string" && data.joinScript.SessionId.startsWith("{")) {
            let sessionId = JSON.parse(data.joinScript.SessionId);
            typeof sessionId.Latitude == "number" && typeof sessionId.Longitude == "number" && updateUserLocationIfChanged({
              userLat: sessionId.Latitude,
              userLon: sessionId.Longitude
            });
          }
        } catch {
        }
      if (data.status === 5) {
        let serverId = null;
        try {
          let bodyData = options.body && typeof options.body == "string" ? JSON.parse(options.body) : options.body;
          bodyData && bodyData.gameId && (serverId = bodyData.gameId);
        } catch {
        }
        serverId && document.dispatchEvent(new CustomEvent("rovalra-server-inactive", {
          detail: { serverId }
        }));
      }
    }).catch(() => {
    }), options.subdomain === "games" && options.endpoint.includes("/servers/") && !options.isRovalraApi)
      try {
        let monitorClone = clonedResponse.clone(), fullUrl = `https://${options.subdomain || "games"}.roblox.com${options.endpoint}`;
        monitorClone.json().then((data) => {
          document.dispatchEvent(new CustomEvent("rovalra-game-servers-response", {
            detail: { url: fullUrl, data }
          }));
        }).catch(() => {
        });
      } catch (e) {
        console.warn("RoValra API: Monitor hook failed", e);
      }
    return clonedResponse;
  }
  __name(callRobloxApi, "callRobloxApi");
  async function callRobloxApiJson(options) {
    let response = await callRobloxApi(options);
    if (!response.ok) {
      let errorBody = await response.json().catch(() => ({ message: "Could not parse error response" })), error = new Error(`API request failed with status ${response.status}`);
      throw error.response = errorBody, error;
    }
    return await response.json();
  }
  __name(callRobloxApiJson, "callRobloxApiJson");

  // src/content/core/regions.js
  var API_ENDPOINT_DATACENTERS_LIST = "/v1/datacenters/list", STORAGE_KEY_DATACENTERS = "rovalraDatacenters", STORAGE_KEY_REGIONS = "cachedRegions", STORAGE_KEY_CONTINENTS = "cachedRegionContinents", cachedRegionData = null, REGIONS = {}, stateMap = {
    Alabama: "AL",
    Alaska: "AK",
    Arizona: "AZ",
    Arkansas: "AR",
    California: "CA",
    Colorado: "CO",
    Connecticut: "CT",
    Delaware: "DE",
    Florida: "FL",
    Georgia: "GA",
    Hawaii: "HI",
    Idaho: "ID",
    Illinois: "IL",
    Indiana: "IN",
    Iowa: "IA",
    Kansas: "KS",
    Kentucky: "KY",
    Louisiana: "LA",
    Maine: "ME",
    Maryland: "MD",
    Massachusetts: "MA",
    Michigan: "MI",
    Minnesota: "MN",
    Mississippi: "MS",
    Missouri: "MO",
    Montana: "MT",
    Nebraska: "NE",
    Nevada: "NV",
    "New Hampshire": "NH",
    "New Jersey": "NJ",
    "New Mexico": "NM",
    "New York": "NY",
    "North Carolina": "NC",
    "North Dakota": "ND",
    Ohio: "OH",
    Oklahoma: "OK",
    Oregon: "OR",
    Pennsylvania: "PA",
    "Rhode Island": "RI",
    "South Carolina": "SC",
    "South Dakota": "SD",
    Tennessee: "TN",
    Texas: "TX",
    Utah: "UT",
    Vermont: "VT",
    Virginia: "VA",
    Washington: "WA",
    "West Virginia": "WV",
    Wisconsin: "WI",
    Wyoming: "WY",
    Hesse: "HE"
  };
  function getStateCodeFromRegion(regionName) {
    return regionName ? stateMap[regionName] || regionName.substring(0, 2).toUpperCase() : null;
  }
  __name(getStateCodeFromRegion, "getStateCodeFromRegion");
  function getContinent(countryCode) {
    return COUNTRY_CONTINENT_MAP[countryCode] || "Other";
  }
  __name(getContinent, "getContinent");
  async function loadDatacenterMap() {
    if (window.rovalraDatacenterState && window.rovalraDatacenterState !== "initial") return;
    window.rovalraDatacenterState = "loading";
    let currentData = null, processDataIntoMap = /* @__PURE__ */ __name((serverListData) => {
      let map = {};
      Array.isArray(serverListData) && serverListData.forEach((dc) => {
        dc.dataCenterIds && Array.isArray(dc.dataCenterIds) && dc.location && dc.dataCenterIds.forEach((id) => {
          map[id] = dc.location;
        });
      }), serverIpMap = map;
    }, "processDataIntoMap");
    try {
      let storageResult = await chrome.storage.local.get(STORAGE_KEY_DATACENTERS);
      storageResult[STORAGE_KEY_DATACENTERS] && (currentData = storageResult[STORAGE_KEY_DATACENTERS], processDataIntoMap(currentData));
    } catch (e) {
      console.error("RoValra: Error reading datacenter map from storage.", e);
    }
    if (!currentData)
      try {
        let fallbackUrl = getAssets().serverListJson, response = await fetch(fallbackUrl);
        if (!response.ok) throw new Error(`Status: ${response.status}`);
        let localData = await response.json();
        currentData = localData, await chrome.storage.local.set({ [STORAGE_KEY_DATACENTERS]: localData }), processDataIntoMap(localData);
      } catch (e) {
        console.error("RoValra: Could not load local fallback JSON.", e), serverIpMap = {};
      }
    try {
      let controller = new AbortController(), timeoutId = setTimeout(() => controller.abort(), 8e3), apiResponse = await callRobloxApi({
        isRovalraApi: !0,
        endpoint: API_ENDPOINT_DATACENTERS_LIST,
        signal: controller.signal
      });
      if (clearTimeout(timeoutId), !apiResponse.ok) throw new Error(`API Status: ${apiResponse.status}`);
      let apiData = await apiResponse.json();
      JSON.stringify(apiData) !== JSON.stringify(currentData) && (await chrome.storage.local.set({ [STORAGE_KEY_DATACENTERS]: apiData }), processDataIntoMap(apiData));
    } catch (e) {
      let msg = e.name === "AbortError" ? "Timeout" : e.message;
    } finally {
      window.rovalraDatacenterState = "complete";
    }
  }
  __name(loadDatacenterMap, "loadDatacenterMap");
  async function fetchAndProcessRegions() {
    let newRegions = { AUTO: { city: "Automatic", state: null, country: null, latitude: null, longitude: null } }, newContinents = {}, data;
    try {
      let response = await callRobloxApi({
        isRovalraApi: !0,
        endpoint: API_ENDPOINT_DATACENTERS_LIST
      });
      if (!response.ok) throw new Error(`Status ${response.status}`);
      data = await response.json();
    } catch (error) {
      console.warn("RoValra: API failed, using fallback.", error.message);
      try {
        let fallbackUrl = getAssets().serverListJson, response = await fetch(fallbackUrl);
        if (!response.ok) throw new Error(`Status ${response.status}`);
        data = await response.json();
      } catch (fallbackError) {
        return console.error("RoValra Critical: Could not load region data.", fallbackError), { regions: newRegions, continents: newContinents };
      }
    }
    if (data && Array.isArray(data))
      for (let item of data) {
        let loc = item.location;
        if (!loc || !loc.country || !loc.latLong || loc.latLong.length !== 2) continue;
        let countryCode = loc.country, state3 = loc.region, city = loc.city, regionCode = countryCode;
        if (countryCode === "US" && state3 && city) {
          let stateCode = getStateCodeFromRegion(state3), cityCode = city.replace(/\s+/g, "").toUpperCase();
          regionCode = `US-${stateCode}-${cityCode}`;
        } else countryCode === "US" && state3 ? regionCode = `US-${getStateCodeFromRegion(state3)}` : city && (regionCode = `${countryCode}-${city.replace(/\s+/g, "").toUpperCase()}`);
        newRegions[regionCode] || (newRegions[regionCode] = {
          latitude: parseFloat(loc.latLong[0]),
          longitude: parseFloat(loc.latLong[1]),
          city: loc.city,
          state: state3,
          country: countryCode,
          countryName: loc.countryName
        });
      }
    return await chrome.storage.local.set({
      [STORAGE_KEY_REGIONS]: newRegions,
      [STORAGE_KEY_CONTINENTS]: newContinents
    }), REGIONS = newRegions, cachedRegionData = { regions: newRegions, continents: newContinents }, cachedRegionData;
  }
  __name(fetchAndProcessRegions, "fetchAndProcessRegions");
  async function getRegionData() {
    return cachedRegionData || new Promise((resolve, reject) => {
      chrome.storage.local.get([STORAGE_KEY_REGIONS, STORAGE_KEY_CONTINENTS], async (result) => {
        if (result[STORAGE_KEY_REGIONS] && result[STORAGE_KEY_REGIONS].AUTO && result[STORAGE_KEY_REGIONS].AUTO.city === "Automatic")
          REGIONS = result[STORAGE_KEY_REGIONS], cachedRegionData = {
            regions: result[STORAGE_KEY_REGIONS],
            continents: result[STORAGE_KEY_CONTINENTS] || {}
          }, resolve(cachedRegionData);
        else
          try {
            let data = await fetchAndProcessRegions();
            resolve(data);
          } catch (error) {
            reject(error);
          }
      });
    });
  }
  __name(getRegionData, "getRegionData");
  function getFullRegionName(regionCode) {
    let regionData = REGIONS[regionCode];
    if (!regionData) {
      if (regionCode === "AUTO") return "Automatic";
      let parts2 = regionCode.split("-");
      if (parts2.length >= 2) {
        let countryCode = parts2[0];
        return `${parts2[parts2.length - 1].replace(/([A-Z]+)([A-Z][a-z])/g, "$1 $2").replace(/([a-z])([A-Z])/g, "$1 $2").trim()}, ${countryCode}`;
      }
      return regionCode;
    }
    if (regionCode === "AUTO") return regionData.city;
    let parts = [];
    return regionData.city && regionData.city !== regionData.country && parts.push(regionData.city), regionData.state && regionData.country === "United States" && parts.push(regionData.state), regionData.country && parts.push(regionData.country), parts = [...new Set(parts.filter((p) => p))], parts.length > 1 && parts[parts.length - 1] === "United States" && (parts[parts.length - 1] = "USA"), parts.join(", ") || regionCode;
  }
  __name(getFullRegionName, "getFullRegionName");
  var COUNTRY_CONTINENT_MAP = {
    AF: "Asia",
    AX: "Europe",
    AL: "Europe",
    DZ: "Africa",
    AS: "Oceania",
    AD: "Europe",
    AO: "Africa",
    AI: "North America",
    AQ: "Antarctica",
    AG: "North America",
    AR: "South America",
    AM: "Asia",
    AW: "North America",
    AU: "Oceania",
    AT: "Europe",
    AZ: "Asia",
    BS: "North America",
    BH: "Asia",
    BD: "Asia",
    BB: "North America",
    BY: "Europe",
    BE: "Europe",
    BZ: "North America",
    BJ: "Africa",
    BM: "North America",
    BT: "Asia",
    BO: "South America",
    BQ: "North America",
    BA: "Europe",
    BW: "Africa",
    BV: "Antarctica",
    BR: "South America",
    IO: "Asia",
    BN: "Asia",
    BG: "Europe",
    BF: "Africa",
    BI: "Africa",
    CV: "Africa",
    KH: "Asia",
    CM: "Africa",
    CA: "North America",
    KY: "North America",
    CF: "Africa",
    TD: "Africa",
    CL: "South America",
    CN: "Asia",
    CX: "Asia",
    CC: "Asia",
    CO: "South America",
    KM: "Africa",
    CG: "Africa",
    CD: "Africa",
    CK: "Oceania",
    CR: "North America",
    CI: "Africa",
    HR: "Europe",
    CU: "North America",
    CW: "North America",
    CY: "Asia",
    CZ: "Europe",
    DK: "Europe",
    DJ: "Africa",
    DM: "North America",
    DO: "North America",
    EC: "South America",
    EG: "Africa",
    SV: "North America",
    GQ: "Africa",
    ER: "Africa",
    EE: "Europe",
    SZ: "Africa",
    ET: "Africa",
    FK: "South America",
    FO: "Europe",
    FJ: "Oceania",
    FI: "Europe",
    FR: "Europe",
    GF: "South America",
    PF: "Oceania",
    TF: "Antarctica",
    GA: "Africa",
    GM: "Africa",
    GE: "Asia",
    DE: "Europe",
    GH: "Africa",
    GI: "Europe",
    GR: "Europe",
    GL: "North America",
    GD: "North America",
    GP: "North America",
    GU: "Oceania",
    GT: "North America",
    GG: "Europe",
    GN: "Africa",
    GW: "Africa",
    GY: "South America",
    HT: "North America",
    HM: "Antarctica",
    VA: "Europe",
    HN: "North America",
    HK: "Asia",
    HU: "Europe",
    IS: "Europe",
    IN: "Asia",
    ID: "Asia",
    IR: "Asia",
    IQ: "Asia",
    IE: "Europe",
    IM: "Europe",
    IL: "Asia",
    IT: "Europe",
    JM: "North America",
    JP: "Asia",
    JE: "Europe",
    JO: "Asia",
    KZ: "Asia",
    KE: "Africa",
    KI: "Oceania",
    KP: "Asia",
    KR: "Asia",
    KW: "Asia",
    KG: "Asia",
    LA: "Asia",
    LV: "Europe",
    LB: "Asia",
    LS: "Africa",
    LR: "Africa",
    LY: "Africa",
    LI: "Europe",
    LT: "Europe",
    LU: "Europe",
    MO: "Asia",
    MG: "Africa",
    MW: "Africa",
    MY: "Asia",
    MV: "Asia",
    ML: "Africa",
    MT: "Europe",
    MH: "Oceania",
    MQ: "North America",
    MR: "Africa",
    MU: "Africa",
    YT: "Africa",
    MX: "North America",
    FM: "Oceania",
    MD: "Europe",
    MC: "Europe",
    MN: "Asia",
    ME: "Europe",
    MS: "North America",
    MA: "Africa",
    MZ: "Africa",
    MM: "Asia",
    NA: "Africa",
    NR: "Oceania",
    NP: "Asia",
    NL: "Europe",
    NC: "Oceania",
    NZ: "Oceania",
    NI: "North America",
    NE: "Africa",
    NG: "Africa",
    NU: "Oceania",
    NF: "Oceania",
    MK: "Europe",
    MP: "Oceania",
    NO: "Europe",
    OM: "Asia",
    PK: "Asia",
    PW: "Oceania",
    PS: "Asia",
    PA: "North America",
    PG: "Oceania",
    PY: "South America",
    PE: "South America",
    PH: "Asia",
    PN: "Oceania",
    PL: "Europe",
    PT: "Europe",
    PR: "North America",
    QA: "Asia",
    RE: "Africa",
    RO: "Europe",
    RU: "Europe",
    RW: "Africa",
    BL: "North America",
    SH: "Africa",
    KN: "North America",
    LC: "North America",
    MF: "North America",
    PM: "North America",
    VC: "North America",
    WS: "Oceania",
    SM: "Europe",
    ST: "Africa",
    SA: "Asia",
    SN: "Africa",
    RS: "Europe",
    SC: "Africa",
    SL: "Africa",
    SG: "Asia",
    SX: "North America",
    SK: "Europe",
    SI: "Europe",
    SB: "Oceania",
    SO: "Africa",
    ZA: "Africa",
    GS: "Antarctica",
    SS: "Africa",
    ES: "Europe",
    LK: "Asia",
    SD: "Africa",
    SR: "South America",
    SJ: "Europe",
    SE: "Europe",
    CH: "Europe",
    SY: "Asia",
    TW: "Asia",
    TJ: "Asia",
    TZ: "Africa",
    TH: "Asia",
    TL: "Asia",
    TG: "Africa",
    TK: "Oceania",
    TO: "Oceania",
    TT: "North America",
    TN: "Africa",
    TR: "Asia",
    TM: "Asia",
    TC: "North America",
    TV: "Oceania",
    UG: "Africa",
    UA: "Europe",
    AE: "Asia",
    GB: "Europe",
    US: "North America",
    UM: "Oceania",
    UY: "South America",
    UZ: "Asia",
    VU: "Oceania",
    VE: "South America",
    VN: "Asia",
    VG: "North America",
    VI: "North America",
    WF: "Oceania",
    EH: "Africa",
    YE: "Asia",
    ZM: "Africa",
    ZW: "Africa"
  };

  // src/content/core/thumbnail/thumbnails.js
  var BATCH_SIZE = 50, MAX_RETRIES = 5, RETRY_DELAY_MS = 1500, sleep = /* @__PURE__ */ __name((ms) => new Promise((resolve) => setTimeout(resolve, ms)), "sleep");
  async function fetchBatchData(batch, type, size, isCircular, signal, noCache = !1) {
    let results = [];
    if (type === "PlayerToken") {
      let requestBody = batch.map((item) => ({
        token: item.id,
        type: "AvatarHeadshot",
        size,
        isCircular,
        requestId: `0:${item.id}:AvatarHeadshot:${size}:png:regular`
      }));
      try {
        let response = await callRobloxApi({
          subdomain: "thumbnails",
          endpoint: "/v1/batch",
          method: "POST",
          body: requestBody,
          signal,
          noCache
        });
        if (response.ok) {
          let data = await response.json();
          if (data && data.data) return data.data;
        }
      } catch (error) {
        console.error('RoValra Thumbnails: Failed to fetch batch for "PlayerToken".', error);
      }
      return results;
    }
    let mapping = {
      AvatarHeadshot: { path: "/v1/users/avatar-headshot", idParam: "userIds" },
      GameIcon: { path: "/v1/games/icons", idParam: "universeIds" },
      Asset: { path: "/v1/assets", idParam: "assetIds" },
      BundleThumbnail: { path: "/v1/bundles/thumbnails", idParam: "bundleIds" },
      PlaceIcon: { path: "/v1/places/gameicons", idParam: "placeIds" },
      UserOutfit: { path: "/v1/users/outfits", idParam: "userOutfitIds" },
      Outfit: { path: "/v1/users/outfits", idParam: "userOutfitIds" },
      GamePass: { path: "/v1/game-passes", idParam: "gamePassIds" }
    }[type];
    if (!mapping) return results;
    let ids = batch.map((item) => item.id).join(",");
    try {
      let endpointUrl = `${mapping.path}?${mapping.idParam}=${ids}&size=${size}&format=Png&returnPolicy=PlaceHolder`;
      isCircular && (endpointUrl += "&isCircular=true");
      let response = await callRobloxApi({
        subdomain: "thumbnails",
        endpoint: endpointUrl,
        signal,
        noCache
      });
      if (response.ok) {
        let data = await response.json();
        if (data && data.data) return data.data;
      }
    } catch (error) {
      console.error(`RoValra Thumbnails: Failed to fetch batch for "${type}".`, error);
    }
    return results;
  }
  __name(fetchBatchData, "fetchBatchData");
  async function fetchThumbnails(items, type, size = "150x150", isCircular = !1, signal) {
    let thumbnailMap = /* @__PURE__ */ new Map();
    if (!items || items.length === 0) return thumbnailMap;
    let processResults = /* @__PURE__ */ __name((resultsArray) => {
      resultsArray.flat().forEach((thumb) => {
        if (type === "PlayerToken") {
          let token = thumb.requestId.split(":")[1];
          thumbnailMap.set(token, thumb);
        } else
          thumbnailMap.set(thumb.targetId, thumb);
      });
    }, "processResults"), initialPromises = [];
    for (let i = 0; i < items.length; i += BATCH_SIZE) {
      let batch = items.slice(i, i + BATCH_SIZE);
      initialPromises.push(fetchBatchData(batch, type, size, isCircular, signal, !1));
    }
    let initialResults = await Promise.all(initialPromises);
    processResults(initialResults);
    let pendingItems2 = [], pendingResolvers = /* @__PURE__ */ new Map();
    for (let [id, data] of thumbnailMap.entries())
      if (data.state === "Pending" || data.state === "InReview") {
        let resolver, updatePromise = new Promise((resolve) => {
          resolver = resolve;
        });
        data.finalUpdate = updatePromise, pendingItems2.push({ id }), pendingResolvers.set(String(id), resolver);
      }
    return pendingItems2.length > 0 && (async () => {
      let currentPending = [...pendingItems2];
      for (let attempt = 1; attempt <= MAX_RETRIES && !(currentPending.length === 0 || signal?.aborted || (await sleep(RETRY_DELAY_MS), signal?.aborted)); attempt++) {
        let retryPromises = [];
        for (let i = 0; i < currentPending.length; i += BATCH_SIZE) {
          let batch = currentPending.slice(i, i + BATCH_SIZE);
          retryPromises.push(fetchBatchData(batch, type, size, isCircular, signal, !0));
        }
        let flatResults = (await Promise.all(retryPromises)).flat(), nextPending = [];
        flatResults.forEach((thumb) => {
          let id;
          if (type === "PlayerToken" ? id = thumb.requestId.split(":")[1] : id = String(thumb.targetId), thumb.state === "Completed") {
            let resolve = pendingResolvers.get(id);
            resolve && (resolve(thumb), pendingResolvers.delete(id));
          } else if (thumb.state === "Pending" || thumb.state === "InReview")
            nextPending.push({ id });
          else {
            let resolve = pendingResolvers.get(id);
            resolve && (resolve(thumb), pendingResolvers.delete(id));
          }
        }), currentPending = nextPending;
      }
      currentPending.forEach((item) => {
        let resolve = pendingResolvers.get(String(item.id));
        resolve && resolve(null);
      });
    })(), thumbnailMap;
  }
  __name(fetchThumbnails, "fetchThumbnails");
  function createThumbnailElement(thumbnailData, altText, baseClass = "game-card-thumb", style = { width: "100%", height: "100%" }) {
    let thumbnailElement, state3 = thumbnailData ? thumbnailData.state : "Error", applyStyles = /* @__PURE__ */ __name((el2) => (el2.alt = altText, Object.assign(el2.style, style), el2), "applyStyles");
    if (state3 === "Completed")
      return thumbnailElement = document.createElement("img"), thumbnailElement.className = baseClass, thumbnailElement.src = thumbnailData.imageUrl, applyStyles(thumbnailElement);
    if (state3 === "Blocked")
      return thumbnailElement = document.createElement("div"), thumbnailElement.className = "thumbnail-2d-container icon-blocked", applyStyles(thumbnailElement);
    if (state3 === "Pending" || state3 === "InReview") {
      let container = document.createElement("div");
      return container.className = "thumbnail-2d-container shimmer", container.style.borderRadius = "8px", applyStyles(container), thumbnailData && thumbnailData.finalUpdate && thumbnailData.finalUpdate.then((updatedData) => {
        if (!updatedData) {
          container.className = "thumbnail-2d-container icon-blocked", container.style.borderRadius = "8px", container.classList.remove("shimmer");
          return;
        }
        if (updatedData.state === "Completed") {
          let img = document.createElement("img");
          img.className = baseClass, img.src = updatedData.imageUrl, img.alt = altText, Object.assign(img.style, style), container.parentNode && container.parentNode.replaceChild(img, container);
        } else updatedData.state === "Blocked" ? (container.className = "thumbnail-2d-container icon-blocked", container.classList.remove("shimmer")) : (container.className = "thumbnail-2d-container icon-broken", container.style.borderRadius = "8px", container.classList.remove("shimmer"));
      }).catch(() => {
        container.className = "thumbnail-2d-container icon-broken", container.style.borderRadius = "8px", container.classList.remove("shimmer");
      }), container;
    }
    return thumbnailElement = document.createElement("div"), thumbnailElement.className = "thumbnail-2d-container icon-broken", thumbnailElement.style.borderRadius = "8px", applyStyles(thumbnailElement);
  }
  __name(createThumbnailElement, "createThumbnailElement");
  async function getBatchThumbnails(ids, type, size = "150x150") {
    let items = ids.map((id) => ({ id })), thumbnailMap = await fetchThumbnails(items, type, size);
    return Array.from(thumbnailMap.values());
  }
  __name(getBatchThumbnails, "getBatchThumbnails");

  // src/content/core/utils/launcher.js
  function executeLaunchScript(codeToInject) {
    typeof chrome < "u" && chrome.runtime ? chrome.runtime.sendMessage({ action: "injectScript", codeToInject }) : console.error("RoValra Launcher: Chrome runtime is not available to inject the script.");
  }
  __name(executeLaunchScript, "executeLaunchScript");
  function launchGame(placeId, jobId = null) {
    let codeToInject = `if (typeof Roblox?.GameLauncher?.joinGameInstance === 'function') { ${jobId ? `Roblox.GameLauncher.joinGameInstance(parseInt('${placeId}', 10), '${jobId}')` : `Roblox.GameLauncher.joinGameInstance(parseInt('${placeId}', 10))`}; }`;
    executeLaunchScript(codeToInject);
  }
  __name(launchGame, "launchGame");
  function launchPrivateGame(placeId, accessCode, linkCode) {
    let codeToInject = `if (typeof Roblox?.GameLauncher?.joinPrivateGame === 'function') { ${`Roblox.GameLauncher.joinPrivateGame(parseInt('${placeId}', 10), '${accessCode}', '${linkCode}')`}; }`;
    executeLaunchScript(codeToInject);
  }
  __name(launchPrivateGame, "launchPrivateGame");
  function launchMultiplayerGame(placeId, launchData = {}) {
    window.__rovalra_skipNextLaunch = !0;
    let codeToInject = `if (typeof Roblox.GameLauncher.joinMultiplayerGame === 'function') { Roblox.GameLauncher.joinMultiplayerGame(${placeId}, false, false, null, null, ${JSON.stringify({ launchData })}); }`;
    executeLaunchScript(codeToInject);
  }
  __name(launchMultiplayerGame, "launchMultiplayerGame");
  async function launchStudioForGame(placeId) {
    try {
      let gameDetails = await callRobloxApiJson({
        subdomain: "games",
        endpoint: `/v1/games/multiget-place-details?placeIds=${placeId}`
      });
      if (gameDetails && gameDetails.length > 0 && gameDetails[0].universeId) {
        let universeId = gameDetails[0].universeId, codeToInject = `if (typeof Roblox?.GameLauncher?.editGameInStudio === 'function') { ${`Roblox.GameLauncher.editGameInStudio(${placeId}, ${universeId})`}; }`;
        executeLaunchScript(codeToInject);
      } else
        throw new Error(`Could not retrieve universeId for placeId ${placeId}`);
    } catch (error) {
      console.error("RoValra Launcher: Failed to launch studio with universeId, falling back.", error);
      let codeToInject = `window.location.href = '${`roblox-studio:launchmode:edit+task:EditPlace+placeId:${placeId}`}';`;
      executeLaunchScript(codeToInject);
    }
  }
  __name(launchStudioForGame, "launchStudioForGame");

  // src/content/core/ui/spinner.js
  function createSpinner({ size = "24px", color = "currentColor", className = "" } = {}) {
    let svg2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg2.setAttribute("viewBox", "0 0 20 20"), svg2.setAttribute("fill", "none"), svg2.style.width = size, svg2.style.height = size, svg2.style.animation = "rovalra-spinner-rotation 1s linear infinite", className && (svg2.className = className);
    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    if (path.setAttribute("fill-rule", "evenodd"), path.setAttribute("clip-rule", "evenodd"), path.setAttribute("fill", color), path.setAttribute("d", "M10 2.75C8.56609 2.75 7.16438 3.1752 5.97212 3.97185C4.77986 4.76849 3.85061 5.90078 3.30188 7.22554C2.75314 8.55031 2.60957 10.008 2.88931 11.4144C3.16905 12.8208 3.85955 14.1126 4.87348 15.1265C5.88741 16.1405 7.17924 16.831 8.5856 17.1107C9.99196 17.3904 11.4497 17.2469 12.7745 16.6981C14.0992 16.1494 15.2315 15.2201 16.0282 14.0279C16.8248 12.8356 17.25 11.4339 17.25 10C17.25 9.58579 17.5858 9.25 18 9.25C18.4142 9.25 18.75 9.58579 18.75 10C18.75 11.7306 18.2368 13.4223 17.2754 14.8612C16.3139 16.3002 14.9473 17.4217 13.3485 18.0839C11.7496 18.7462 9.9903 18.9195 8.29296 18.5819C6.59563 18.2443 5.03653 17.4109 3.81282 16.1872C2.58911 14.9635 1.75575 13.4044 1.41813 11.707C1.08051 10.0097 1.25379 8.25037 1.91606 6.65152C2.57832 5.05267 3.69983 3.6861 5.13876 2.72464C6.57769 1.76318 8.26942 1.25 10 1.25C10.4142 1.25 10.75 1.58579 10.75 2C10.75 2.41421 10.4142 2.75 10 2.75Z"), svg2.appendChild(path), !document.getElementById("rovalra-spinner-keyframes")) {
      let style = document.createElement("style");
      style.id = "rovalra-spinner-keyframes", style.textContent = `
            @keyframes rovalra-spinner-rotation {
                from { transform: rotate(0deg); }
                to { transform: rotate(359deg); }
            }
        `, document.head.appendChild(style);
    }
    return svg2;
  }
  __name(createSpinner, "createSpinner");

  // src/content/core/ui/startModal/gamelaunchmodal.js
  var activeInstance = null, keepOverlayOpen = !1;
  function showLoadingOverlay(onCancel, customLogo = null, closeOnBackgroundClick = !1) {
    keepOverlayOpen = !1, activeInstance && (activeInstance.close(), activeInstance = null);
    let bodyWrapper = document.createElement("div");
    bodyWrapper.className = "rovalra-modal-content rovalra-gamelaunch-modal-body";
    let logoImg = document.createElement("img");
    if (customLogo)
      logoImg.src = customLogo;
    else
      try {
        logoImg.src = getAssets().rovalraIcon;
      } catch {
      }
    logoImg.className = "rovalra-gamelaunch-logo", bodyWrapper.appendChild(logoImg);
    let textElement = document.createElement("h2");
    textElement.className = "text-heading-medium rovalra-gamelaunch-text", textElement.innerHTML = "Searching For Servers...", bodyWrapper.appendChild(textElement);
    let infoContainer = document.createElement("div");
    infoContainer.className = "rovalra-gamelaunch-info-container", bodyWrapper.appendChild(infoContainer);
    let actionContainer = document.createElement("div");
    actionContainer.className = "rovalra-gamelaunch-action-container";
    let spinner = createSpinner({ size: "24px", color: "#FFFFFF" });
    actionContainer.appendChild(spinner), bodyWrapper.appendChild(actionContainer);
    let { overlay, close } = createOverlay({
      title: "",
      bodyContent: bodyWrapper,
      showLogo: !1,
      maxWidth: "350px",
      preventBackdropClose: !closeOnBackgroundClick,
      onClose: /* @__PURE__ */ __name(() => {
        activeInstance && (activeInstance = null, typeof onCancel == "function" && onCancel());
      }, "onClose")
    }), titleEl = overlay.querySelector(
      ".group-description-dialog-body-header"
    );
    titleEl && titleEl.remove();
    let closeBtn = overlay.querySelector(
      ".foundation-web-dialog-close-container button"
    );
    if (closeBtn) {
      let newCloseBtn = closeBtn.cloneNode(!0);
      closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn), newCloseBtn.onclick = () => {
        typeof onCancel == "function" && onCancel(), hideLoadingOverlay(!0);
      };
    }
    activeInstance = {
      overlay,
      close,
      textElement,
      actionContainer,
      infoContainer
    };
  }
  __name(showLoadingOverlay, "showLoadingOverlay");
  function hideLoadingOverlay(force = !1) {
    if (!(keepOverlayOpen && !force) && activeInstance) {
      let instance = activeInstance;
      activeInstance = null, instance.close();
    }
  }
  __name(hideLoadingOverlay, "hideLoadingOverlay");
  function updateLoadingOverlayText(text2) {
    activeInstance?.textElement && (activeInstance.textElement.innerHTML = purify.sanitize(text2));
  }
  __name(updateLoadingOverlayText, "updateLoadingOverlayText");
  function updateServerInfo(gameName, iconUrl, detailsHtml) {
    if (!activeInstance?.infoContainer) return;
    let container = activeInstance.infoContainer;
    container.classList.remove("is-visible"), container.innerHTML = "";
    let headerDiv = document.createElement("div");
    headerDiv.className = "rovalra-game-header";
    let icon = document.createElement("img");
    icon.src = iconUrl || "", icon.className = "rovalra-gamelaunch-game-icon";
    let textDiv = document.createElement("div");
    textDiv.className = "rovalra-gamelaunch-text-container";
    let nameLabel = document.createElement("span");
    if (nameLabel.innerText = gameName || "Roblox Experience", nameLabel.className = "rovalra-gamelaunch-game-name", textDiv.appendChild(nameLabel), headerDiv.appendChild(icon), headerDiv.appendChild(textDiv), container.appendChild(headerDiv), detailsHtml) {
      let detailsList = document.createElement("ul");
      detailsList.className = "rovalra-details-list", detailsList.innerHTML = purify.sanitize(detailsHtml), container.appendChild(detailsList);
    }
    container.classList.add("is-visible"), requestAnimationFrame(() => {
      container.querySelectorAll(".rovalra-channel-wrapper").forEach((wrapper) => {
        let textElement = wrapper.querySelector(
          ".rovalra-channel-truncated"
        );
        textElement && (textElement.scrollWidth > textElement.clientWidth ? wrapper.classList.add("rovalra-has-overflow") : wrapper.classList.remove("rovalra-has-overflow"));
      });
    });
  }
  __name(updateServerInfo, "updateServerInfo");
  function showLoadingOverlayResult(message, buttonOptions) {
    if (!activeInstance) return;
    keepOverlayOpen = !0, updateLoadingOverlayText(message);
    let container = activeInstance.actionContainer;
    if (container.innerHTML = "", buttonOptions) {
      let btn = document.createElement("button");
      btn.textContent = buttonOptions.text, btn.className = "rovalra-gamelaunch-action-button", container.appendChild(btn), container.onclick = (e) => {
        e.stopPropagation(), keepOverlayOpen = !1, buttonOptions.onClick();
      };
    }
  }
  __name(showLoadingOverlayResult, "showLoadingOverlayResult");

  // src/content/features/games/revertlogo.js
  var HIDE_ROBLOX_UI_CLASS = "rovalra-hide-roblox-dialogs", styles = `
    body.${HIDE_ROBLOX_UI_CLASS} .foundation-web-dialog-overlay,
    body.${HIDE_ROBLOX_UI_CLASS} .MuiModal-root,
    body.${HIDE_ROBLOX_UI_CLASS} .ReactModalPortal,
    body.${HIDE_ROBLOX_UI_CLASS} iframe#gamelaunch {
        display: none !important;
        visibility: hidden !important;
        pointer-events: none !important;
        opacity: 0 !important;
        z-index: -9999 !important;
    }

    .rovalra-info-icon {
        fill: rgb(32, 34, 39); 
    }
    .dark-theme .rovalra-info-icon {
        fill: rgb(247, 247, 248) !important;
    }
    .light-theme .rovalra-info-icon {
        fill: rgb(32, 34, 39) !important;
    }
`;
  try {
    let styleSheet = document.createElement("style");
    styleSheet.textContent = styles, (document.head || document.documentElement).appendChild(styleSheet);
  } catch {
  }
  function openInterface(onCancel, customLogo, closeOnBackgroundClick) {
    document.body.classList.add(HIDE_ROBLOX_UI_CLASS), showLoadingOverlay(() => {
      closeInterface(), onCancel && onCancel();
    }, customLogo, closeOnBackgroundClick);
  }
  __name(openInterface, "openInterface");
  function closeInterface(force = !1) {
    document.body.classList.remove(HIDE_ROBLOX_UI_CLASS), hideLoadingOverlay(force);
  }
  __name(closeInterface, "closeInterface");
  var serverIpMap2 = {}, REGIONS2 = {}, lastProcessedGameLaunchSrc = null, gameLaunchElementExists = !1, interceptedServerData = null, currentGameId = null, pollingInterval = null, clientStatusReceived = !1;
  function cleanupPolling() {
    pollingInterval && (clearInterval(pollingInterval), pollingInterval = null), document.removeEventListener("rovalra-game-launch-success", handleGameLaunchSuccess);
  }
  __name(cleanupPolling, "cleanupPolling");
  function triggerSuccess() {
    clientStatusReceived || (clientStatusReceived = !0, cleanupPolling(), showLoadingOverlayResult("Have Fun!", {
      text: "Close",
      onClick: /* @__PURE__ */ __name(() => {
        cleanupPolling(), closeInterface(!0);
      }, "onClick")
    }));
  }
  __name(triggerSuccess, "triggerSuccess");
  function handleGameLaunchSuccess() {
    triggerSuccess();
  }
  __name(handleGameLaunchSuccess, "handleGameLaunchSuccess");
  async function ensureDatacenterDataIsParsed() {
    try {
      if (Object.keys(serverIpMap2).length > 0) return;
      await loadDatacenterMap(), REGIONS2 = (await getRegionData()).regions;
      let serverListData = (await Promise.race([
        new Promise((resolve) => chrome.storage.local.get("rovalraDatacenters", resolve)),
        new Promise((_2, reject) => setTimeout(() => reject(new Error("Timeout")), 2e3))
      ])).rovalraDatacenters;
      serverListData && Array.isArray(serverListData) && serverListData.forEach((entry) => {
        !entry.location || !entry.dataCenterIds || entry.dataCenterIds.forEach((id) => {
          serverIpMap2[id] = entry.location;
        });
      });
    } catch (error) {
      console.warn("Rovalra: Failed to load datacenter map", error);
    }
  }
  __name(ensureDatacenterDataIsParsed, "ensureDatacenterDataIsParsed");
  async function fetchGameDetails(placeId) {
    if (!placeId) return { name: "Roblox Experience", iconUrl: null };
    try {
      let name = (await (await callRobloxApi({
        endpoint: `/v1/games/multiget-place-details?placeIds=${placeId}`,
        subdomain: "games"
      })).json())[0]?.name || "Unknown Experience", iconUrl = null;
      try {
        let thumbData = (await fetchThumbnails([{ id: parseInt(placeId, 10) }], "PlaceIcon", "150x150", !1)).get(parseInt(placeId, 10));
        thumbData && thumbData.state === "Completed" && (iconUrl = thumbData.imageUrl);
      } catch {
      }
      return { name, iconUrl };
    } catch {
      return { name: "Roblox Experience", iconUrl: null };
    }
  }
  __name(fetchGameDetails, "fetchGameDetails");
  async function fetchServerUptime(placeId, serverId) {
    if (!placeId || !serverId) return null;
    try {
      let response = await callRobloxApi({
        isRovalraApi: !0,
        endpoint: `/v1/servers/details?place_id=${placeId}&server_ids=${serverId}`
      });
      return response.ok && (await response.json())?.servers?.[0]?.first_seen || null;
    } catch {
      return null;
    }
  }
  __name(fetchServerUptime, "fetchServerUptime");
  async function fetchUserPresence(userId) {
    if (!userId) return null;
    try {
      let response = await callRobloxApi({
        subdomain: "presence",
        endpoint: "/v1/presence/users",
        method: "POST",
        body: { userIds: [parseInt(userId, 10)] }
      });
      if (!response.ok) return null;
      let data = await response.json();
      return data?.userPresences?.[0]?.rootPlaceId || data?.userPresences?.[0]?.placeId || null;
    } catch {
      return null;
    }
  }
  __name(fetchUserPresence, "fetchUserPresence");
  var buildInfoList = /* @__PURE__ */ __name((gameId, isPrivateServer, regionCode, regionName, serverInfo, placeVersion, serverChannel, rccVersion, serverUptime, ownerInfo) => {
    let liClass = 'class="rovalra-details-li"', verIcon = '<svg class="rovalra-info-icon" viewBox="0 0 24 24"><path d="M21 10.12h-6.78l2.74-2.82c-2.73-2.7-7.15-2.8-9.88-.1-2.73 2.71-2.73 7.08 0 9.79s7.15 2.71 9.88 0C18.32 15.65 19 14.08 19 12.1h2c0 1.98-.88 4.55-2.64 6.29-3.51 3.48-9.21 3.48-12.72 0-3.5-3.47-3.53-9.11-.02-12.58s9.14-3.47 12.65 0L21 3zM12.5 8v4.25l3.5 2.08-.72 1.21L11 13V8z"></path></svg>', timeIcon = '<svg class="rovalra-info-icon" viewBox="0 0 24 24"><path d="m22 5.7-4.6-3.9-1.3 1.5 4.6 3.9zM7.9 3.4 6.6 1.9 2 5.7l1.3 1.5zM12.5 8H11v6l4.7 2.9.8-1.2-4-2.4zM12 4c-5 0-9 4-9 9s4 9 9 9 9-4 9-9-4-9-9-9m0 16c-3.9 0-7-3.1-7-7s3.1-7 7-7 7 3.1 7 7-3.1 7-7 7"></path></svg>', rccIcon = '<svg class="rovalra-info-icon" viewBox="0 0 24 24"><path d="M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.11-.9-2-2-2m0 14H3V5h18z"></path></svg>', privIcon = '<svg class="rovalra-info-icon" viewBox="0 0 24 24"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2m-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2m3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1z"></path></svg>', channelIcon = '<svg class="rovalra-info-icon" viewBox="0 0 24 24"><path d="M15 9H9v6h6zm-2 4h-2v-2h2zm8-2V9h-2V7c0-1.1-.9-2-2-2h-2V3h-2v2h-2V3H9v2H7c-1.1 0-2 .9-2 2v2H3v2h2v2H3v2h2v2c0 1.1.9 2 2 2h2v2h2v-2h2v2h2v-2h2c1.1 0 2-.9 2-2v-2h2v-2h-2v-2zm-4 6H7V7h10z"></path></svg>', listItems = [];
    if (gameId && listItems.push(`<li style="white-space: nowrap;" ${liClass}><strong>ServerID:</strong> <span class="rovalra-spoiler" style="white-space: nowrap;">${gameId}</span></li>`), isPrivateServer && listItems.push(`<li ${liClass}>${privIcon}<strong>Private Server</strong></li>`), ownerInfo) {
      let ownerProfileUrl = `https://www.roblox.com/users/${ownerInfo.id}/profile`, ownerIconHtml = ownerInfo.thumbnailUrl ? `<img src="${ownerInfo.thumbnailUrl}" style="width:16px;height:16px;border-radius:50%;margin-right:6px;vertical-align:text-bottom;" alt="Owner">` : '<span style="width:16px;height:16px;border-radius:50%;margin-right:6px;background-color:#555;display:inline-block;vertical-align:text-bottom;"></span>';
      listItems.push(`<li ${liClass}>${ownerIconHtml}<strong>Owner:</strong> <a href="${ownerProfileUrl}" target="_blank" style="text-decoration: underline;">${ownerInfo.displayName}</a></li>`);
    }
    if (regionCode && regionName) {
      let flagUrl = `https://flagcdn.com/w20/${regionCode.toLowerCase().split("-")[0]}.png`;
      listItems.push(`<li ${liClass}><img src="${flagUrl}" alt="${regionCode}"> ${regionName}</li>`);
    }
    if (placeVersion && listItems.push(`<li ${liClass}>${verIcon} <strong>Version:</strong> ${placeVersion}</li>`), serverUptime) {
      let firstSeenDate = new Date(serverUptime), remainingSeconds = (/* @__PURE__ */ new Date() - firstSeenDate) / 1e3, days = Math.floor(remainingSeconds / 86400);
      remainingSeconds %= 86400;
      let hours = Math.floor(remainingSeconds / 3600);
      remainingSeconds %= 3600;
      let minutes = Math.floor(remainingSeconds / 60), parts = [];
      days > 0 && parts.push(`${days}d`), hours > 0 && parts.push(`${hours}h`), (minutes > 0 || parts.length === 0) && parts.push(`${minutes}m`), listItems.push(`<li ${liClass}>${timeIcon} <strong>Uptime:</strong> ${parts.join(" ")}</li>`);
    }
    rccVersion && listItems.push(`<li ${liClass}>${rccIcon} <strong>RCC:</strong> ${rccVersion}</li>`);
    let channelText = serverChannel || "Production";
    return listItems.push(`
        <li ${liClass}>
            ${channelIcon} 
            <strong>Server Channel:</strong> 
            <div class="rovalra-channel-wrapper">
                <span class="rovalra-channel-truncated">${channelText}</span>
                <span class="rovalra-channel-tooltip">${channelText}</span>
            </div>
        </li>
    `), purify.sanitize(listItems.join(""));
  }, "buildInfoList");
  async function pollClientStatus(targetPlaceId) {
    clientStatusReceived = !1, cleanupPolling();
    let isDownloadOptionShown = !1, unknownStatusCount = 0, triggerDownloadOption = /* @__PURE__ */ __name(() => {
      !clientStatusReceived && !isDownloadOptionShown && (isDownloadOptionShown = !0, showLoadingOverlayResult("Launching Roblox", {
        text: "Download Roblox",
        onClick: showDownloadUI
      }), setTimeout(() => {
        let buttons = document.querySelectorAll("button");
        for (let btn of buttons)
          if (btn.textContent.includes("Download Roblox")) {
            let wrapper = document.createElement("div");
            wrapper.innerHTML = purify.sanitize('<button type="button" class="foundation-web-button relative clip group/interactable focus-visible:outline-focus disabled:outline-none cursor-pointer relative flex items-center justify-center stroke-none padding-y-none select-none radius-medium text-label-medium height-1000 padding-x-medium bg-action-emphasis content-action-emphasis grow" style="text-decoration: none;"><div role="presentation" class="absolute inset-[0] transition-colors group-hover/interactable:bg-[var(--color-state-hover)] group-active/interactable:bg-[var(--color-state-press)] group-disabled/interactable:bg-none"></div><span class="padding-y-xsmall text-truncate-end text-no-wrap">Download Roblox</span></button>');
            let newBtn = wrapper.firstChild;
            newBtn && (newBtn.onclick = showDownloadUI, btn.replaceWith(newBtn));
            break;
          }
      }, 50));
    }, "triggerDownloadOption"), showDownloadUI = /* @__PURE__ */ __name(() => {
      if (document.getElementById("rovalra-download-dialog-container")) return;
      let startDownload = /* @__PURE__ */ __name(() => {
        window.open(`https://www.roblox.com/download/client?_=${Date.now()}`, "_blank");
      }, "startDownload");
      startDownload(), hideLoadingOverlay();
      let dialogWrapper = document.createElement("div");
      dialogWrapper.id = "rovalra-download-dialog-container", dialogWrapper.style.cssText = "position: fixed; inset: 0; z-index: 99999; display: flex; align-items: center; justify-content: center; background-color: rgba(0,0,0,0.6);", dialogWrapper.innerHTML = purify.sanitize(`<div role="dialog" id="radix-0" aria-describedby="radix-2" aria-labelledby="radix-1" data-state="open" class="relative radius-large bg-surface-100 stroke-muted stroke-standard foundation-web-dialog-content shadow-transient-high install-dialog" data-size="Large" tabindex="-1" style="pointer-events: auto;"><div class="absolute foundation-web-dialog-close-container"><button type="button" class="foundation-web-close-affordance flex stroke-none bg-none cursor-pointer relative clip group/interactable focus-visible:outline-focus disabled:outline-none bg-over-media-100 padding-medium radius-circle" aria-label="Close"><div role="presentation" class="absolute inset-[0] transition-colors group-hover/interactable:bg-[var(--color-state-hover)] group-active/interactable:bg-[var(--color-state-press)] group-disabled/interactable:bg-none"></div><span role="presentation" class="grow-0 shrink-0 basis-auto icon icon-regular-x size-[var(--icon-size-large)]"></span></button></div><div class="padding-x-xlarge padding-top-xlarge padding-bottom-xlarge content-default"><div class="flex flex-col gap-xlarge padding-xlarge"><div class="flex flex-col gap-xsmall"><h2 id="radix-1" class="text-heading-medium content-emphasis padding-none">Thanks for downloading Roblox</h2><p class="text-body-large">Just follow the steps below to install Roblox. Download should start in a few seconds. If it doesn't, <a id="rovalra-restart-download" href="#" class="download-link-underline">restart the download</a>.</p></div><div></div> <div class="flex gap-xxlarge"><section class="flex flex-col gap-large grow basis-0"><h3 class="text-title-large content-emphasis padding-none">Install Instructions</h3><ol class="download-instructions-list flex flex-col gap-xlarge margin-none padding-left-large text-body-medium"><li class="padding-left-medium">Once downloaded, double-click the <b>RobloxPlayerInstaller.exe</b> file in your Downloads folder.</li><li class="padding-left-medium">Double-click the <b>RobloxPlayerInstaller</b> to install the app.</li><li class="padding-left-medium">Follow the instructions to install Roblox to your computer.</li><li class="padding-left-medium">Now that it\u2019s installed, <a id="download-join-experience" class="download-link-underline" style="cursor: pointer;">join the experience</a>.</li></ol></section><div></div> <div class="stroke-standard stroke-default"></div><div></div> <section class="flex flex-col grow basis-0 gap-xxlarge"><div class="flex flex-col gap-small"><h3 class="text-label-large content-emphasis padding-none">Don't forget the mobile app</h3><p class="text-body-medium">Scan this code with your phone's camera to get Roblox.</p></div><div class="flex grow justify-center items-center bg-shift-100 radius-medium padding-x-large"><div class="radius-medium padding-small bg-[white]"><img class="size-2100" src="https://images.rbxcdn.com/79852c254bf43f36.webp" alt=""></div></div></section></div></div></div></div>`, { ADD_ATTR: ["id"] }), document.body.appendChild(dialogWrapper);
      let closeDialog = /* @__PURE__ */ __name(() => {
        dialogWrapper.remove(), closeInterface(!0);
      }, "closeDialog"), closeBtn = dialogWrapper.querySelector('button[aria-label="Close"]');
      closeBtn && (closeBtn.onclick = closeDialog);
      let joinLink = dialogWrapper.querySelector("#download-join-experience");
      joinLink && (joinLink.onclick = (e) => {
        e.preventDefault(), closeDialog(), targetPlaceId && launchGame(targetPlaceId);
      });
      let restartLink = dialogWrapper.querySelector("#rovalra-restart-download");
      restartLink && (restartLink.onclick = (e) => {
        e.preventDefault(), startDownload();
      });
    }, "showDownloadUI"), performClientStatusCheck = /* @__PURE__ */ __name(async () => {
      try {
        let response = await callRobloxApi({
          subdomain: "apis",
          endpoint: "/matchmaking-api/v1/client-status",
          method: "GET",
          noCache: !0
        });
        if (response.ok) {
          let data = await response.json();
          handleClientStatus(data);
        }
      } catch {
      }
    }, "performClientStatusCheck"), handleClientStatus = /* @__PURE__ */ __name((data) => {
      data && data.status && (data.status === "Unknown" ? (unknownStatusCount++, unknownStatusCount >= 3 ? triggerDownloadOption() : setTimeout(() => {
        performClientStatusCheck();
      }, 1e3)) : (unknownStatusCount = 0, isDownloadOptionShown && (isDownloadOptionShown = !1, updateLoadingOverlayText("Joining Server...")), data.status === "InGame" && triggerSuccess()));
    }, "handleClientStatus");
    document.addEventListener("rovalra-game-launch-success", handleGameLaunchSuccess);
    let currentUserElement = document.querySelector('meta[name="user-data"]'), currentUserId = currentUserElement ? currentUserElement.dataset.userid : null;
    currentUserId && (performClientStatusCheck(), pollingInterval = setInterval(async () => {
      if (!document.body.classList.contains(HIDE_ROBLOX_UI_CLASS) || clientStatusReceived) {
        cleanupPolling();
        return;
      }
      performClientStatusCheck();
      try {
        let resp = await callRobloxApi({
          subdomain: "presence",
          endpoint: "/v1/presence/users",
          method: "POST",
          body: { userIds: [parseInt(currentUserId, 10)] }
        });
        if (resp.ok) {
          let presence = (await resp.json())?.userPresences?.[0];
          presence && (presence.userPresenceType === 2 || presence.userPresenceType === 4) && (targetPlaceId && presence.rootPlaceId === parseInt(targetPlaceId, 10) ? triggerSuccess() : targetPlaceId || triggerSuccess());
        }
      } catch {
      }
    }, 3e3));
  }
  __name(pollClientStatus, "pollClientStatus");
  var customLogoId = "rovalra-custom-logo", targetSelectors = ["span.app-icon-bluebg.app-icon-windows.app-icon-size-96", "div.MuiGrid-root div.app-icon-bluebg.app-icon-windows", ".app-icon-windows.app-icon-bluebg"];
  function applyCustomLogo(imageData, element) {
    if (element) {
      let size = element.closest("div[role='dialog']") || element.closest(".MuiDialog-paper") ? { width: "64px", height: "64px" } : { width: "96px", height: "96px" };
      if (element.id === customLogoId) {
        Object.assign(element.style, size);
        return;
      }
      let img = document.createElement("img");
      img.id = customLogoId, img.src = imageData, Object.assign(img.style, { ...size, objectFit: "contain" }), element.replaceWith(img);
    }
  }
  __name(applyCustomLogo, "applyCustomLogo");
  function initRevertLogo() {
    chrome.storage.local.get({ revertLogo: !1, customLogoData: null }, (settings) => {
      if (settings.revertLogo === !0 && settings.customLogoData) {
        let callback = /* @__PURE__ */ __name((el2) => applyCustomLogo(settings.customLogoData, el2), "callback");
        targetSelectors.forEach((selector) => observeElement(selector, callback));
      }
    });
  }
  __name(initRevertLogo, "initRevertLogo");
  function initializeJoinDialogEnhancer() {
    document.addEventListener("rovalra-game-servers-response", (event) => {
      let { data } = event.detail;
      if (data && data.data && Array.isArray(data.data) && currentGameId) {
        let server = data.data.find((s) => s.id === currentGameId);
        server && (interceptedServerData = { playing: server.playing, maxPlayers: server.maxPlayers, fps: server.fps, ping: server.ping });
      }
    }), chrome.storage.local.get({ whatamIJoiningEnabled: !0, AlwaysGetInfo: !1, customLogoData: null, revertLogo: !1, closeUiByClickingTheBackground: !0 }, (settings) => {
      let processGameLaunchData = /* @__PURE__ */ __name(async (gameLaunchFrame) => {
        gameLaunchElementExists = !0;
        let gameLaunchSrc = gameLaunchFrame?.src;
        if (!gameLaunchSrc || !gameLaunchSrc.includes("placelauncherurl:") || gameLaunchSrc === lastProcessedGameLaunchSrc) return;
        lastProcessedGameLaunchSrc = gameLaunchSrc, currentGameId = null, interceptedServerData = null;
        let logoToUse = settings.revertLogo === !0 && settings.customLogoData ? settings.customLogoData : null;
        openInterface(null, logoToUse, settings.closeUiByClickingTheBackground);
        let urlParams, placeId;
        try {
          let urlString = gameLaunchSrc.substring(gameLaunchSrc.indexOf("placelauncherurl:")), decodedUrlString = decodeURIComponent(urlString.split("+")[0].substring(17));
          urlParams = new URLSearchParams(new URL(decodedUrlString).search), placeId = urlParams.get("placeId");
        } catch {
          showLoadingOverlayResult("Error parsing URL", { text: "Close", onClick: /* @__PURE__ */ __name(() => closeInterface(!0), "onClick") });
          return;
        }
        if (!placeId && urlParams.get("request") === "RequestFollowUser") {
          let userId = urlParams.get("userId");
          userId && (updateLoadingOverlayText("Finding user..."), placeId = await fetchUserPresence(userId));
        }
        let gameDetailsPromise = Promise.resolve({ name: "Roblox Experience", iconUrl: null });
        placeId && (gameDetailsPromise = fetchGameDetails(placeId));
        let requestType = urlParams.get("request"), isRequestGame = requestType === "RequestGame" || requestType === "RequestGameJob", hasGameId = urlParams.has("gameId"), hasAccessCode = urlParams.has("accessCode"), isGenericJoin = isRequestGame && !hasGameId && !hasAccessCode, isPrivateServer = requestType === "RequestPrivateGame", isFollowingUser = requestType === "RequestFollowUser";
        hasGameId && (currentGameId = urlParams.get("gameId"));
        let joinApiResponse = null;
        if (settings.AlwaysGetInfo) {
          updateLoadingOverlayText("Fetching server info...");
          try {
            await ensureDatacenterDataIsParsed();
            let retries = 0, MAX_RETRIES2 = 5;
            for (; !joinApiResponse && document.body.classList.contains(HIDE_ROBLOX_UI_CLASS) && retries < MAX_RETRIES2; ) {
              retries++;
              try {
                let response = null, apiBody = { gameJoinAttemptId: crypto.randomUUID(), placeId: parseInt(placeId, 10) };
                if (isGenericJoin)
                  response = await callRobloxApi({
                    subdomain: "gamejoin",
                    endpoint: "/v1/join-game",
                    method: "POST",
                    body: apiBody
                  });
                else if (isPrivateServer) {
                  let accessCode = urlParams.get("accessCode"), linkCode = urlParams.get("linkCode") || "";
                  response = await callRobloxApi({
                    subdomain: "gamejoin",
                    endpoint: "/v1/join-private-game",
                    method: "POST",
                    body: { ...apiBody, accessCode, linkCode, isTeleport: !1 }
                  });
                } else if (isFollowingUser) {
                  let userIdToFollow = urlParams.get("userId");
                  response = await callRobloxApi({
                    subdomain: "gamejoin",
                    endpoint: "/v1/play-with-user",
                    method: "POST",
                    body: { userIdToFollow: parseInt(userIdToFollow, 10) }
                  });
                } else currentGameId && (response = await callRobloxApi({
                  subdomain: "gamejoin",
                  endpoint: "/v1/join-game-instance",
                  method: "POST",
                  body: { ...apiBody, gameId: currentGameId }
                }));
                if (response && response.ok) {
                  let data = await response.json();
                  if (data?.status === 12 || data?.message && data.message.includes("non-root place")) {
                    showLoadingOverlayResult(data.message || "Cannot join: Non-root place restrictions.", {
                      text: "Close",
                      onClick: /* @__PURE__ */ __name(() => closeInterface(!0), "onClick")
                    });
                    return;
                  }
                  if (data?.joinScript) {
                    joinApiResponse = data;
                    break;
                  }
                }
              } catch (innerErr) {
                console.error("Join API attempt failed:", innerErr);
              }
              !joinApiResponse && retries < MAX_RETRIES2 && await new Promise((r) => setTimeout(r, 2e3));
            }
            joinApiResponse?.joinScript?.GameId && (currentGameId = joinApiResponse.joinScript.GameId);
          } catch (e) {
            console.error("Error in server info fetch loop:", e);
          }
        }
        if (document.body.classList.contains(HIDE_ROBLOX_UI_CLASS))
          try {
            let joinScript = joinApiResponse?.joinScript, regionCode, regionName, ownerInfo, serverUptime;
            if (joinScript) {
              let resolvedGameId = joinScript.GameId || currentGameId;
              if (joinScript.PrivateServerOwnerID)
                try {
                  let ownerId = joinScript.PrivateServerOwnerID, [uData, thumbMap] = await Promise.all([
                    callRobloxApi({ subdomain: "users", endpoint: "/v1/users", method: "POST", body: { userIds: [ownerId] } }).then((r) => r.json()),
                    fetchThumbnails([{ id: ownerId }], "AvatarHeadshot", "48x48", !1)
                  ]), thumbData = thumbMap.get(ownerId);
                  uData?.data?.[0] && (ownerInfo = {
                    id: uData.data[0].id,
                    displayName: uData.data[0].displayName,
                    thumbnailUrl: thumbData?.imageUrl || null
                  });
                } catch {
                }
              let dataCenterId = joinScript.DataCenterId;
              if (dataCenterId && serverIpMap2[dataCenterId]) {
                let loc = serverIpMap2[dataCenterId];
                regionCode = loc.country, regionName = loc.region ? `${loc.city}, ${loc.region}` : loc.city;
              }
              resolvedGameId && (serverUptime = await fetchServerUptime(placeId, resolvedGameId));
              let htmlDetails = buildInfoList(resolvedGameId, isPrivateServer, regionCode, regionName, interceptedServerData, joinScript.PlaceVersion, joinScript.ChannelName, joinScript.RccVersion, serverUptime, ownerInfo), gameDetails = await gameDetailsPromise;
              updateServerInfo(gameDetails.name, gameDetails.iconUrl, htmlDetails), updateLoadingOverlayText("Joining Server...");
            } else {
              currentGameId && (serverUptime = await fetchServerUptime(placeId, currentGameId));
              let htmlDetails = buildInfoList(currentGameId, isPrivateServer, null, null, interceptedServerData, null, null, null, serverUptime, null), details = await gameDetailsPromise;
              updateServerInfo(details.name, details.iconUrl, htmlDetails), updateLoadingOverlayText("Waiting for Roblox...");
            }
            pollClientStatus(placeId);
          } catch (e) {
            console.error("Rendering error:", e);
            let details = await gameDetailsPromise;
            updateServerInfo(details.name, details.iconUrl, null), updateLoadingOverlayText("Launching..."), pollClientStatus(placeId);
          }
      }, "processGameLaunchData");
      settings.whatamIJoiningEnabled && observeElement("#gamelaunch", processGameLaunchData, {
        observeAttributes: !0,
        onRemove: /* @__PURE__ */ __name(() => {
          gameLaunchElementExists = !1;
        }, "onRemove")
      });
    });
  }
  __name(initializeJoinDialogEnhancer, "initializeJoinDialogEnhancer");
  function initialize() {
    try {
      initRevertLogo(), initializeJoinDialogEnhancer();
    } catch {
    }
  }
  __name(initialize, "initialize");
  function init2() {
    closeInterface(!0), document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", initialize, { once: !0 }) : initialize();
  }
  __name(init2, "init");

  // src/content/features/sitewide/easterEggs/links.js
  function handleCatsPage() {
    observeElement("#content", /* @__PURE__ */ __name((contentDiv) => {
      contentDiv.innerHTML = "", contentDiv.style.position = "relative";
      let header = document.createElement("h1");
      header.textContent = "CATS!!!!!", contentDiv.appendChild(header);
      let numberOfCats = 30, catImagePromises = [];
      for (let i = 0; i < numberOfCats; i++)
        catImagePromises.push(
          fetch("https://api.thecatapi.com/v1/images/search").then((response) => {
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return response.json();
          }).then((data) => data && data.length > 0 && data[0].url ? data[0].url : null).catch((error) => (console.error("Error fetching cat image:", error), null))
        );
      Promise.all(catImagePromises).then((catImageUrls) => {
        catImageUrls.forEach((catImageUrl) => {
          if (catImageUrl) {
            let imgElement = document.createElement("img");
            imgElement.src = catImageUrl, imgElement.alt = "Random cat image", Object.assign(imgElement.style, {
              maxWidth: "150px",
              maxHeight: "150px",
              display: "inline-block",
              pointerEvents: "none",
              marginTop: `${Math.random() * 40 - 20}px`,
              marginBottom: `${Math.random() * 40 - 20}px`,
              marginLeft: `${Math.random() * 40 - 20}px`,
              marginRight: `${Math.random() * 40 - 20}px`,
              verticalAlign: ["top", "middle", "bottom"][Math.floor(Math.random() * 3)]
            }), contentDiv.appendChild(imgElement);
          }
        });
      }).catch((error) => {
        console.error("Error processing cat image promises:", error), contentDiv.textContent = "Failed to load cat images :C";
      });
    }, "clearContentAndLoadCats"));
  }
  __name(handleCatsPage, "handleCatsPage");
  function init3() {
    chrome.storage.local.get("eastereggslinksEnabled", (result) => {
      if (result.eastereggslinksEnabled) {
        let path = window.location.pathname, redirects = {
          "/cats": handleCatsPage,
          "/fishstrap": /* @__PURE__ */ __name(() => window.location.href = "https://fishstrap.app", "/fishstrap"),
          "/rovalra": /* @__PURE__ */ __name(() => window.location.href = "https://rovalra.com", "/rovalra"),
          "/roseal": /* @__PURE__ */ __name(() => window.location.href = "https://www.roseal.live", "/roseal"),
          "/rokitty": /* @__PURE__ */ __name(() => window.location.href = "https://www.rokitty.app", "/rokitty"),
          "/roqol": /* @__PURE__ */ __name(() => window.location.href = "https://roqol.io/", "/roqol")
        };
        redirects[path] && redirects[path]();
      }
    });
  }
  __name(init3, "init");

  // src/content/features/sitewide/cssfixes.js
  var applyImpersonateAttribute = /* @__PURE__ */ __name((headerContainer) => {
    chrome.storage.local.get("impersonateRobloxStaffSetting", function(data) {
      data.impersonateRobloxStaffSetting && headerContainer.setAttribute("data-mayimpersonate", "true");
    });
  }, "applyImpersonateAttribute"), applyHeaderFix = /* @__PURE__ */ __name((profileHeader) => {
    if (profileHeader.dataset.headerFixApplied) return;
    profileHeader.dataset.headerFixApplied = "true";
    let headerNames = profileHeader.querySelector(".profile-header-names"), headerDetails = profileHeader.querySelector(".profile-header-details"), headerMain = profileHeader.querySelector(".profile-header-main"), headerButtons = profileHeader.querySelector(".profile-header-buttons"), headerMisc = profileHeader.querySelector(".header-misc");
    if (headerNames && headerDetails && headerMain && headerButtons) {
      headerNames.parentElement !== headerMain && headerMain.insertBefore(headerNames, headerButtons), headerMisc && headerNames.appendChild(headerMisc), headerDetails.parentElement !== profileHeader && profileHeader.appendChild(headerDetails);
      let css = `
            .profile-avatar-thumb { width: 128px !important; height: 128px !important; }
            .profile-header-main { margin-bottom: 0 !important; }
            .profile-header-details { padding: 0 !important; padding-bottom: 24px !important; }
            .profile-header-social-counts { padding-left: 167px; box-sizing: border-box; }
            .profile-header-names { display: flex; flex-direction: column; align-items: flex-start; gap: 8px; }
            .header-misc { display: flex; flex-wrap: wrap; align-items: center; gap: 12px; }
            @media (max-width: 768px) { .profile-header-social-counts { padding-left: 0; } }
        `, style = document.createElement("style");
      style.textContent = css, document.head.appendChild(style), console.log("CSS Fixer: Header fix applied successfully.");
    }
  }, "applyHeaderFix"), applyHomeHeaderLinkFix = /* @__PURE__ */ __name(() => {
    chrome.storage.local.get("giantInvisibleLink", function(settings) {
      if (!settings.giantInvisibleLink || window.location.pathname !== "/home")
        return;
      observeElement('a[data-testid="section-header-title-subtitle-container"]', (anchor) => {
        if (anchor.dataset.rovalraLinkFixApplied) return;
        anchor.dataset.rovalraLinkFixApplied = "true";
        let innerDiv = anchor.querySelector('div[data-testid="text-icon-row"]');
        if (!innerDiv) return;
        let newAnchor = document.createElement("a");
        for (newAnchor.href = anchor.href, newAnchor.className = "css-j5e4nw-textIconRow", newAnchor.setAttribute("aria-label", anchor.getAttribute("aria-label")), newAnchor.style.display = "inline-flex", newAnchor.style.width = "fit-content", newAnchor.style.minWidth = "fit-content"; innerDiv.firstChild; )
          newAnchor.appendChild(innerDiv.firstChild);
        anchor.replaceWith(newAnchor);
      }, { multiple: !0 });
    });
  }, "applyHomeHeaderLinkFix"), applyGameTitleFix = /* @__PURE__ */ __name(() => {
    chrome.storage.local.get("gameTitleIssueEnable", function(settings) {
      if (!settings.gameTitleIssueEnable || !window.location.href.includes("profile")) return;
      let css = `
            .slide-item-name.games.font-title {
                line-height: normal !important;
            }
        `, style = document.createElement("style");
      style.textContent = css, (document.head || document.documentElement).appendChild(style);
    });
  }, "applyGameTitleFix"), applyCartRemoveButtonFix = /* @__PURE__ */ __name(() => {
    chrome.storage.local.get("FixCartRemoveButton", function(settings) {
      if (!settings.FixCartRemoveButton) return;
      let css = `
            .cart-item-container .rm-item-btn-container.icon-actions-clear-sm button {
                width: 18px;
                height: 18px;
            }
        `, style = document.createElement("style");
      style.textContent = css, (document.head || document.documentElement).appendChild(style);
    });
  }, "applyCartRemoveButtonFix");
  function init4() {
    chrome.storage.local.get(["cssfixesEnabled", "giantInvisibleLink"], function(data) {
      data.cssfixesEnabled === !0 && (observeElement("#profile-header-container", applyImpersonateAttribute), observeElement(".profile-header", applyHeaderFix), applyHomeHeaderLinkFix(), applyGameTitleFix(), applyCartRemoveButtonFix());
    });
  }
  __name(init4, "init");

  // src/content/features/catalog/hiddenCatalog.js
  var currentMode = "dark";
  function removeHomeElement() {
    let homeElementToRemove = document.querySelector("li.cursor-pointer.btr-nav-node-header_home.btr-nav-header_home");
    homeElementToRemove && homeElementToRemove.remove();
  }
  __name(removeHomeElement, "removeHomeElement");
  function applyTheme(mode) {
    currentMode = mode, localStorage.setItem("hiddenCatalogMode", mode), document.documentElement.setAttribute("data-theme", mode);
    let contentDiv = document.querySelector(".content#content");
    contentDiv && (contentDiv.classList.toggle("light-mode", mode === "light"), contentDiv.classList.toggle("dark-mode", mode !== "light"));
    let selectors = [
      ".hidden-catalog-header h1",
      ".hidden-catalog-header img",
      "#hidden-catalog-description",
      ".item-name",
      ".item-container",
      ".shimmer",
      ".icon-in-review"
    ];
    document.querySelectorAll(selectors.join(", ")).forEach((el2) => {
      el2.classList.toggle("light-mode", mode === "light"), el2.classList.toggle("dark-mode", mode !== "light");
    });
  }
  __name(applyTheme, "applyTheme");
  async function fetchItemDetails(itemId) {
    try {
      return await callRobloxApiJson({ subdomain: "economy", endpoint: `/v2/assets/${itemId}/details` }) || null;
    } catch (err) {
      return console.error("Failed to fetch item details for", itemId, err), null;
    }
  }
  __name(fetchItemDetails, "fetchItemDetails");
  function displayApiError(message) {
    let contentDiv = document.querySelector(".content#content");
    if (!contentDiv) return;
    let existing = contentDiv.querySelector(".hidden-catalog-api-error");
    existing && existing.remove();
    let p = document.createElement("p");
    p.className = "hidden-catalog-api-error", p.style.color = "var(--danger, red)", p.style.padding = "16px", p.style.textAlign = "center", p.textContent = message;
    let desc = document.getElementById("hidden-catalog-description");
    desc ? contentDiv.insertBefore(p, desc.nextSibling) : contentDiv.appendChild(p);
  }
  __name(displayApiError, "displayApiError");
  async function displayItems(itemsWithDetails) {
    let contentDiv = document.querySelector(".content#content");
    if (!contentDiv) return;
    let wrapper = contentDiv.querySelector(".hidden-catalog.items-wrapper");
    wrapper ? wrapper.innerHTML = "" : (wrapper = document.createElement("div"), wrapper.className = "hidden-catalog items-wrapper", wrapper.style.display = "grid", wrapper.style.gridTemplateColumns = "repeat(auto-fill, minmax(221.75px, 1fr))", wrapper.style.gap = "5px", wrapper.style.width = "100%", wrapper.style.marginLeft = "30px", contentDiv.appendChild(wrapper)), itemsWithDetails.forEach((item) => {
      let link = document.createElement("a");
      link.className = "item-container", link.classList.add(currentMode === "light" ? "light-mode" : "dark-mode"), link.href = `https://www.roblox.com/catalog/${item.item_id}/${encodeURIComponent(item.name || "Item")}`, link.style.display = "flex", link.style.flexDirection = "column", link.style.justifyContent = "space-between", link.style.borderRadius = "8px", link.style.overflow = "hidden", link.style.minHeight = "221.75px", link.style.width = "221.75px", link.style.cursor = "pointer";
      let thumbWrap = document.createElement("div");
      thumbWrap.className = "thumbnail-container", thumbWrap.style.position = "relative", thumbWrap.style.height = "221.75px", thumbWrap.style.width = "100%", thumbWrap.style.borderRadius = "8px", thumbWrap.style.display = "flex", thumbWrap.style.justifyContent = "center", thumbWrap.style.alignItems = "center";
      let shimmer = document.createElement("div");
      if (shimmer.className = "thumbnail-2d-container shimmer", shimmer.classList.add(currentMode === "light" ? "light-mode" : "dark-mode"), shimmer.style.height = "221.75px", shimmer.style.width = "100%", shimmer.style.borderRadius = "8px", thumbWrap.appendChild(shimmer), item.details && item.details.ProductId !== 0) {
        let released = document.createElement("div");
        released.className = "released-label", released.textContent = "Released", released.style.position = "absolute", released.style.left = "5px", released.style.top = "5px", released.style.background = "#e57b00", released.style.color = "#fff", released.style.padding = "5px", released.style.borderRadius = "5px", released.style.fontSize = "12px", released.style.fontWeight = "bold", released.style.zIndex = "2", thumbWrap.appendChild(released);
      }
      let meta = document.createElement("div");
      meta.className = "item-details", meta.style.padding = "10px 0", meta.style.display = "flex", meta.style.flexDirection = "column", meta.style.justifyContent = "space-between", meta.style.height = "100%";
      let nameContainer = document.createElement("div");
      nameContainer.style.display = "flex", nameContainer.style.flexDirection = "column", nameContainer.style.gap = "2px", nameContainer.style.position = "relative";
      let title = document.createElement("p");
      title.className = "item-name", title.classList.add(currentMode === "light" ? "light-mode" : "dark-mode");
      let displayName = item.name || "Name Unavailable", originalName = item.details && item.details.Name ? item.details.Name : displayName;
      if (title.textContent = displayName, title.style.fontWeight = "600", title.style.fontSize = "18px", title.style.margin = "0", title.style.paddingRight = "25px", title.style.overflow = "hidden", title.style.textOverflow = "ellipsis", title.style.whiteSpace = "nowrap", item.details && item.details.Name && item.details.Name !== item.name) {
        let toggleButton = document.createElement("button");
        toggleButton.style.position = "absolute", toggleButton.style.right = "5px", toggleButton.style.top = "0", toggleButton.style.padding = "2px 5px", toggleButton.style.fontSize = "13px", toggleButton.style.cursor = "pointer", toggleButton.style.backgroundColor = "transparent", toggleButton.style.border = "0px solid #666", toggleButton.textContent = "\u21BA", toggleButton.title = "Toggle original name", toggleButton.style.color = "#666";
        let showingOriginal = !1;
        toggleButton.onclick = (e) => {
          e.preventDefault(), e.stopPropagation(), showingOriginal ? (title.textContent = displayName, toggleButton.style.color = "#666") : (title.textContent = originalName, toggleButton.style.color = "var(--rovalra-main-text-color)"), showingOriginal = !showingOriginal;
        }, nameContainer.appendChild(toggleButton);
      }
      nameContainer.appendChild(title), meta.appendChild(nameContainer), link.appendChild(thumbWrap), link.appendChild(meta), wrapper.appendChild(link);
    });
    try {
      let itemsForThumb = itemsWithDetails.map((it2) => ({ id: it2.item_id })), thumbnailMap = await fetchThumbnails(itemsForThumb, "Asset", "250x250", !1);
      wrapper.querySelectorAll(".item-container").forEach((linkEl, index) => {
        let item = itemsWithDetails[index], thumbContainer = linkEl.querySelector(".thumbnail-container");
        if (!thumbContainer) return;
        let releasedLabel = thumbContainer.querySelector(".released-label"), idKey = Number(item.item_id), thumbData = thumbnailMap.get(idKey) || thumbnailMap.get(String(idKey));
        if (thumbData && thumbData.state === "InReview") {
          thumbContainer.innerHTML = "", releasedLabel && thumbContainer.appendChild(releasedLabel);
          let shimmerDiv = document.createElement("div");
          shimmerDiv.className = "thumbnail-2d-container shimmer", shimmerDiv.classList.add(currentMode === "light" ? "light-mode" : "dark-mode"), shimmerDiv.style.height = "221.75px", shimmerDiv.style.width = "100%", shimmerDiv.style.borderRadius = "8px", thumbContainer.appendChild(shimmerDiv), setTimeout(() => {
            thumbContainer.innerHTML = "", releasedLabel && thumbContainer.appendChild(releasedLabel);
            let inReviewDiv = document.createElement("div");
            inReviewDiv.className = "thumbnail-2d-container icon-in-review", inReviewDiv.classList.add(currentMode === "light" ? "light-mode" : "dark-mode"), inReviewDiv.style.height = "221.75px", inReviewDiv.style.width = "100%", inReviewDiv.style.borderRadius = "8px", thumbContainer.appendChild(inReviewDiv);
          }, 6e3);
        } else if (thumbData && thumbData.imageUrl) {
          thumbContainer.style.backgroundColor = "rgb(78 78 78 / 20%)";
          let tempShimmer = thumbContainer.querySelector(".shimmer");
          tempShimmer || (tempShimmer = document.createElement("div"), tempShimmer.className = "thumbnail-2d-container shimmer", tempShimmer.classList.add(currentMode === "light" ? "light-mode" : "dark-mode"), tempShimmer.style.height = "221.75px", tempShimmer.style.width = "100%", tempShimmer.style.borderRadius = "8px", thumbContainer.appendChild(tempShimmer));
          let img = document.createElement("img");
          img.src = thumbData.imageUrl, img.alt = item.name, img.className = "item-thumbnail", img.style.width = "100%", img.style.height = "100%", img.style.objectFit = "contain", img.style.borderRadius = "8px", img.style.display = "none", img.onload = () => {
            tempShimmer && tempShimmer.remove(), img.style.display = "block";
          }, img.onerror = () => {
            thumbContainer.style.backgroundColor = "", tempShimmer && tempShimmer.remove();
            let errShimmer = document.createElement("div");
            errShimmer.className = "thumbnail-2d-container shimmer", errShimmer.classList.add(currentMode === "light" ? "light-mode" : "dark-mode"), errShimmer.style.height = "221.75px", errShimmer.style.borderRadius = "8px", thumbContainer.appendChild(errShimmer);
          }, thumbContainer.appendChild(img);
        } else {
          thumbContainer.innerHTML = "", releasedLabel && thumbContainer.appendChild(releasedLabel), thumbContainer.style.backgroundColor = "";
          let fallbackShimmer = document.createElement("div");
          fallbackShimmer.className = "thumbnail-2d-container shimmer", fallbackShimmer.classList.add(currentMode === "light" ? "light-mode" : "dark-mode"), fallbackShimmer.style.height = "221.75px", fallbackShimmer.style.borderRadius = "8px", thumbContainer.appendChild(fallbackShimmer);
        }
      });
    } catch (err) {
      console.error("Hidden Catalog thumbnails error", err);
    }
  }
  __name(displayItems, "displayItems");
  async function fetchDataFromAPI(page = 1, limit = 24) {
    let apiUrl = "https://catalog.rovalra.com/items";
    try {
      let requestHeaders = new Headers();
      requestHeaders.append("Accept", "application/json, text/plain, */*"), requestHeaders.append("Accept-Language", "en-US,en-UK,en;q=0.9"), requestHeaders.append("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36");
      let resp = await fetch(apiUrl, {
        method: "GET",
        headers: requestHeaders,
        redirect: "manual",
        cache: "no-store"
      });
      if (!resp.ok) throw new Error(`Catalog responded ${resp.status}`);
      let json = await resp.json(), items = Array.isArray(json.items) ? json.items : [];
      if (items.length === 0) return [];
      let detailsPromises = items.map((it2) => fetchItemDetails(it2.item_id)), details = await Promise.all(detailsPromises);
      return items.map((it2, idx) => ({ ...it2, details: details[idx] }));
    } catch (err) {
      return console.error("Hidden Catalog fetch failed", err), displayApiError("Failed to fetch hidden catalog items."), [];
    }
  }
  __name(fetchDataFromAPI, "fetchDataFromAPI");
  async function removeHiddenCatalogContent() {
    let contentDiv = document.querySelector(".content#content");
    if (!contentDiv) return;
    contentDiv.innerHTML = "", contentDiv.style.position = "relative";
    let headerContainer = document.createElement("div");
    headerContainer.className = "hidden-catalog-header", headerContainer.style.position = "relative", headerContainer.style.display = "flex", headerContainer.style.alignItems = "center", headerContainer.style.marginBottom = "20px";
    let h1 = document.createElement("h1");
    h1.textContent = "Hidden Catalog", h1.style.fontWeight = "800", h1.style.fontSize = "2em", h1.style.margin = "0", h1.style.padding = "10px 0";
    let img = document.createElement("img");
    img.src = getAssets().rovalraIcon, img.alt = "Hidden Catalog Icon", img.style.width = "32px", img.style.height = "32px", img.style.verticalAlign = "middle", img.style.marginLeft = "10px", headerContainer.appendChild(h1), headerContainer.appendChild(img), contentDiv.appendChild(headerContainer);
    let desc = document.createElement("div");
    desc.id = "hidden-catalog-description", desc.style.paddingTop = "10px", desc.style.paddingBottom = "20px", desc.innerHTML = purify.sanitize(`
        <p>The Hidden Catalog shows items uploaded by Roblox which are not yet on the marketplace.</p>
        <p><b>Roblox has patched this...</p>
        <p>Keep in mind that some of these items may never be released, as they could have been test uploads by Roblox.</p>
        <p>Most items will not have a thumbnail / mesh while being on the hidden catalog.</p>
        <p><b>To open the item page you will need <a href="https://www.roseal.live/" target="_blank" style="text-decoration: underline; color: inherit;">RoSeal</a></b></p>
    `), contentDiv.appendChild(desc);
    let items = await fetchDataFromAPI(1, 24);
    items.length > 0 && await displayItems(items), applyTheme(currentMode);
  }
  __name(removeHiddenCatalogContent, "removeHiddenCatalogContent");
  function init5() {
    chrome.storage.local.get({ hiddenCatalogEnabled: !1 }, function(result) {
      if (!result.hiddenCatalogEnabled) return;
      window.addEventListener("themeDetected", (event) => {
        applyTheme(event.detail.theme);
      });
      let storedTheme = localStorage.getItem("hiddenCatalogMode") || document.documentElement.getAttribute("data-theme") || "dark";
      applyTheme(storedTheme), observeElement("#navigation-robux-container a.robux-menu-btn", (robuxButtonLink) => {
        let container = document.getElementById("navigation-robux-container");
        container && container.style.display === "none" && (container.style.display = "block"), robuxButtonLink.textContent = "Hidden Catalog", robuxButtonLink.href = "/hidden-catalog", robuxButtonLink.target = "_self";
      }), window.location.pathname.endsWith("/hidden-catalog") && (removeHiddenCatalogContent(), removeHomeElement());
    });
  }
  __name(init5, "init");

  // src/content/features/games/serverlistener.js
  var isInitialized = !1, capturedServerData = {}, sentServerIds = /* @__PURE__ */ new Map(), ROBLOX_SERVER_URL_PATTERN = /^https:\/\/games\.roblox\.com\/v1\/games\/(\d+)\/servers\/Public/;
  async function sendToLocalAPI(placeId, serverIds) {
    if (!(!placeId || !serverIds || !serverIds.length))
      try {
        await callRobloxApi({
          isRovalraApi: !0,
          endpoint: "/process_servers",
          method: "POST",
          body: {
            place_id: placeId,
            server_ids: serverIds
          }
        });
      } catch (apiError) {
        console.error(apiError);
      }
  }
  __name(sendToLocalAPI, "sendToLocalAPI");
  function processServerData(placeId, responseData) {
    if (responseData && responseData.data && Array.isArray(responseData.data)) {
      sentServerIds.has(placeId) || sentServerIds.set(placeId, /* @__PURE__ */ new Set());
      let sentSet = sentServerIds.get(placeId), idsToSend = [];
      responseData.data.forEach((server) => {
        capturedServerData[server.id] = server, sentSet.has(server.id) || (sentSet.add(server.id), idsToSend.push(server.id));
      }), idsToSend.length > 0 && sendToLocalAPI(placeId, idsToSend);
    }
  }
  __name(processServerData, "processServerData");
  function init6() {
    isInitialized || chrome.storage.local.get({ ServerdataEnabled: !0 }, function(settings) {
      settings.ServerdataEnabled && (isInitialized = !0, document.addEventListener("rovalra-game-servers-response", (event) => {
        if (!event.detail) return;
        let { url, data } = event.detail, matches = url ? url.match(ROBLOX_SERVER_URL_PATTERN) : null;
        if (matches && matches[1]) {
          let placeId = matches[1];
          processServerData(placeId, data);
        }
      }), window.addEventListener("rovalra:getServerDataRequest", (event) => {
        if (event.detail && event.detail.gameId) {
          let gameId = event.detail.gameId, serverInfo = capturedServerData[gameId] || null;
          window.dispatchEvent(new CustomEvent("rovalra:getServerDataResponse", {
            detail: { gameId, serverInfo }
          }));
        }
      }));
    });
  }
  __name(init6, "init");

  // src/content/core/ui/tooltip.js
  var activeTooltipCleanup = null;
  function addTooltip(parent, text2, options = {}) {
    let { position = "bottom", container = document.body } = options, tooltipElement = null, isUpdateScheduled = !1, scrollListenerRef = null, showTooltip = /* @__PURE__ */ __name(() => {
      activeTooltipCleanup && activeTooltipCleanup(), tooltipElement = document.createElement("div"), tooltipElement.style.position = "absolute", tooltipElement.style.pointerEvents = "none", tooltipElement.className = "tooltip fade bottom in", tooltipElement.setAttribute("role", "tooltip");
      let arrow = document.createElement("div");
      arrow.className = "tooltip-arrow";
      let inner = document.createElement("div");
      inner.className = "tooltip-inner", inner.innerHTML = purify.sanitize(text2), tooltipElement.append(arrow, inner), container.appendChild(tooltipElement);
      let updatePosition = /* @__PURE__ */ __name(() => {
        if (!tooltipElement || !parent.isConnected) {
          hideTooltip();
          return;
        }
        let parentRect = parent.getBoundingClientRect(), tooltipWidth = tooltipElement.offsetWidth, tooltipHeight = tooltipElement.offsetHeight, arrowSize = 0, targetTop, targetLeft;
        switch (position) {
          case "top":
            targetTop = parentRect.top - tooltipHeight, targetLeft = parentRect.left + parentRect.width / 2 - tooltipWidth / 2;
            break;
          case "left":
            targetTop = parentRect.top + parentRect.height / 2 - tooltipHeight / 2, targetLeft = parentRect.left - tooltipWidth - arrowSize;
            break;
          case "right":
            targetTop = parentRect.top + parentRect.height / 2 - tooltipHeight / 2, targetLeft = parentRect.right + arrowSize;
            break;
          default:
            targetTop = parentRect.bottom + arrowSize, targetLeft = parentRect.left + parentRect.width / 2 - tooltipWidth / 2;
            break;
        }
        let finalLeft = Math.max(5, Math.min(targetLeft, window.innerWidth - tooltipWidth - 5)), finalTopAbs = Math.max(5, Math.min(targetTop, window.innerHeight - tooltipHeight - 5)) + window.scrollY, finalLeftAbs = finalLeft + window.scrollX;
        if (tooltipElement.style.top = `${finalTopAbs}px`, tooltipElement.style.left = `${finalLeftAbs}px`, position === "top" || position === "bottom") {
          let arrowLeft = parentRect.left + window.scrollX + parentRect.width / 2 - finalLeftAbs;
          arrow.style.top = "auto", arrow.style.left = `${arrowLeft}px`, position === "top" ? (arrow.style.transform = "translateY(-100%) rotate(180deg)", arrow.style.top = "100%") : arrow.style.transform = "none";
        } else if (position === "left" || position === "right") {
          let arrowTop = parentRect.top + window.scrollY + parentRect.height / 2 - finalTopAbs;
          arrow.style.left = "auto", arrow.style.top = `${arrowTop}px`, arrow.style.transform = `translateY(-50%) rotate(${position === "left" ? 90 : -90}deg)`;
        }
        isUpdateScheduled = !1;
      }, "updatePosition"), onScrollOrResize = /* @__PURE__ */ __name(() => {
        isUpdateScheduled || (isUpdateScheduled = !0, requestAnimationFrame(updatePosition));
      }, "onScrollOrResize");
      updatePosition(), scrollListenerRef = onScrollOrResize, window.addEventListener("scroll", onScrollOrResize, { passive: !0 }), window.addEventListener("resize", onScrollOrResize, { passive: !0 }), tooltipElement.style.display = "block", tooltipElement.style.opacity = "1", tooltipElement.style.visibility = "visible", activeTooltipCleanup = hideTooltip;
    }, "showTooltip"), hideTooltip = /* @__PURE__ */ __name(() => {
      tooltipElement && (tooltipElement.remove(), tooltipElement = null), scrollListenerRef && (window.removeEventListener("scroll", scrollListenerRef), window.removeEventListener("resize", scrollListenerRef), scrollListenerRef = null), activeTooltipCleanup === hideTooltip && (activeTooltipCleanup = null);
    }, "hideTooltip");
    parent.addEventListener("mouseenter", showTooltip), parent.addEventListener("mouseleave", hideTooltip), parent.addEventListener("click", hideTooltip);
  }
  __name(addTooltip, "addTooltip");

  // src/content/core/ui/navbarButton.js
  function createNavbarButton({ id, iconSvgData, tooltipText, onClick: onClick2 }) {
    return new Promise((resolve) => {
      let init54 = /* @__PURE__ */ __name(() => {
        observeElement(".nav.navbar-right.rbx-navbar-icon-group", (navbar) => {
          if (document.getElementById(id)) {
            resolve(document.getElementById(id).querySelector("button"));
            return;
          }
          let li = document.createElement("li");
          li.id = id, li.className = "navbar-icon-item";
          let button = document.createElement("button");
          button.type = "button", button.className = "btn-uiblox-common-common-notification-bell-md";
          let spanIcon = document.createElement("span");
          if (spanIcon.className = "rbx-menu-item", spanIcon.style.display = "flex", spanIcon.style.alignItems = "center", spanIcon.style.justifyContent = "center", iconSvgData)
            try {
              let svgData = iconSvgData.includes("<svg") ? iconSvgData : decodeURIComponent(iconSvgData.split(",")[1]);
              svgData = svgData.replace('fill="white"', 'fill="var(--rovalra-main-text-color)"'), spanIcon.innerHTML = svgData;
              let svg2 = spanIcon.querySelector("svg");
              svg2 && (svg2.setAttribute("width", "28"), svg2.setAttribute("height", "28"));
            } catch (e) {
              console.error("RoValra: Failed to parse navbar button icon", e), resolve(null);
              return;
            }
          button.appendChild(spanIcon), li.appendChild(button), tooltipText && addTooltip(button, tooltipText), onClick2 && button.addEventListener("click", () => onClick2(button));
          let searchIcon = navbar.querySelector(".rbx-navbar-right-search");
          searchIcon ? navbar.insertBefore(li, searchIcon.nextSibling) : navbar.insertBefore(li, navbar.firstChild), resolve(button);
        });
      }, "init");
      document.readyState === "complete" ? init54() : window.addEventListener("load", init54, { once: !0 });
    });
  }
  __name(createNavbarButton, "createNavbarButton");

  // src/content/core/ui/general/radio.js
  function createRadioButton({ id, checked = !1, onChange } = {}) {
    let button = document.createElement("button");
    button.type = "button", button.setAttribute("role", "checkbox"), id && (button.id = id), Object.assign(button.style, {
      background: "none",
      border: "none",
      padding: "0",
      cursor: "pointer",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "24px",
      height: "24px"
    });
    let icon = document.createElement("span"), setChecked = /* @__PURE__ */ __name((isChecked) => {
      button.setAttribute("aria-checked", String(isChecked)), icon.className = isChecked ? "icon-radio-check-circle-filled" : "icon-radio-check-circle";
    }, "setChecked");
    return button.addEventListener("click", (e) => {
      e.stopPropagation();
      let newState = button.getAttribute("aria-checked") !== "true";
      setChecked(newState), onChange && onChange(newState);
    }), button.appendChild(icon), setChecked(checked), button.setChecked = setChecked, button;
  }
  __name(createRadioButton, "createRadioButton");

  // src/content/core/ui/selects.js
  function createDropdownContent(triggerElement, items, initialValue, onValueChange, updateTriggerTextCallback, showFlags = !1) {
    let contentPanel = document.createElement("div");
    contentPanel.className = "rovalra-dropdown-content-panel foundation-web-menu bg-surface-100 stroke-standard stroke-default shadow-transient-high radius-large", contentPanel.setAttribute("role", "listbox"), contentPanel.style.minWidth = `${triggerElement.offsetWidth}px`;
    let dropdownContentInner = document.createElement("div");
    dropdownContentInner.className = "flex-dropdown-menu", contentPanel.appendChild(dropdownContentInner);
    let currentSelectedValue = initialValue, updateSelectedState = /* @__PURE__ */ __name((newValue) => {
      currentSelectedValue = newValue, contentPanel.querySelectorAll(".rovalra-dropdown-item").forEach((el2) => {
        let isSelected = el2.dataset.value === newValue;
        el2.setAttribute("data-selected", isSelected);
      });
    }, "updateSelectedState");
    if (items.some((item) => item.group)) {
      let grouped = {};
      items.forEach((item) => {
        let group = item.group || "Other";
        grouped[group] || (grouped[group] = []), grouped[group].push(item);
      }), ["North America", "South America", "Europe", "Asia", "Africa", "Oceania", "Other"].forEach((groupName) => {
        if (grouped[groupName]) {
          let headerEl = document.createElement("div");
          headerEl.className = "rovalra-dropdown-section-header", headerEl.textContent = groupName, dropdownContentInner.appendChild(headerEl), grouped[groupName].forEach((item) => {
            dropdownContentInner.appendChild(createDropdownItem(item));
          });
        }
      });
    } else
      items.forEach((item) => {
        dropdownContentInner.appendChild(createDropdownItem(item));
      });
    function createDropdownItem(item) {
      let itemEl = document.createElement("button");
      itemEl.className = "rovalra-dropdown-item relative clip group/interactable focus-visible:outline-focus disabled:outline-none foundation-web-menu-item flex items-center content-default text-truncate-split focus-visible:hover:outline-none cursor-pointer stroke-none bg-none text-align-x-left width-full text-body-medium padding-x-medium padding-y-small gap-x-medium radius-medium", itemEl.type = "button", itemEl.dataset.value = item.value, itemEl.setAttribute("role", "option"), itemEl.setAttribute("aria-selected", item.value === currentSelectedValue);
      let itemPresentationDiv = document.createElement("div");
      itemPresentationDiv.setAttribute("role", "presentation"), itemPresentationDiv.className = "absolute inset-[0] transition-colors group-hover/interactable:bg-[var(--color-state-hover)] group-active/interactable:bg-[var(--color-state-press)] group-disabled/interactable:bg-none";
      let countryCode = (/* @__PURE__ */ __name((regionCode) => regionCode === "AUTO" ? null : regionCode.split("-")[0].toLowerCase(), "getCountryCode"))(item.value), itemTextWrapper = document.createElement("div");
      if (itemTextWrapper.className = "grow-1 text-truncate-split flex flex-col gap-y-xsmall", itemTextWrapper.style.display = "flex", itemTextWrapper.style.flexDirection = "row", itemTextWrapper.style.alignItems = "center", itemTextWrapper.style.gap = "8px", showFlags && countryCode) {
        let flagImg = document.createElement("img");
        flagImg.src = `https://flagcdn.com/h20/${countryCode}.png`, flagImg.srcset = `https://flagcdn.com/h40/${countryCode}.png 2x`, flagImg.alt = `${countryCode} flag`, flagImg.style.width = "20px", flagImg.style.height = "15px", flagImg.style.objectFit = "cover", flagImg.style.borderRadius = "3px", flagImg.style.flexShrink = "0", itemTextWrapper.appendChild(flagImg);
      }
      let itemText = document.createElement("span");
      return itemText.className = "foundation-web-menu-item-title text-no-wrap text-truncate-split content-emphasis", itemText.textContent = item.label, itemText.style.flex = "1", itemTextWrapper.appendChild(itemText), itemEl.append(itemPresentationDiv, itemTextWrapper), itemEl.addEventListener("click", () => {
        updateSelectedState(item.value), updateTriggerTextCallback(item.value), onValueChange(item.value), toggleContentVisibility(!1);
      }), itemEl;
    }
    __name(createDropdownItem, "createDropdownItem");
    let positionContent = /* @__PURE__ */ __name(() => {
      let triggerRect = triggerElement.getBoundingClientRect();
      contentPanel.style.top = `${triggerRect.bottom + window.scrollY + 4}px`, contentPanel.style.left = `${triggerRect.left + window.scrollX}px`, contentPanel.style.minWidth = `${triggerRect.width}px`;
    }, "positionContent"), toggleContentVisibility = /* @__PURE__ */ __name((forceOpen) => {
      let isOpen = forceOpen ?? contentPanel.getAttribute("data-state") !== "open";
      contentPanel.setAttribute("data-state", isOpen ? "open" : "closed"), triggerElement.setAttribute("aria-expanded", String(isOpen)), isOpen ? (document.body.appendChild(contentPanel), positionContent(), window.addEventListener("scroll", positionContent, { passive: !0 }), window.addEventListener("resize", positionContent, { passive: !0 })) : (contentPanel.parentNode === document.body && document.body.removeChild(contentPanel), window.removeEventListener("scroll", positionContent), window.removeEventListener("resize", positionContent));
    }, "toggleContentVisibility");
    return updateSelectedState(initialValue), {
      element: contentPanel,
      toggleVisibility: toggleContentVisibility,
      updateSelectedState
    };
  }
  __name(createDropdownContent, "createDropdownContent");

  // src/content/core/ui/dropdown.js
  var isCssInjected = !1;
  function injectDropdownCss() {
    if (isCssInjected) return;
    isCssInjected = !0;
    let style = document.createElement("style");
    style.id = "rovalra-global-dropdown-style", style.textContent = `
        .rovalra-dropdown-container {
            position: relative;
            display: inline-block;
            vertical-align: middle; 
            margin: 0; 
        }
        .rovalra-dropdown-trigger .rovalra-dropdown-chevron {
            transition: transform 0.2s ease !important;
        }
        .rovalra-dropdown-trigger[data-state="open"] .rovalra-dropdown-chevron {
            transform: rotate(180deg);
        }
        .rovalra-dropdown-panel {
            cursor: default;
        }
    `, document.head.appendChild(style);
  }
  __name(injectDropdownCss, "injectDropdownCss");
  function createDropdown({ items = [], initialValue, placeholder = "Select...", onValueChange, showFlags = !1 }) {
    injectDropdownCss();
    let container = document.createElement("div");
    container.className = "rovalra-dropdown-container";
    let trigger = document.createElement("button");
    trigger.className = "rovalra-dropdown-trigger relative clip group/interactable focus-visible:outline-focus disabled:outline-none flex items-center justify-between width-full bg-none stroke-standard radius-medium height-1000 padding-x-medium text-body-medium stroke-default content-default", trigger.type = "button", trigger.setAttribute("role", "combobox"), trigger.setAttribute("aria-haspopup", "listbox"), trigger.style.minHeight = "38px";
    let triggerPresentationDiv = document.createElement("div");
    triggerPresentationDiv.setAttribute("role", "presentation"), triggerPresentationDiv.className = "absolute inset-[0] transition-colors group-hover/interactable:bg-[var(--color-state-hover)] group-active/interactable:bg-[var(--color-state-press)] group-disabled/interactable:bg-none";
    let textWrapper = document.createElement("div");
    textWrapper.className = "grow-1 text-truncate-split text-align-x-left";
    let triggerValueSpan = document.createElement("span");
    triggerValueSpan.className = "text-no-wrap text-truncate-split content-emphasis", triggerValueSpan.style.pointerEvents = "none", textWrapper.innerHTML = '<span style="pointer-events: none;"></span>', textWrapper.firstElementChild.appendChild(triggerValueSpan);
    let chevron = document.createElement("span");
    if (chevron.setAttribute("aria-hidden", "true"), chevron.className = "rovalra-dropdown-chevron size-500 icon icon-regular-chevron-large-down content-default", items && items.length > 0) {
      let widestItem = items.reduce((prev, current) => current.label.length > prev.label.length ? current : prev, { label: "" });
      triggerValueSpan.textContent = widestItem.label || placeholder, Object.assign(trigger.style, { visibility: "hidden", position: "absolute" }), container.appendChild(trigger), document.body.appendChild(container);
      let widestWidth = trigger.scrollWidth + 16;
      trigger.style.minWidth = `${widestWidth}px`, document.body.removeChild(container), Object.assign(trigger.style, { visibility: "", position: "" });
    } else
      triggerValueSpan.textContent = placeholder;
    trigger.append(triggerPresentationDiv, textWrapper, chevron);
    let updateTriggerText = /* @__PURE__ */ __name((value) => {
      let selectedItem = items ? items.find((item) => item.value === value) : null;
      for (; triggerValueSpan.firstChild; )
        triggerValueSpan.removeChild(triggerValueSpan.firstChild);
      if (selectedItem) {
        if (showFlags) {
          let countryCode = (/* @__PURE__ */ __name((regionCode) => regionCode === "AUTO" ? null : regionCode.split("-")[0].toLowerCase(), "getCountryCode"))(selectedItem.value);
          if (countryCode) {
            let flagImg = document.createElement("img");
            flagImg.src = `https://flagcdn.com/h20/${countryCode}.png`, flagImg.srcset = `https://flagcdn.com/h40/${countryCode}.png 2x`, flagImg.alt = `${countryCode} flag`, flagImg.style.width = "20px", flagImg.style.height = "15px", flagImg.style.objectFit = "cover", flagImg.style.borderRadius = "3px", flagImg.style.marginRight = "8px", flagImg.style.flexShrink = "0", flagImg.style.verticalAlign = "middle", triggerValueSpan.appendChild(flagImg);
          }
        }
        let textNode = document.createTextNode(selectedItem.label);
        triggerValueSpan.appendChild(textNode), trigger.removeAttribute("data-placeholder");
      } else
        triggerValueSpan.textContent = placeholder, trigger.setAttribute("data-placeholder", "true");
    }, "updateTriggerText"), handleValueChange = /* @__PURE__ */ __name((value) => {
      onValueChange && onValueChange(value), trigger.setAttribute("data-state", "closed"), trigger.setAttribute("aria-expanded", "false");
    }, "handleValueChange"), { element: contentPanel, toggleVisibility: toggleContentVisibility, updateSelectedState: updateContentSelectedState } = createDropdownContent(
      trigger,
      items || [],
      initialValue,
      handleValueChange,
      updateTriggerText,
      showFlags
    ), toggleDropdown = /* @__PURE__ */ __name((forceOpen) => {
      let isOpen = forceOpen ?? contentPanel.getAttribute("data-state") !== "open";
      toggleContentVisibility(isOpen), trigger.setAttribute("data-state", isOpen ? "open" : "closed"), trigger.setAttribute("aria-expanded", String(isOpen)), isOpen && requestAnimationFrame(() => {
        let rect = contentPanel.getBoundingClientRect(), viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        if (rect.right > viewportWidth) {
          let currentLeft = parseFloat(contentPanel.style.left);
          isNaN(currentLeft) || (contentPanel.style.left = `${currentLeft - (rect.right - viewportWidth) - 20}px`);
        }
      });
    }, "toggleDropdown");
    return trigger.addEventListener("click", (e) => {
      e.stopPropagation(), toggleDropdown();
    }), contentPanel.addEventListener("click", (e) => {
      e.stopPropagation();
    }), document.addEventListener("click", (e) => {
      contentPanel.contains(e.target) || !container.contains(e.target) && contentPanel.getAttribute("data-state") === "open" && toggleDropdown(!1);
    }), initialValue && updateTriggerText(initialValue), container.append(trigger), {
      element: container,
      panel: contentPanel,
      trigger,
      setValue: /* @__PURE__ */ __name((value) => {
        updateTriggerText(value), updateContentSelectedState(value);
        let parentWrapper = container.parentElement;
        if (parentWrapper) {
          let hiddenSelect = parentWrapper.querySelector('select[style*="display: none"]');
          hiddenSelect && (hiddenSelect.value = value, hiddenSelect.dispatchEvent(new Event("change", { bubbles: !0 })));
        }
      }, "setValue")
    };
  }
  __name(createDropdown, "createDropdown");
  function createDropdownMenu({ trigger, items, onValueChange, position }) {
    injectDropdownCss();
    let updateTriggerText = /* @__PURE__ */ __name(() => {
    }, "updateTriggerText"), handleValueChange = /* @__PURE__ */ __name((value) => {
      onValueChange && onValueChange(value), trigger.setAttribute("data-state", "closed"), trigger.setAttribute("aria-expanded", "false");
    }, "handleValueChange"), { element: contentPanel, toggleVisibility } = createDropdownContent(
      trigger,
      items,
      null,
      handleValueChange,
      updateTriggerText,
      !1
    ), toggle = /* @__PURE__ */ __name((forceOpen) => {
      let isOpen = forceOpen ?? contentPanel.getAttribute("data-state") !== "open";
      if (toggleVisibility(isOpen), trigger.setAttribute("data-state", isOpen ? "open" : "closed"), trigger.setAttribute("aria-expanded", String(isOpen)), isOpen && (contentPanel.style.minWidth = "200px", position !== "center")) {
        let rect = trigger.getBoundingClientRect();
        rect.left + 200 > window.innerWidth && (contentPanel.style.left = `${rect.right - 200 + window.scrollX}px`);
      }
    }, "toggle");
    return trigger.addEventListener("click", (e) => {
      e.stopPropagation(), toggle();
    }), contentPanel.addEventListener("click", (e) => {
      e.stopPropagation();
    }), document.addEventListener("click", (e) => {
      contentPanel.contains(e.target) || !trigger.contains(e.target) && contentPanel.getAttribute("data-state") === "open" && toggle(!1);
    }), { panel: contentPanel, toggle };
  }
  __name(createDropdownMenu, "createDropdownMenu");

  // src/content/features/navigation/betaprograms.js
  async function optInBeta(programId) {
    return callRobloxApi({
      subdomain: "apis",
      endpoint: "/test-pilot-api/v1/opt-in",
      method: "POST",
      body: { programId }
    });
  }
  __name(optInBeta, "optInBeta");
  async function optOutBeta() {
    return callRobloxApi({
      subdomain: "apis",
      endpoint: "/test-pilot-api/v1/opt-in",
      method: "POST",
      body: { programId: "" }
    });
  }
  __name(optOutBeta, "optOutBeta");
  var cachedBetaPrograms = null;
  async function addNavbarButton() {
    if (document.getElementById("rovalra-beta-programs-toggle")) return;
    let icon = getAssets().TerminalIcon, button = await createNavbarButton({
      id: "rovalra-beta-programs-toggle",
      iconSvgData: icon,
      tooltipText: "Toggle Beta Programs"
    });
    if (!button) return;
    let menu = null, isLoading = !1;
    button.addEventListener("click", async (e) => {
      if (menu && e.stopImmediatePropagation(), isLoading) return;
      if (menu && menu.panel.getAttribute("data-state") === "open") {
        menu.toggle(!1);
        return;
      }
      isLoading = !0;
      let originalIcon = button.innerHTML;
      button.innerHTML = "", button.appendChild(createSpinner({ size: "28px" }));
      try {
        let programsDataPromise;
        cachedBetaPrograms ? programsDataPromise = Promise.resolve(cachedBetaPrograms) : programsDataPromise = callRobloxApiJson({ subdomain: "apis", endpoint: "/test-pilot-api/v1/beta-programs" }).then((data) => (cachedBetaPrograms = data, data));
        let [programsData, optInData] = await Promise.all([
          programsDataPromise,
          callRobloxApiJson({ subdomain: "apis", endpoint: "/test-pilot-api/v1/opt-in" })
        ]), betaPrograms = programsData.betaPrograms || [], currentOptInId = optInData.optIn?.programId, menuItems = betaPrograms.map((program) => ({
          label: program.displayName,
          value: program.id,
          description: program.description,
          checked: program.id === currentOptInId
        }));
        if (!menu) {
          menu = createDropdownMenu({
            trigger: button,
            items: [],
            onValueChange: /* @__PURE__ */ __name(() => {
            }, "onValueChange"),
            position: "center"
          }), menu.panel.style.transform = "translateX(-50%)", menu.panel.style.setProperty("min-width", "300px", "important"), menu.panel.style.maxHeight = "400px", menu.panel.style.overflowY = "auto";
          let updatePosition = /* @__PURE__ */ __name(() => {
            button.offsetWidth > 0 && (menu.panel.style.marginLeft = `${button.offsetWidth / 2}px`);
          }, "updatePosition");
          button.addEventListener("click", updatePosition), updatePosition();
        }
        if (menu.panel.innerHTML = "", menuItems.length === 0) {
          let noProgramsEl = document.createElement("div");
          noProgramsEl.className = "rovalra-dropdown-item", noProgramsEl.textContent = "You are not enrolled into any beta programs.", noProgramsEl.style.textAlign = "center", noProgramsEl.style.padding = "10px", menu.panel.appendChild(noProgramsEl);
        } else {
          let currentCheckedRadio = null, radios = [];
          menuItems.forEach((item) => {
            let itemEl = document.createElement("div");
            itemEl.className = "rovalra-dropdown-item flex items-center justify-between p-2", itemEl.style.padding = "8px 12px", itemEl.style.cursor = "pointer";
            let textContainer = document.createElement("div");
            textContainer.className = "flex flex-col", textContainer.style.marginRight = "10px";
            let label = document.createElement("span");
            if (label.className = "text-body-emphasis", label.textContent = item.label, textContainer.appendChild(label), item.description) {
              let desc = document.createElement("span");
              desc.className = "text-caption-subtle", desc.textContent = item.description, textContainer.appendChild(desc);
            }
            let handleRadioChange = /* @__PURE__ */ __name(async (newState) => {
              newState ? (radios.forEach((r) => {
                r !== radio && r.setChecked(!1);
              }), currentCheckedRadio = radio, await optInBeta(item.value)) : currentCheckedRadio === radio && (currentCheckedRadio = null, await optOutBeta());
            }, "handleRadioChange"), radio = createRadioButton({
              checked: item.checked,
              onChange: handleRadioChange
            });
            radios.push(radio), item.checked && (currentCheckedRadio = radio), itemEl.addEventListener("click", (e2) => {
              if (radio.contains(e2.target)) return;
              let currentChecked = radio.getAttribute("aria-checked") === "true";
              radio.setChecked(!currentChecked), handleRadioChange(!currentChecked);
            }), itemEl.appendChild(textContainer), itemEl.appendChild(radio), menu.panel.appendChild(itemEl);
          });
        }
        menu.toggle(!0);
      } catch (error) {
        console.error("RoValra: Failed to fetch beta programs", error), menu && menu.toggle(!1);
      } finally {
        isLoading = !1, button.innerHTML = originalIcon;
      }
    });
  }
  __name(addNavbarButton, "addNavbarButton");
  function init7() {
    chrome.storage.local.get(
      { betaProgramsEnabled: !0 },
      (settings) => {
        settings.betaProgramsEnabled && addNavbarButton();
      }
    );
  }
  __name(init7, "init");

  // src/content/core/utils/videoStreamer.js
  var MIME_TYPE = 'video/webm; codecs="vp9,opus"', BUFFER_AHEAD_SECONDS = 30;
  function streamRobloxVideo(requestJson, videoElement, onProgress = () => {
  }) {
    return new Promise((resolve, reject) => {
      if (!requestJson || !Array.isArray(requestJson) || !requestJson[0]?.location)
        return reject(new Error("Invalid video data: Asset is likely not a video."));
      let mediaSource = new MediaSource(), objectUrl = URL.createObjectURL(mediaSource);
      videoElement.src = objectUrl;
      let cleanup = /* @__PURE__ */ __name(() => {
        videoElement.src === objectUrl && URL.revokeObjectURL(objectUrl);
      }, "cleanup"), isClosed = /* @__PURE__ */ __name(() => mediaSource.readyState !== "open", "isClosed");
      mediaSource.addEventListener("sourceopen", async () => {
        if (URL.revokeObjectURL(objectUrl), !MediaSource.isTypeSupported(MIME_TYPE)) {
          reject(new Error(`Browser does not support ${MIME_TYPE}`));
          return;
        }
        let sourceBuffer;
        try {
          sourceBuffer = mediaSource.addSourceBuffer(MIME_TYPE), sourceBuffer.mode = "sequence";
        } catch {
          return;
        }
        let fullFileChunks = [];
        try {
          let masterUrl = requestJson[0].location;
          onProgress("Fetching master playlist...");
          let masterText = await fetchText(masterUrl);
          if (isClosed()) return;
          let streamUrl = getBestStreamUrl(masterText, masterUrl);
          if (!streamUrl) throw new Error("Could not determine stream URL");
          onProgress("Fetching segment list...");
          let segmentText = await fetchText(streamUrl);
          if (isClosed()) return;
          let baseUrl = streamUrl.substring(0, streamUrl.lastIndexOf("/") + 1), { initUrl, segments } = parseSegmentUrls(segmentText, baseUrl);
          if (segments.length === 0) throw new Error("No video segments found");
          if (initUrl) {
            onProgress("Initializing...");
            let initChunk = await fetchBuffer(initUrl);
            if (isClosed()) return;
            fullFileChunks.push(initChunk), await appendChunk(sourceBuffer, initChunk);
          }
          let currentSegment = 0;
          for (; currentSegment < segments.length && !isClosed(); ) {
            if (shouldPauseBuffering(videoElement)) {
              await new Promise((r) => setTimeout(r, 1e3));
              continue;
            }
            onProgress(`Buffering ${currentSegment + 1}/${segments.length}`);
            let chunk = null, attempts = 0;
            for (; !chunk && attempts < 3 && !isClosed(); )
              try {
                chunk = await fetchBuffer(segments[currentSegment]);
              } catch {
                attempts++, console.warn(`Retry ${attempts}/3 for segment ${currentSegment}`), await new Promise((r) => setTimeout(r, 1e3));
              }
            if (!chunk && !isClosed())
              throw new Error(`Failed to load segment ${currentSegment}`);
            if (isClosed()) break;
            fullFileChunks.push(chunk), await appendChunk(sourceBuffer, chunk), currentSegment++;
          }
          isClosed() || (mediaSource.endOfStream(), onProgress("Complete"), resolve(new Blob(fullFileChunks, { type: "video/webm" })));
        } catch (err) {
          console.error("Streamer Error:", err), isClosed() || mediaSource.endOfStream("network"), cleanup(), reject(err);
        }
      });
    });
  }
  __name(streamRobloxVideo, "streamRobloxVideo");
  function shouldPauseBuffering(video) {
    if (video.error) return !1;
    if (video.paused && video.buffered.length > 0 && video.buffered.end(video.buffered.length - 1) > video.currentTime + 10)
      return !0;
    for (let i = 0; i < video.buffered.length; i++) {
      let start = video.buffered.start(i), end = video.buffered.end(i);
      if (video.currentTime >= start && video.currentTime <= end)
        return end - video.currentTime > BUFFER_AHEAD_SECONDS;
    }
    return !1;
  }
  __name(shouldPauseBuffering, "shouldPauseBuffering");
  async function fetchText(url) {
    let resp = await callRobloxApi({ fullUrl: url, credentials: "omit" });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return await resp.text();
  }
  __name(fetchText, "fetchText");
  async function fetchBuffer(url) {
    let resp = await callRobloxApi({ fullUrl: url, credentials: "omit" });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return await resp.arrayBuffer();
  }
  __name(fetchBuffer, "fetchBuffer");
  function appendChunk(sourceBuffer, data) {
    return new Promise((resolve, reject) => {
      if (sourceBuffer.updating)
        return reject(new Error("Buffer is busy"));
      let onUpdateEnd = /* @__PURE__ */ __name(() => {
        cleanup(), resolve();
      }, "onUpdateEnd"), onError = /* @__PURE__ */ __name((e) => {
        cleanup(), reject(new Error("SourceBuffer append error"));
      }, "onError"), cleanup = /* @__PURE__ */ __name(() => {
        sourceBuffer.removeEventListener("updateend", onUpdateEnd), sourceBuffer.removeEventListener("error", onError);
      }, "cleanup");
      sourceBuffer.addEventListener("updateend", onUpdateEnd), sourceBuffer.addEventListener("error", onError);
      try {
        sourceBuffer.appendBuffer(data);
      } catch (e) {
        cleanup(), e.name !== "InvalidStateError" && reject(e);
      }
    });
  }
  __name(appendChunk, "appendChunk");
  function getBestStreamUrl(m3u8Content, masterUrl) {
    let baseUriMatch = m3u8Content.match(/NAME="RBX-BASE-URI",\s*VALUE="(.*?)"/), rbxBaseUri = baseUriMatch ? baseUriMatch[1] : "", lines = m3u8Content.split(/\r?\n/), bestBandwidth = -1, bestPath = null, pendingBandwidth = null;
    for (let line of lines)
      if (line = line.trim(), !!line)
        if (line.startsWith("#EXT-X-STREAM-INF")) {
          let bwMatch = line.match(/BANDWIDTH=(\d+)/);
          bwMatch && (pendingBandwidth = parseInt(bwMatch[1], 10));
        } else line.startsWith("#") || pendingBandwidth !== null && (pendingBandwidth > bestBandwidth && (bestBandwidth = pendingBandwidth, bestPath = line), pendingBandwidth = null);
    return bestPath ? (bestPath.includes("{$RBX-BASE-URI}") && (bestPath = bestPath.replace("{$RBX-BASE-URI}", rbxBaseUri)), bestPath.startsWith("http") ? bestPath : masterUrl.substring(0, masterUrl.lastIndexOf("/") + 1) + bestPath) : null;
  }
  __name(getBestStreamUrl, "getBestStreamUrl");
  function parseSegmentUrls(m3u8Content, baseUrl) {
    let lines = m3u8Content.split(/\r?\n/), segments = [], initUrl = null;
    for (let line of lines) {
      let clean = line.trim();
      if (clean)
        if (clean.startsWith("#EXT-X-MAP:URI=")) {
          let uri = clean.substring(15);
          uri.startsWith('"') && uri.endsWith('"') && (uri = uri.slice(1, -1)), initUrl = uri.startsWith("http") ? uri : baseUrl + uri;
        } else !clean.startsWith("#") && !clean.startsWith("<") && segments.push(clean.startsWith("http") ? clean : baseUrl + clean);
    }
    return { initUrl, segments };
  }
  __name(parseSegmentUrls, "parseSegmentUrls");

  // src/content/features/developer/videotest.js
  var VIDEO_ASSETS = [
    { id: 126397822635206, name: "Original Test" },
    { id: 80354346308494, name: "Video 2" },
    { id: 85723716754877, name: "Video 3" },
    { id: 90460839026431, name: "Video 4" },
    { id: 124530269490618, name: "Video 5" }
  ];
  function waitForBody() {
    return new Promise((resolve) => {
      if (document.body) return resolve();
      let observer = new MutationObserver(() => {
        document.body && (observer.disconnect(), resolve());
      });
      observer.observe(document.documentElement, { childList: !0 });
    });
  }
  __name(waitForBody, "waitForBody");
  async function loadVideo(assetId, videoElement, statusText, downloadBtn) {
    statusText.innerText = "Requesting Asset Data...", statusText.style.color = "var(--rovalra-secondary-text-color)", downloadBtn.style.display = "none", downloadBtn.onclick = null, videoElement.pause(), videoElement.removeAttribute("src"), videoElement.load();
    try {
      let fetchAssetData = /* @__PURE__ */ __name(async (assetType) => await callRobloxApiJson({
        subdomain: "assetdelivery",
        endpoint: "/v1/assets/batch",
        method: "POST",
        body: [{
          assetId,
          assetType,
          requestId: "0"
        }]
      }), "fetchAssetData"), data = await fetchAssetData("Video");
      if (data && data.length > 0 && data[0].errors && (console.warn(`[RoValra] Asset ${assetId} failed as 'Video'. Errors:`, data[0].errors), statusText.innerText = "Retrying as GamePreviewVideo...", data = await fetchAssetData("GamePreviewVideo"), data && data.length > 0 && data[0].errors)) {
        let errInfo = data[0].errors[0];
        throw new Error(`API Error ${errInfo.code}: ${errInfo.message}`);
      }
      let videoBlob = await streamRobloxVideo(data, videoElement, (status) => {
        videoElement.paused && videoElement.currentTime === 0 ? statusText.innerText = status : statusText.innerText = "Streaming...";
      });
      downloadBtn.style.display = "inline-block", downloadBtn.onclick = () => {
        let url = URL.createObjectURL(videoBlob), a = document.createElement("a");
        a.href = url, a.download = `roblox-video-${assetId}.webm`, document.body.appendChild(a), a.click(), document.body.removeChild(a), URL.revokeObjectURL(url);
      };
    } catch (err) {
      console.error(err), statusText.innerText = "Error: " + err.message, statusText.style.color = "#ff5555";
    }
  }
  __name(loadVideo, "loadVideo");
  async function init8() {
    if (window.location.pathname.toLowerCase() !== "/videotest" || !await new Promise((resolve) => {
      typeof chrome < "u" && chrome.storage && chrome.storage.local ? chrome.storage.local.get(["EnableVideoTest"], (result) => {
        resolve(result && result.EnableVideoTest === !0);
      }) : (console.warn("[RoValra] Chrome Storage API not found."), resolve(!1));
    }))
      return;
    await waitForBody(), document.documentElement.style.height = "100%", document.body.style.height = "100%", document.body.style.margin = "0", document.body.style.backgroundColor = "var(--rovalra-container-background-color)", document.body.style.color = "var(--rovalra-secondary-text-color)", document.body.style.display = "flex", document.body.style.flexDirection = "column", document.body.style.alignItems = "center", document.body.style.justifyContent = "center";
    let optionsHtml = VIDEO_ASSETS.map(
      (v2) => `<option value="${v2.id}">${v2.id} - ${v2.name}</option>`
    ).join("");
    document.body.innerHTML = `
        <div style="text-align:center;">
            <h1>RoValra Video Test</h1>
            
            <div style="margin-bottom: 20px; display: flex; align-items: center; justify-content: center; gap: 10px;">
                <label for="video-selector" style="font-weight: bold;">Select Asset:</label>
                <select id="video-selector" style="padding: 8px; border-radius: 4px; border: 1px solid #555; background: #222; color: #fff; font-family: monospace;">
                    ${optionsHtml}
                </select>
                <button id="reload-btn" style="padding: 8px 12px; cursor: pointer; border-radius: 4px; border: none; background: #0084dd; color: white;">Reload</button>
            </div>

            <p id="status-text">Ready</p>
            
            <video id="rovalra-player" controls autoplay style="width: 80vw; max-width: 1000px; box-shadow: 0 0 20px #000; border-radius: 8px; background: #000;"></video>
            
            <br/>
            <button id="dl-btn" style="margin-top:20px; padding:10px 20px; cursor:pointer; display:none;">Save Full MP4</button>
        </div>
    `;
    let statusText = document.getElementById("status-text"), videoElement = document.getElementById("rovalra-player"), downloadBtn = document.getElementById("dl-btn"), selector = document.getElementById("video-selector"), reloadBtn = document.getElementById("reload-btn"), triggerLoad = /* @__PURE__ */ __name(() => {
      let assetId = parseInt(selector.value, 10);
      loadVideo(assetId, videoElement, statusText, downloadBtn);
    }, "triggerLoad");
    selector.addEventListener("change", triggerLoad), reloadBtn.addEventListener("click", triggerLoad), triggerLoad();
  }
  __name(init8, "init");

  // src/content/features/sitewide/streamermode.js
  function init9() {
    let isHideRobuxEnabled = !1, isSettingsPageInfoEnabled = !1;
    function updateRobuxText(element) {
      isHideRobuxEnabled && element.textContent !== "Hidden" && (element.textContent = "Hidden");
    }
    __name(updateRobuxText, "updateRobuxText");
    function updateSettingsPage() {
      if (!isSettingsPageInfoEnabled || !window.location.href.includes("/my/account")) return;
      let phoneField = document.getElementById("account-field-phone");
      if (phoneField) {
        let phoneValueSpan = phoneField.querySelector(
          ".settings-text-span-visible"
        );
        phoneValueSpan && phoneValueSpan.textContent !== "RoValra Streamer Mode Enabled" && (phoneValueSpan.textContent = "RoValra Streamer Mode Enabled");
        let emailField = phoneField.nextElementSibling;
        if (emailField && emailField.classList.contains("settings-text-field-container")) {
          let emailValueSpan = emailField.querySelector(
            ".settings-text-span-visible"
          );
          emailValueSpan && emailValueSpan.textContent !== "RoValra Streamer Mode Enabled" && (emailValueSpan.textContent = "RoValra Streamer Mode Enabled");
        }
      }
    }
    __name(updateSettingsPage, "updateSettingsPage");
    function updateStreamerMode() {
      chrome.storage.local.get(
        ["streamermode", "settingsPageInfo", "hideRobux"],
        (data) => {
          try {
            data.streamermode ? (sessionStorage.setItem("rovalra_streamermode", "true"), sessionStorage.setItem(
              "rovalra_settingsPageInfo",
              data.settingsPageInfo !== !1 ? "true" : "false"
            ), sessionStorage.setItem(
              "rovalra_hideRobux",
              data.hideRobux === !0 ? "true" : "false"
            )) : sessionStorage.removeItem("rovalra_streamermode");
          } catch {
          }
          isHideRobuxEnabled = data.streamermode && data.hideRobux === !0, isSettingsPageInfoEnabled = data.streamermode && data.settingsPageInfo !== !1, document.querySelectorAll(
            "#nav-robux-amount, #nav-robux-balance"
          ).forEach(updateRobuxText), updateSettingsPage(), document.dispatchEvent(
            new CustomEvent("rovalra-streamer-mode", {
              detail: {
                enabled: data.streamermode,
                settingsPageInfo: data.settingsPageInfo !== !1,
                hideRobux: data.hideRobux === !0
              }
            })
          );
        }
      );
    }
    __name(updateStreamerMode, "updateStreamerMode"), updateStreamerMode(), chrome.storage.onChanged.addListener((changes, namespace) => {
      namespace === "local" && (changes.streamermode || changes.settingsPageInfo || changes.hideRobux) && updateStreamerMode();
    }), observeElement(
      "#nav-robux-amount, #nav-robux-balance",
      (element) => {
        updateRobuxText(element);
      },
      { multiple: !0 }
    ), observeElement("#account-field-phone", () => {
      updateSettingsPage();
    });
  }
  __name(init9, "init");

  // node_modules/marked/lib/marked.esm.js
  function M() {
    return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null };
  }
  __name(M, "M");
  var T = M();
  function H(u3) {
    T = u3;
  }
  __name(H, "H");
  var _ = { exec: /* @__PURE__ */ __name(() => null, "exec") };
  function k(u3, e = "") {
    let t = typeof u3 == "string" ? u3 : u3.source, n = { replace: /* @__PURE__ */ __name((r, i) => {
      let s = typeof i == "string" ? i : i.source;
      return s = s.replace(m.caret, "$1"), t = t.replace(r, s), n;
    }, "replace"), getRegex: /* @__PURE__ */ __name(() => new RegExp(t, e), "getRegex") };
    return n;
  }
  __name(k, "k");
  var Re = (() => {
    try {
      return !!new RegExp("(?<=1)(?<!1)");
    } catch {
      return !1;
    }
  })(), m = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] +\S/, listReplaceTask: /^\[[ xX]\] +/, listTaskCheckbox: /\[[ xX]\]/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: /* @__PURE__ */ __name((u3) => new RegExp(`^( {0,3}${u3})((?:[	 ][^\\n]*)?(?:\\n|$))`), "listItemRegex"), nextBulletRegex: /* @__PURE__ */ __name((u3) => new RegExp(`^ {0,${Math.min(3, u3 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), "nextBulletRegex"), hrRegex: /* @__PURE__ */ __name((u3) => new RegExp(`^ {0,${Math.min(3, u3 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), "hrRegex"), fencesBeginRegex: /* @__PURE__ */ __name((u3) => new RegExp(`^ {0,${Math.min(3, u3 - 1)}}(?:\`\`\`|~~~)`), "fencesBeginRegex"), headingBeginRegex: /* @__PURE__ */ __name((u3) => new RegExp(`^ {0,${Math.min(3, u3 - 1)}}#`), "headingBeginRegex"), htmlBeginRegex: /* @__PURE__ */ __name((u3) => new RegExp(`^ {0,${Math.min(3, u3 - 1)}}<(?:[a-z].*>|!--)`, "i"), "htmlBeginRegex"), blockquoteBeginRegex: /* @__PURE__ */ __name((u3) => new RegExp(`^ {0,${Math.min(3, u3 - 1)}}>`), "blockquoteBeginRegex") }, Te = /^(?:[ \t]*(?:\n|$))+/, Oe = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, we = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, I = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, ye = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, N = / {0,3}(?:[*+-]|\d{1,9}[.)])/, re = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, se = k(re).replace(/bull/g, N).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Pe = k(re).replace(/bull/g, N).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), Q = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Se = /^[^\n]+/, F = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, $e = k(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", F).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), _e = k(/^(bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, N).getRegex(), q = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", j = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Le = k("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", j).replace("tag", q).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), ie = k(Q).replace("hr", I).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", q).getRegex(), Me = k(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", ie).getRegex(), U = { blockquote: Me, code: Oe, def: $e, fences: we, heading: ye, hr: I, html: Le, lheading: se, list: _e, newline: Te, paragraph: ie, table: _, text: Se }, te = k("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", I).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", q).getRegex(), ze = { ...U, lheading: Pe, table: te, paragraph: k(Q).replace("hr", I).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", te).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)])[ \\t]").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", q).getRegex() }, Ce = { ...U, html: k(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", j).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: _, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: k(Q).replace("hr", I).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", se).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, Ae = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, Ie = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, oe = /^( {2,}|\\)\n(?!\s*$)/, Ee = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, v = /[\p{P}\p{S}]/u, K = /[\s\p{P}\p{S}]/u, ae = /[^\s\p{P}\p{S}]/u, Be = k(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, K).getRegex(), le = /(?!~)[\p{P}\p{S}]/u, De = /(?!~)[\s\p{P}\p{S}]/u, qe = /(?:[^\s\p{P}\p{S}]|~)/u, ue = /(?![*_])[\p{P}\p{S}]/u, ve = /(?![*_])[\s\p{P}\p{S}]/u, Ge = /(?:[^\s\p{P}\p{S}]|[*_])/u, He = k(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", Re ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex(), pe = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, Ze = k(pe, "u").replace(/punct/g, v).getRegex(), Ne = k(pe, "u").replace(/punct/g, le).getRegex(), ce = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", Qe = k(ce, "gu").replace(/notPunctSpace/g, ae).replace(/punctSpace/g, K).replace(/punct/g, v).getRegex(), Fe = k(ce, "gu").replace(/notPunctSpace/g, qe).replace(/punctSpace/g, De).replace(/punct/g, le).getRegex(), je = k("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, ae).replace(/punctSpace/g, K).replace(/punct/g, v).getRegex(), Ue = k(/^~~?(?:((?!~)punct)|[^\s~])/, "u").replace(/punct/g, ue).getRegex(), Ke = "^[^~]+(?=[^~])|(?!~)punct(~~?)(?=[\\s]|$)|notPunctSpace(~~?)(?!~)(?=punctSpace|$)|(?!~)punctSpace(~~?)(?=notPunctSpace)|[\\s](~~?)(?!~)(?=punct)|(?!~)punct(~~?)(?!~)(?=punct)|notPunctSpace(~~?)(?=notPunctSpace)", We = k(Ke, "gu").replace(/notPunctSpace/g, Ge).replace(/punctSpace/g, ve).replace(/punct/g, ue).getRegex(), Xe = k(/\\(punct)/, "gu").replace(/punct/g, v).getRegex(), Je = k(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Ve = k(j).replace("(?:-->|$)", "-->").getRegex(), Ye = k("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Ve).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), D = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/, et = k(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", D).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), he = k(/^!?\[(label)\]\[(ref)\]/).replace("label", D).replace("ref", F).getRegex(), ke = k(/^!?\[(ref)\](?:\[\])?/).replace("ref", F).getRegex(), tt = k("reflink|nolink(?!\\()", "g").replace("reflink", he).replace("nolink", ke).getRegex(), ne = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/, W = { _backpedal: _, anyPunctuation: Xe, autolink: Je, blockSkip: He, br: oe, code: Ie, del: _, delLDelim: _, delRDelim: _, emStrongLDelim: Ze, emStrongRDelimAst: Qe, emStrongRDelimUnd: je, escape: Ae, link: et, nolink: ke, punctuation: Be, reflink: he, reflinkSearch: tt, tag: Ye, text: Ee, url: _ }, nt = { ...W, link: k(/^!?\[(label)\]\((.*?)\)/).replace("label", D).getRegex(), reflink: k(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", D).getRegex() }, Z = { ...W, emStrongRDelimAst: Fe, emStrongLDelim: Ne, delLDelim: Ue, delRDelim: We, url: k(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", ne).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: k(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", ne).getRegex() }, rt = { ...Z, br: k(oe).replace("{2,}", "*").getRegex(), text: k(Z.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, E = { normal: U, gfm: ze, pedantic: Ce }, z = { normal: W, gfm: Z, breaks: rt, pedantic: nt }, st = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, de = /* @__PURE__ */ __name((u3) => st[u3], "de");
  function O(u3, e) {
    if (e) {
      if (m.escapeTest.test(u3)) return u3.replace(m.escapeReplace, de);
    } else if (m.escapeTestNoEncode.test(u3)) return u3.replace(m.escapeReplaceNoEncode, de);
    return u3;
  }
  __name(O, "O");
  function X(u3) {
    try {
      u3 = encodeURI(u3).replace(m.percentDecode, "%");
    } catch {
      return null;
    }
    return u3;
  }
  __name(X, "X");
  function J(u3, e) {
    let t = u3.replace(m.findPipe, (i, s, a) => {
      let o = !1, l = s;
      for (; --l >= 0 && a[l] === "\\"; ) o = !o;
      return o ? "|" : " |";
    }), n = t.split(m.splitPipe), r = 0;
    if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) if (n.length > e) n.splice(e);
    else for (; n.length < e; ) n.push("");
    for (; r < n.length; r++) n[r] = n[r].trim().replace(m.slashPipe, "|");
    return n;
  }
  __name(J, "J");
  function C(u3, e, t) {
    let n = u3.length;
    if (n === 0) return "";
    let r = 0;
    for (; r < n; ) {
      let i = u3.charAt(n - r - 1);
      if (i === e && !t) r++;
      else if (i !== e && t) r++;
      else break;
    }
    return u3.slice(0, n - r);
  }
  __name(C, "C");
  function ge(u3, e) {
    if (u3.indexOf(e[1]) === -1) return -1;
    let t = 0;
    for (let n = 0; n < u3.length; n++) if (u3[n] === "\\") n++;
    else if (u3[n] === e[0]) t++;
    else if (u3[n] === e[1] && (t--, t < 0)) return n;
    return t > 0 ? -2 : -1;
  }
  __name(ge, "ge");
  function fe(u3, e = 0) {
    let t = e, n = "";
    for (let r of u3) if (r === "	") {
      let i = 4 - t % 4;
      n += " ".repeat(i), t += i;
    } else n += r, t++;
    return n;
  }
  __name(fe, "fe");
  function me(u3, e, t, n, r) {
    let i = e.href, s = e.title || null, a = u3[1].replace(r.other.outputLinkReplace, "$1");
    n.state.inLink = !0;
    let o = { type: u3[0].charAt(0) === "!" ? "image" : "link", raw: t, href: i, title: s, text: a, tokens: n.inlineTokens(a) };
    return n.state.inLink = !1, o;
  }
  __name(me, "me");
  function it(u3, e, t) {
    let n = u3.match(t.other.indentCodeCompensation);
    if (n === null) return e;
    let r = n[1];
    return e.split(`
`).map((i) => {
      let s = i.match(t.other.beginningSpace);
      if (s === null) return i;
      let [a] = s;
      return a.length >= r.length ? i.slice(r.length) : i;
    }).join(`
`);
  }
  __name(it, "it");
  var w = class {
    static {
      __name(this, "w");
    }
    options;
    rules;
    lexer;
    constructor(e) {
      this.options = e || T;
    }
    space(e) {
      let t = this.rules.block.newline.exec(e);
      if (t && t[0].length > 0) return { type: "space", raw: t[0] };
    }
    code(e) {
      let t = this.rules.block.code.exec(e);
      if (t) {
        let n = t[0].replace(this.rules.other.codeRemoveIndent, "");
        return { type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : C(n, `
`) };
      }
    }
    fences(e) {
      let t = this.rules.block.fences.exec(e);
      if (t) {
        let n = t[0], r = it(n, t[3] || "", this.rules);
        return { type: "code", raw: n, lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2], text: r };
      }
    }
    heading(e) {
      let t = this.rules.block.heading.exec(e);
      if (t) {
        let n = t[2].trim();
        if (this.rules.other.endingHash.test(n)) {
          let r = C(n, "#");
          (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (n = r.trim());
        }
        return { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: this.lexer.inline(n) };
      }
    }
    hr(e) {
      let t = this.rules.block.hr.exec(e);
      if (t) return { type: "hr", raw: C(t[0], `
`) };
    }
    blockquote(e) {
      let t = this.rules.block.blockquote.exec(e);
      if (t) {
        let n = C(t[0], `
`).split(`
`), r = "", i = "", s = [];
        for (; n.length > 0; ) {
          let a = !1, o = [], l;
          for (l = 0; l < n.length; l++) if (this.rules.other.blockquoteStart.test(n[l])) o.push(n[l]), a = !0;
          else if (!a) o.push(n[l]);
          else break;
          n = n.slice(l);
          let p = o.join(`
`), c = p.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
          r = r ? `${r}
${p}` : p, i = i ? `${i}
${c}` : c;
          let d = this.lexer.state.top;
          if (this.lexer.state.top = !0, this.lexer.blockTokens(c, s, !0), this.lexer.state.top = d, n.length === 0) break;
          let h = s.at(-1);
          if (h?.type === "code") break;
          if (h?.type === "blockquote") {
            let R = h, f = R.raw + `
` + n.join(`
`), S = this.blockquote(f);
            s[s.length - 1] = S, r = r.substring(0, r.length - R.raw.length) + S.raw, i = i.substring(0, i.length - R.text.length) + S.text;
            break;
          } else if (h?.type === "list") {
            let R = h, f = R.raw + `
` + n.join(`
`), S = this.list(f);
            s[s.length - 1] = S, r = r.substring(0, r.length - h.raw.length) + S.raw, i = i.substring(0, i.length - R.raw.length) + S.raw, n = f.substring(s.at(-1).raw.length).split(`
`);
            continue;
          }
        }
        return { type: "blockquote", raw: r, tokens: s, text: i };
      }
    }
    list(e) {
      let t = this.rules.block.list.exec(e);
      if (t) {
        let n = t[1].trim(), r = n.length > 1, i = { type: "list", raw: "", ordered: r, start: r ? +n.slice(0, -1) : "", loose: !1, items: [] };
        n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r ? n : "[*+-]");
        let s = this.rules.other.listItemRegex(n), a = !1;
        for (; e; ) {
          let l = !1, p = "", c = "";
          if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break;
          p = t[0], e = e.substring(p.length);
          let d = fe(t[2].split(`
`, 1)[0], t[1].length), h = e.split(`
`, 1)[0], R = !d.trim(), f = 0;
          if (this.options.pedantic ? (f = 2, c = d.trimStart()) : R ? f = t[1].length + 1 : (f = d.search(this.rules.other.nonSpaceChar), f = f > 4 ? 1 : f, c = d.slice(f), f += t[1].length), R && this.rules.other.blankLine.test(h) && (p += h + `
`, e = e.substring(h.length + 1), l = !0), !l) {
            let S = this.rules.other.nextBulletRegex(f), V = this.rules.other.hrRegex(f), Y = this.rules.other.fencesBeginRegex(f), ee = this.rules.other.headingBeginRegex(f), xe = this.rules.other.htmlBeginRegex(f), be = this.rules.other.blockquoteBeginRegex(f);
            for (; e; ) {
              let G = e.split(`
`, 1)[0], A;
              if (h = G, this.options.pedantic ? (h = h.replace(this.rules.other.listReplaceNesting, "  "), A = h) : A = h.replace(this.rules.other.tabCharGlobal, "    "), Y.test(h) || ee.test(h) || xe.test(h) || be.test(h) || S.test(h) || V.test(h)) break;
              if (A.search(this.rules.other.nonSpaceChar) >= f || !h.trim()) c += `
` + A.slice(f);
              else {
                if (R || d.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || Y.test(d) || ee.test(d) || V.test(d)) break;
                c += `
` + h;
              }
              R = !h.trim(), p += G + `
`, e = e.substring(G.length + 1), d = A.slice(f);
            }
          }
          i.loose || (a ? i.loose = !0 : this.rules.other.doubleBlankLine.test(p) && (a = !0)), i.items.push({ type: "list_item", raw: p, task: !!this.options.gfm && this.rules.other.listIsTask.test(c), loose: !1, text: c, tokens: [] }), i.raw += p;
        }
        let o = i.items.at(-1);
        if (o) o.raw = o.raw.trimEnd(), o.text = o.text.trimEnd();
        else return;
        i.raw = i.raw.trimEnd();
        for (let l of i.items) {
          if (this.lexer.state.top = !1, l.tokens = this.lexer.blockTokens(l.text, []), l.task) {
            if (l.text = l.text.replace(this.rules.other.listReplaceTask, ""), l.tokens[0]?.type === "text" || l.tokens[0]?.type === "paragraph") {
              l.tokens[0].raw = l.tokens[0].raw.replace(this.rules.other.listReplaceTask, ""), l.tokens[0].text = l.tokens[0].text.replace(this.rules.other.listReplaceTask, "");
              for (let c = this.lexer.inlineQueue.length - 1; c >= 0; c--) if (this.rules.other.listIsTask.test(this.lexer.inlineQueue[c].src)) {
                this.lexer.inlineQueue[c].src = this.lexer.inlineQueue[c].src.replace(this.rules.other.listReplaceTask, "");
                break;
              }
            }
            let p = this.rules.other.listTaskCheckbox.exec(l.raw);
            if (p) {
              let c = { type: "checkbox", raw: p[0] + " ", checked: p[0] !== "[ ]" };
              l.checked = c.checked, i.loose ? l.tokens[0] && ["paragraph", "text"].includes(l.tokens[0].type) && "tokens" in l.tokens[0] && l.tokens[0].tokens ? (l.tokens[0].raw = c.raw + l.tokens[0].raw, l.tokens[0].text = c.raw + l.tokens[0].text, l.tokens[0].tokens.unshift(c)) : l.tokens.unshift({ type: "paragraph", raw: c.raw, text: c.raw, tokens: [c] }) : l.tokens.unshift(c);
            }
          }
          if (!i.loose) {
            let p = l.tokens.filter((d) => d.type === "space"), c = p.length > 0 && p.some((d) => this.rules.other.anyLine.test(d.raw));
            i.loose = c;
          }
        }
        if (i.loose) for (let l of i.items) {
          l.loose = !0;
          for (let p of l.tokens) p.type === "text" && (p.type = "paragraph");
        }
        return i;
      }
    }
    html(e) {
      let t = this.rules.block.html.exec(e);
      if (t) return { type: "html", block: !0, raw: t[0], pre: t[1] === "pre" || t[1] === "script" || t[1] === "style", text: t[0] };
    }
    def(e) {
      let t = this.rules.block.def.exec(e);
      if (t) {
        let n = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3];
        return { type: "def", tag: n, raw: t[0], href: r, title: i };
      }
    }
    table(e) {
      let t = this.rules.block.table.exec(e);
      if (!t || !this.rules.other.tableDelimiter.test(t[2])) return;
      let n = J(t[1]), r = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: t[0], header: [], align: [], rows: [] };
      if (n.length === r.length) {
        for (let a of r) this.rules.other.tableAlignRight.test(a) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(a) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(a) ? s.align.push("left") : s.align.push(null);
        for (let a = 0; a < n.length; a++) s.header.push({ text: n[a], tokens: this.lexer.inline(n[a]), header: !0, align: s.align[a] });
        for (let a of i) s.rows.push(J(a, s.header.length).map((o, l) => ({ text: o, tokens: this.lexer.inline(o), header: !1, align: s.align[l] })));
        return s;
      }
    }
    lheading(e) {
      let t = this.rules.block.lheading.exec(e);
      if (t) return { type: "heading", raw: t[0], depth: t[2].charAt(0) === "=" ? 1 : 2, text: t[1], tokens: this.lexer.inline(t[1]) };
    }
    paragraph(e) {
      let t = this.rules.block.paragraph.exec(e);
      if (t) {
        let n = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
        return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) };
      }
    }
    text(e) {
      let t = this.rules.block.text.exec(e);
      if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) };
    }
    escape(e) {
      let t = this.rules.inline.escape.exec(e);
      if (t) return { type: "escape", raw: t[0], text: t[1] };
    }
    tag(e) {
      let t = this.rules.inline.tag.exec(e);
      if (t) return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: t[0] };
    }
    link(e) {
      let t = this.rules.inline.link.exec(e);
      if (t) {
        let n = t[2].trim();
        if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
          if (!this.rules.other.endAngleBracket.test(n)) return;
          let s = C(n.slice(0, -1), "\\");
          if ((n.length - s.length) % 2 === 0) return;
        } else {
          let s = ge(t[2], "()");
          if (s === -2) return;
          if (s > -1) {
            let o = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
            t[2] = t[2].substring(0, s), t[0] = t[0].substring(0, o).trim(), t[3] = "";
          }
        }
        let r = t[2], i = "";
        if (this.options.pedantic) {
          let s = this.rules.other.pedanticHrefTitle.exec(r);
          s && (r = s[1], i = s[3]);
        } else i = t[3] ? t[3].slice(1, -1) : "";
        return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? r = r.slice(1) : r = r.slice(1, -1)), me(t, { href: r && r.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, t[0], this.lexer, this.rules);
      }
    }
    reflink(e, t) {
      let n;
      if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
        let r = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = t[r.toLowerCase()];
        if (!i) {
          let s = n[0].charAt(0);
          return { type: "text", raw: s, text: s };
        }
        return me(n, i, n[0], this.lexer, this.rules);
      }
    }
    emStrong(e, t, n = "") {
      let r = this.rules.inline.emStrongLDelim.exec(e);
      if (!(!r || r[3] && n.match(this.rules.other.unicodeAlphaNumeric)) && (!(r[1] || r[2]) || !n || this.rules.inline.punctuation.exec(n))) {
        let s = [...r[0]].length - 1, a, o, l = s, p = 0, c = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
        for (c.lastIndex = 0, t = t.slice(-1 * e.length + s); (r = c.exec(t)) != null; ) {
          if (a = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !a) continue;
          if (o = [...a].length, r[3] || r[4]) {
            l += o;
            continue;
          } else if ((r[5] || r[6]) && s % 3 && !((s + o) % 3)) {
            p += o;
            continue;
          }
          if (l -= o, l > 0) continue;
          o = Math.min(o, o + l + p);
          let d = [...r[0]][0].length, h = e.slice(0, s + r.index + d + o);
          if (Math.min(s, o) % 2) {
            let f = h.slice(1, -1);
            return { type: "em", raw: h, text: f, tokens: this.lexer.inlineTokens(f) };
          }
          let R = h.slice(2, -2);
          return { type: "strong", raw: h, text: R, tokens: this.lexer.inlineTokens(R) };
        }
      }
    }
    codespan(e) {
      let t = this.rules.inline.code.exec(e);
      if (t) {
        let n = t[2].replace(this.rules.other.newLineCharGlobal, " "), r = this.rules.other.nonSpaceChar.test(n), i = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
        return r && i && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: t[0], text: n };
      }
    }
    br(e) {
      let t = this.rules.inline.br.exec(e);
      if (t) return { type: "br", raw: t[0] };
    }
    del(e, t, n = "") {
      let r = this.rules.inline.delLDelim.exec(e);
      if (r && (!r[1] || !n || this.rules.inline.punctuation.exec(n))) {
        let s = [...r[0]].length - 1, a, o, l = s, p = this.rules.inline.delRDelim;
        for (p.lastIndex = 0, t = t.slice(-1 * e.length + s); (r = p.exec(t)) != null; ) {
          if (a = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !a || (o = [...a].length, o !== s)) continue;
          if (r[3] || r[4]) {
            l += o;
            continue;
          }
          if (l -= o, l > 0) continue;
          o = Math.min(o, o + l);
          let c = [...r[0]][0].length, d = e.slice(0, s + r.index + c + o), h = d.slice(s, -s);
          return { type: "del", raw: d, text: h, tokens: this.lexer.inlineTokens(h) };
        }
      }
    }
    autolink(e) {
      let t = this.rules.inline.autolink.exec(e);
      if (t) {
        let n, r;
        return t[2] === "@" ? (n = t[1], r = "mailto:" + n) : (n = t[1], r = n), { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
      }
    }
    url(e) {
      let t;
      if (t = this.rules.inline.url.exec(e)) {
        let n, r;
        if (t[2] === "@") n = t[0], r = "mailto:" + n;
        else {
          let i;
          do
            i = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "";
          while (i !== t[0]);
          n = t[0], t[1] === "www." ? r = "http://" + t[0] : r = t[0];
        }
        return { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
      }
    }
    inlineText(e) {
      let t = this.rules.inline.text.exec(e);
      if (t) {
        let n = this.lexer.state.inRawBlock;
        return { type: "text", raw: t[0], text: t[0], escaped: n };
      }
    }
  }, x = class u {
    static {
      __name(this, "u");
    }
    tokens;
    options;
    state;
    inlineQueue;
    tokenizer;
    constructor(e) {
      this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || T, this.options.tokenizer = this.options.tokenizer || new w(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
      let t = { other: m, block: E.normal, inline: z.normal };
      this.options.pedantic ? (t.block = E.pedantic, t.inline = z.pedantic) : this.options.gfm && (t.block = E.gfm, this.options.breaks ? t.inline = z.breaks : t.inline = z.gfm), this.tokenizer.rules = t;
    }
    static get rules() {
      return { block: E, inline: z };
    }
    static lex(e, t) {
      return new u(t).lex(e);
    }
    static lexInline(e, t) {
      return new u(t).inlineTokens(e);
    }
    lex(e) {
      e = e.replace(m.carriageReturn, `
`), this.blockTokens(e, this.tokens);
      for (let t = 0; t < this.inlineQueue.length; t++) {
        let n = this.inlineQueue[t];
        this.inlineTokens(n.src, n.tokens);
      }
      return this.inlineQueue = [], this.tokens;
    }
    blockTokens(e, t = [], n = !1) {
      for (this.options.pedantic && (e = e.replace(m.tabCharGlobal, "    ").replace(m.spaceLine, "")); e; ) {
        let r;
        if (this.options.extensions?.block?.some((s) => (r = s.call({ lexer: this }, e, t)) ? (e = e.substring(r.raw.length), t.push(r), !0) : !1)) continue;
        if (r = this.tokenizer.space(e)) {
          e = e.substring(r.raw.length);
          let s = t.at(-1);
          r.raw.length === 1 && s !== void 0 ? s.raw += `
` : t.push(r);
          continue;
        }
        if (r = this.tokenizer.code(e)) {
          e = e.substring(r.raw.length);
          let s = t.at(-1);
          s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.at(-1).src = s.text) : t.push(r);
          continue;
        }
        if (r = this.tokenizer.fences(e)) {
          e = e.substring(r.raw.length), t.push(r);
          continue;
        }
        if (r = this.tokenizer.heading(e)) {
          e = e.substring(r.raw.length), t.push(r);
          continue;
        }
        if (r = this.tokenizer.hr(e)) {
          e = e.substring(r.raw.length), t.push(r);
          continue;
        }
        if (r = this.tokenizer.blockquote(e)) {
          e = e.substring(r.raw.length), t.push(r);
          continue;
        }
        if (r = this.tokenizer.list(e)) {
          e = e.substring(r.raw.length), t.push(r);
          continue;
        }
        if (r = this.tokenizer.html(e)) {
          e = e.substring(r.raw.length), t.push(r);
          continue;
        }
        if (r = this.tokenizer.def(e)) {
          e = e.substring(r.raw.length);
          let s = t.at(-1);
          s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = { href: r.href, title: r.title }, t.push(r));
          continue;
        }
        if (r = this.tokenizer.table(e)) {
          e = e.substring(r.raw.length), t.push(r);
          continue;
        }
        if (r = this.tokenizer.lheading(e)) {
          e = e.substring(r.raw.length), t.push(r);
          continue;
        }
        let i = e;
        if (this.options.extensions?.startBlock) {
          let s = 1 / 0, a = e.slice(1), o;
          this.options.extensions.startBlock.forEach((l) => {
            o = l.call({ lexer: this }, a), typeof o == "number" && o >= 0 && (s = Math.min(s, o));
          }), s < 1 / 0 && s >= 0 && (i = e.substring(0, s + 1));
        }
        if (this.state.top && (r = this.tokenizer.paragraph(i))) {
          let s = t.at(-1);
          n && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r), n = i.length !== e.length, e = e.substring(r.raw.length);
          continue;
        }
        if (r = this.tokenizer.text(e)) {
          e = e.substring(r.raw.length);
          let s = t.at(-1);
          s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r);
          continue;
        }
        if (e) {
          let s = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(s);
            break;
          } else throw new Error(s);
        }
      }
      return this.state.top = !0, t;
    }
    inline(e, t = []) {
      return this.inlineQueue.push({ src: e, tokens: t }), t;
    }
    inlineTokens(e, t = []) {
      let n = e, r = null;
      if (this.tokens.links) {
        let o = Object.keys(this.tokens.links);
        if (o.length > 0) for (; (r = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) o.includes(r[0].slice(r[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
      }
      for (; (r = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, r.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      let i;
      for (; (r = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) i = r[2] ? r[2].length : 0, n = n.slice(0, r.index + i) + "[" + "a".repeat(r[0].length - i - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      n = this.options.hooks?.emStrongMask?.call({ lexer: this }, n) ?? n;
      let s = !1, a = "";
      for (; e; ) {
        s || (a = ""), s = !1;
        let o;
        if (this.options.extensions?.inline?.some((p) => (o = p.call({ lexer: this }, e, t)) ? (e = e.substring(o.raw.length), t.push(o), !0) : !1)) continue;
        if (o = this.tokenizer.escape(e)) {
          e = e.substring(o.raw.length), t.push(o);
          continue;
        }
        if (o = this.tokenizer.tag(e)) {
          e = e.substring(o.raw.length), t.push(o);
          continue;
        }
        if (o = this.tokenizer.link(e)) {
          e = e.substring(o.raw.length), t.push(o);
          continue;
        }
        if (o = this.tokenizer.reflink(e, this.tokens.links)) {
          e = e.substring(o.raw.length);
          let p = t.at(-1);
          o.type === "text" && p?.type === "text" ? (p.raw += o.raw, p.text += o.text) : t.push(o);
          continue;
        }
        if (o = this.tokenizer.emStrong(e, n, a)) {
          e = e.substring(o.raw.length), t.push(o);
          continue;
        }
        if (o = this.tokenizer.codespan(e)) {
          e = e.substring(o.raw.length), t.push(o);
          continue;
        }
        if (o = this.tokenizer.br(e)) {
          e = e.substring(o.raw.length), t.push(o);
          continue;
        }
        if (o = this.tokenizer.del(e, n, a)) {
          e = e.substring(o.raw.length), t.push(o);
          continue;
        }
        if (o = this.tokenizer.autolink(e)) {
          e = e.substring(o.raw.length), t.push(o);
          continue;
        }
        if (!this.state.inLink && (o = this.tokenizer.url(e))) {
          e = e.substring(o.raw.length), t.push(o);
          continue;
        }
        let l = e;
        if (this.options.extensions?.startInline) {
          let p = 1 / 0, c = e.slice(1), d;
          this.options.extensions.startInline.forEach((h) => {
            d = h.call({ lexer: this }, c), typeof d == "number" && d >= 0 && (p = Math.min(p, d));
          }), p < 1 / 0 && p >= 0 && (l = e.substring(0, p + 1));
        }
        if (o = this.tokenizer.inlineText(l)) {
          e = e.substring(o.raw.length), o.raw.slice(-1) !== "_" && (a = o.raw.slice(-1)), s = !0;
          let p = t.at(-1);
          p?.type === "text" ? (p.raw += o.raw, p.text += o.text) : t.push(o);
          continue;
        }
        if (e) {
          let p = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(p);
            break;
          } else throw new Error(p);
        }
      }
      return t;
    }
  }, y = class {
    static {
      __name(this, "y");
    }
    options;
    parser;
    constructor(e) {
      this.options = e || T;
    }
    space(e) {
      return "";
    }
    code({ text: e, lang: t, escaped: n }) {
      let r = (t || "").match(m.notSpaceStart)?.[0], i = e.replace(m.endingNewline, "") + `
`;
      return r ? '<pre><code class="language-' + O(r) + '">' + (n ? i : O(i, !0)) + `</code></pre>
` : "<pre><code>" + (n ? i : O(i, !0)) + `</code></pre>
`;
    }
    blockquote({ tokens: e }) {
      return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
    }
    html({ text: e }) {
      return e;
    }
    def(e) {
      return "";
    }
    heading({ tokens: e, depth: t }) {
      return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
    }
    hr(e) {
      return `<hr>
`;
    }
    list(e) {
      let t = e.ordered, n = e.start, r = "";
      for (let a = 0; a < e.items.length; a++) {
        let o = e.items[a];
        r += this.listitem(o);
      }
      let i = t ? "ol" : "ul", s = t && n !== 1 ? ' start="' + n + '"' : "";
      return "<" + i + s + `>
` + r + "</" + i + `>
`;
    }
    listitem(e) {
      return `<li>${this.parser.parse(e.tokens)}</li>
`;
    }
    checkbox({ checked: e }) {
      return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox"> ';
    }
    paragraph({ tokens: e }) {
      return `<p>${this.parser.parseInline(e)}</p>
`;
    }
    table(e) {
      let t = "", n = "";
      for (let i = 0; i < e.header.length; i++) n += this.tablecell(e.header[i]);
      t += this.tablerow({ text: n });
      let r = "";
      for (let i = 0; i < e.rows.length; i++) {
        let s = e.rows[i];
        n = "";
        for (let a = 0; a < s.length; a++) n += this.tablecell(s[a]);
        r += this.tablerow({ text: n });
      }
      return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + r + `</table>
`;
    }
    tablerow({ text: e }) {
      return `<tr>
${e}</tr>
`;
    }
    tablecell(e) {
      let t = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
      return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + t + `</${n}>
`;
    }
    strong({ tokens: e }) {
      return `<strong>${this.parser.parseInline(e)}</strong>`;
    }
    em({ tokens: e }) {
      return `<em>${this.parser.parseInline(e)}</em>`;
    }
    codespan({ text: e }) {
      return `<code>${O(e, !0)}</code>`;
    }
    br(e) {
      return "<br>";
    }
    del({ tokens: e }) {
      return `<del>${this.parser.parseInline(e)}</del>`;
    }
    link({ href: e, title: t, tokens: n }) {
      let r = this.parser.parseInline(n), i = X(e);
      if (i === null) return r;
      e = i;
      let s = '<a href="' + e + '"';
      return t && (s += ' title="' + O(t) + '"'), s += ">" + r + "</a>", s;
    }
    image({ href: e, title: t, text: n, tokens: r }) {
      r && (n = this.parser.parseInline(r, this.parser.textRenderer));
      let i = X(e);
      if (i === null) return O(n);
      e = i;
      let s = `<img src="${e}" alt="${O(n)}"`;
      return t && (s += ` title="${O(t)}"`), s += ">", s;
    }
    text(e) {
      return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : O(e.text);
    }
  }, $ = class {
    static {
      __name(this, "$");
    }
    strong({ text: e }) {
      return e;
    }
    em({ text: e }) {
      return e;
    }
    codespan({ text: e }) {
      return e;
    }
    del({ text: e }) {
      return e;
    }
    html({ text: e }) {
      return e;
    }
    text({ text: e }) {
      return e;
    }
    link({ text: e }) {
      return "" + e;
    }
    image({ text: e }) {
      return "" + e;
    }
    br() {
      return "";
    }
    checkbox({ raw: e }) {
      return e;
    }
  }, b = class u2 {
    static {
      __name(this, "u");
    }
    options;
    renderer;
    textRenderer;
    constructor(e) {
      this.options = e || T, this.options.renderer = this.options.renderer || new y(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new $();
    }
    static parse(e, t) {
      return new u2(t).parse(e);
    }
    static parseInline(e, t) {
      return new u2(t).parseInline(e);
    }
    parse(e) {
      let t = "";
      for (let n = 0; n < e.length; n++) {
        let r = e[n];
        if (this.options.extensions?.renderers?.[r.type]) {
          let s = r, a = this.options.extensions.renderers[s.type].call({ parser: this }, s);
          if (a !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(s.type)) {
            t += a || "";
            continue;
          }
        }
        let i = r;
        switch (i.type) {
          case "space": {
            t += this.renderer.space(i);
            break;
          }
          case "hr": {
            t += this.renderer.hr(i);
            break;
          }
          case "heading": {
            t += this.renderer.heading(i);
            break;
          }
          case "code": {
            t += this.renderer.code(i);
            break;
          }
          case "table": {
            t += this.renderer.table(i);
            break;
          }
          case "blockquote": {
            t += this.renderer.blockquote(i);
            break;
          }
          case "list": {
            t += this.renderer.list(i);
            break;
          }
          case "checkbox": {
            t += this.renderer.checkbox(i);
            break;
          }
          case "html": {
            t += this.renderer.html(i);
            break;
          }
          case "def": {
            t += this.renderer.def(i);
            break;
          }
          case "paragraph": {
            t += this.renderer.paragraph(i);
            break;
          }
          case "text": {
            t += this.renderer.text(i);
            break;
          }
          default: {
            let s = 'Token with "' + i.type + '" type was not found.';
            if (this.options.silent) return console.error(s), "";
            throw new Error(s);
          }
        }
      }
      return t;
    }
    parseInline(e, t = this.renderer) {
      let n = "";
      for (let r = 0; r < e.length; r++) {
        let i = e[r];
        if (this.options.extensions?.renderers?.[i.type]) {
          let a = this.options.extensions.renderers[i.type].call({ parser: this }, i);
          if (a !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type)) {
            n += a || "";
            continue;
          }
        }
        let s = i;
        switch (s.type) {
          case "escape": {
            n += t.text(s);
            break;
          }
          case "html": {
            n += t.html(s);
            break;
          }
          case "link": {
            n += t.link(s);
            break;
          }
          case "image": {
            n += t.image(s);
            break;
          }
          case "checkbox": {
            n += t.checkbox(s);
            break;
          }
          case "strong": {
            n += t.strong(s);
            break;
          }
          case "em": {
            n += t.em(s);
            break;
          }
          case "codespan": {
            n += t.codespan(s);
            break;
          }
          case "br": {
            n += t.br(s);
            break;
          }
          case "del": {
            n += t.del(s);
            break;
          }
          case "text": {
            n += t.text(s);
            break;
          }
          default: {
            let a = 'Token with "' + s.type + '" type was not found.';
            if (this.options.silent) return console.error(a), "";
            throw new Error(a);
          }
        }
      }
      return n;
    }
  }, P = class {
    static {
      __name(this, "P");
    }
    options;
    block;
    constructor(e) {
      this.options = e || T;
    }
    static passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
    static passThroughHooksRespectAsync = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"]);
    preprocess(e) {
      return e;
    }
    postprocess(e) {
      return e;
    }
    processAllTokens(e) {
      return e;
    }
    emStrongMask(e) {
      return e;
    }
    provideLexer() {
      return this.block ? x.lex : x.lexInline;
    }
    provideParser() {
      return this.block ? b.parse : b.parseInline;
    }
  }, B = class {
    static {
      __name(this, "B");
    }
    defaults = M();
    options = this.setOptions;
    parse = this.parseMarkdown(!0);
    parseInline = this.parseMarkdown(!1);
    Parser = b;
    Renderer = y;
    TextRenderer = $;
    Lexer = x;
    Tokenizer = w;
    Hooks = P;
    constructor(...e) {
      this.use(...e);
    }
    walkTokens(e, t) {
      let n = [];
      for (let r of e) switch (n = n.concat(t.call(this, r)), r.type) {
        case "table": {
          let i = r;
          for (let s of i.header) n = n.concat(this.walkTokens(s.tokens, t));
          for (let s of i.rows) for (let a of s) n = n.concat(this.walkTokens(a.tokens, t));
          break;
        }
        case "list": {
          let i = r;
          n = n.concat(this.walkTokens(i.items, t));
          break;
        }
        default: {
          let i = r;
          this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
            let a = i[s].flat(1 / 0);
            n = n.concat(this.walkTokens(a, t));
          }) : i.tokens && (n = n.concat(this.walkTokens(i.tokens, t)));
        }
      }
      return n;
    }
    use(...e) {
      let t = this.defaults.extensions || { renderers: {}, childTokens: {} };
      return e.forEach((n) => {
        let r = { ...n };
        if (r.async = this.defaults.async || r.async || !1, n.extensions && (n.extensions.forEach((i) => {
          if (!i.name) throw new Error("extension name required");
          if ("renderer" in i) {
            let s = t.renderers[i.name];
            s ? t.renderers[i.name] = function(...a) {
              let o = i.renderer.apply(this, a);
              return o === !1 && (o = s.apply(this, a)), o;
            } : t.renderers[i.name] = i.renderer;
          }
          if ("tokenizer" in i) {
            if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
            let s = t[i.level];
            s ? s.unshift(i.tokenizer) : t[i.level] = [i.tokenizer], i.start && (i.level === "block" ? t.startBlock ? t.startBlock.push(i.start) : t.startBlock = [i.start] : i.level === "inline" && (t.startInline ? t.startInline.push(i.start) : t.startInline = [i.start]));
          }
          "childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens);
        }), r.extensions = t), n.renderer) {
          let i = this.defaults.renderer || new y(this.defaults);
          for (let s in n.renderer) {
            if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
            if (["options", "parser"].includes(s)) continue;
            let a = s, o = n.renderer[a], l = i[a];
            i[a] = (...p) => {
              let c = o.apply(i, p);
              return c === !1 && (c = l.apply(i, p)), c || "";
            };
          }
          r.renderer = i;
        }
        if (n.tokenizer) {
          let i = this.defaults.tokenizer || new w(this.defaults);
          for (let s in n.tokenizer) {
            if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
            if (["options", "rules", "lexer"].includes(s)) continue;
            let a = s, o = n.tokenizer[a], l = i[a];
            i[a] = (...p) => {
              let c = o.apply(i, p);
              return c === !1 && (c = l.apply(i, p)), c;
            };
          }
          r.tokenizer = i;
        }
        if (n.hooks) {
          let i = this.defaults.hooks || new P();
          for (let s in n.hooks) {
            if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
            if (["options", "block"].includes(s)) continue;
            let a = s, o = n.hooks[a], l = i[a];
            P.passThroughHooks.has(s) ? i[a] = (p) => {
              if (this.defaults.async && P.passThroughHooksRespectAsync.has(s)) return (async () => {
                let d = await o.call(i, p);
                return l.call(i, d);
              })();
              let c = o.call(i, p);
              return l.call(i, c);
            } : i[a] = (...p) => {
              if (this.defaults.async) return (async () => {
                let d = await o.apply(i, p);
                return d === !1 && (d = await l.apply(i, p)), d;
              })();
              let c = o.apply(i, p);
              return c === !1 && (c = l.apply(i, p)), c;
            };
          }
          r.hooks = i;
        }
        if (n.walkTokens) {
          let i = this.defaults.walkTokens, s = n.walkTokens;
          r.walkTokens = function(a) {
            let o = [];
            return o.push(s.call(this, a)), i && (o = o.concat(i.call(this, a))), o;
          };
        }
        this.defaults = { ...this.defaults, ...r };
      }), this;
    }
    setOptions(e) {
      return this.defaults = { ...this.defaults, ...e }, this;
    }
    lexer(e, t) {
      return x.lex(e, t ?? this.defaults);
    }
    parser(e, t) {
      return b.parse(e, t ?? this.defaults);
    }
    parseMarkdown(e) {
      return (n, r) => {
        let i = { ...r }, s = { ...this.defaults, ...i }, a = this.onError(!!s.silent, !!s.async);
        if (this.defaults.async === !0 && i.async === !1) return a(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
        if (typeof n > "u" || n === null) return a(new Error("marked(): input parameter is undefined or null"));
        if (typeof n != "string") return a(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
        if (s.hooks && (s.hooks.options = s, s.hooks.block = e), s.async) return (async () => {
          let o = s.hooks ? await s.hooks.preprocess(n) : n, p = await (s.hooks ? await s.hooks.provideLexer() : e ? x.lex : x.lexInline)(o, s), c = s.hooks ? await s.hooks.processAllTokens(p) : p;
          s.walkTokens && await Promise.all(this.walkTokens(c, s.walkTokens));
          let h = await (s.hooks ? await s.hooks.provideParser() : e ? b.parse : b.parseInline)(c, s);
          return s.hooks ? await s.hooks.postprocess(h) : h;
        })().catch(a);
        try {
          s.hooks && (n = s.hooks.preprocess(n));
          let l = (s.hooks ? s.hooks.provideLexer() : e ? x.lex : x.lexInline)(n, s);
          s.hooks && (l = s.hooks.processAllTokens(l)), s.walkTokens && this.walkTokens(l, s.walkTokens);
          let c = (s.hooks ? s.hooks.provideParser() : e ? b.parse : b.parseInline)(l, s);
          return s.hooks && (c = s.hooks.postprocess(c)), c;
        } catch (o) {
          return a(o);
        }
      };
    }
    onError(e, t) {
      return (n) => {
        if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
          let r = "<p>An error occurred:</p><pre>" + O(n.message + "", !0) + "</pre>";
          return t ? Promise.resolve(r) : r;
        }
        if (t) return Promise.reject(n);
        throw n;
      };
    }
  }, L = new B();
  function g(u3, e) {
    return L.parse(u3, e);
  }
  __name(g, "g");
  g.options = g.setOptions = function(u3) {
    return L.setOptions(u3), g.defaults = L.defaults, H(g.defaults), g;
  };
  g.getDefaults = M;
  g.defaults = T;
  g.use = function(...u3) {
    return L.use(...u3), g.defaults = L.defaults, H(g.defaults), g;
  };
  g.walkTokens = function(u3, e) {
    return L.walkTokens(u3, e);
  };
  g.parseInline = L.parseInline;
  g.Parser = b;
  g.parser = b.parse;
  g.Renderer = y;
  g.TextRenderer = $;
  g.Lexer = x;
  g.lexer = x.lex;
  g.Tokenizer = w;
  g.Hooks = P;
  g.parse = g;
  var Ut = g.options, Kt = g.setOptions, Wt = g.use, Xt = g.walkTokens, Jt = g.parseInline;
  var Yt = b.parse, en = x.lex;

  // src/content/core/utils/markdown.js
  function parseMarkdown(text2, themeColors = {}) {
    if (!text2) return "";
    let processedText = text2.replace(/\{\{(.*?) ([a-zA-Z0-9#-_]+)\}\}/g, (match, content, colorName) => `<span style="color:${themeColors[colorName] || colorName || "inherit"};">${content}</span>`);
    return g.setOptions({
      gfm: !0,
      breaks: !0
    }), `<div class="rovalra-markdown">${g.parse(processedText)}</div>`;
  }
  __name(parseMarkdown, "parseMarkdown");

  // src/content/features/developer/markdowntest.js
  var observerActive = !1;
  function removeHomeElement2() {
    let homeElementToRemove = document.querySelector("li.cursor-pointer.btr-nav-node-header_home.btr-nav-header_home");
    homeElementToRemove && homeElementToRemove.remove();
  }
  __name(removeHomeElement2, "removeHomeElement");
  function renderMarkdownPage(contentDiv) {
    if (window.location.pathname.toLowerCase() !== "/markdown") return;
    contentDiv.innerHTML = "", contentDiv.style.position = "relative";
    let headerContainer = document.createElement("div");
    headerContainer.style.marginBottom = "20px", headerContainer.style.padding = "20px 0";
    let h1 = document.createElement("h1");
    h1.textContent = "RoValra Markdown Test", h1.style.fontWeight = "800", h1.style.fontSize = "2.5em", h1.style.margin = "0", headerContainer.appendChild(h1), contentDiv.appendChild(headerContainer);
    let renderedHtml = parseMarkdown(`
# Heading 1
## Heading 2
### Heading 3
#### Heading 4
##### Heading 5
###### Heading 6

---

### Text Formatting
This is a paragraph with **bold text**, *italic text*, and ~~strikethrough~~.
You can also combine them: ***bold and italic***.

### Lists
Unordered:
- Item 1
- Item 2
  - Nested Item 2.1
  - Nested Item 2.2

Ordered:
1. First
2. Second
3. Third

### Links & Images
[RoValra Repository](https://github.com/NotValra/RoValra)
![Image Test](https://tr.rbxcdn.com/180DAY-bae15f4fd078a8cb4229bee3c0bfebf3/150/150/Decal/Webp/noFilter)

### Code
Inline code: \`console.log('Hello')\`

Block code:
\`\`\`javascript
const test = 'Hello World';
function run() {
    console.log(test);
}
\`\`\`

### Blockquotes
> This is a blockquote.
> It can span multiple lines.

### Bullet points
- This is a bullet point
- This is another bullet point

### Tables
| Header 1 | Header 2 |
| --- | --- |
|Data 1|Data 2|
|Data 3|Data 4|

### Custom Colors (RoValra Specific)
{{This text is red red}}
{{This text is blue blue}}
{{This text is green #00FF00}}
{{This text uses theme color text-color}}
`, {
      red: "#ff5555",
      blue: "#5555ff",
      "text-color": "var(--rovalra-main-text-color)"
    }), container = document.createElement("div");
    container.style.padding = "20px", container.innerHTML = renderedHtml, contentDiv.appendChild(container), removeHomeElement2();
  }
  __name(renderMarkdownPage, "renderMarkdownPage");
  function init10() {
    chrome.storage.local.get("eastereggslinksEnabled", (result) => {
      if (result.eastereggslinksEnabled) {
        if (window.location.pathname.toLowerCase() !== "/markdown") return;
        let contentDiv = document.querySelector(".content#content");
        contentDiv && renderMarkdownPage(contentDiv), observerActive || (observerActive = !0, observeElement(".content#content", (cDiv) => {
          renderMarkdownPage(cDiv);
        }));
      }
    });
  }
  __name(init10, "init");

  // src/content/core/packages/dompurify.js
  var safeHtml = /* @__PURE__ */ __name((strings, ...values) => {
    let result = strings[0];
    return values.forEach((val, i) => {
      let escaped = (val == null ? "" : String(val)).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      result += escaped + strings[i + 1];
    }), purify.sanitize(result);
  }, "safeHtml"), dompurify_default = purify;

  // src/content/core/games/playerCount.js
  function formatPlayerCount(num) {
    return num < 1e3 ? num.toString() : num < 1e6 ? `${(num / 1e3).toFixed(1)}K` : num < 1e9 ? `${(num / 1e6).toFixed(1)}M` : `${(num / 1e9).toFixed(1)}B`;
  }
  __name(formatPlayerCount, "formatPlayerCount");

  // src/content/core/ui/games/gameCard.js
  var BATCH_WAIT = 50, MAX_BATCH = 50, universeQueue = /* @__PURE__ */ new Map(), universeTimer = null;
  async function fetchWithRetry(subdomain, endpoint, retries = 3) {
    try {
      let res = await callRobloxApi({ subdomain, endpoint, method: "GET" });
      if (res.status === 429 && retries > 0)
        return await new Promise((r) => setTimeout(r, 1e3 * (4 - retries))), fetchWithRetry(subdomain, endpoint, retries - 1);
      if (!res.ok) throw new Error(`API Error: ${res.status}`);
      return res.json();
    } catch (e) {
      if (retries > 0)
        return await new Promise((r) => setTimeout(r, 1e3)), fetchWithRetry(subdomain, endpoint, retries - 1);
      throw e;
    }
  }
  __name(fetchWithRetry, "fetchWithRetry");
  async function getUniverseIdFromPlaceId(placeId) {
    let data = await (await callRobloxApi({
      subdomain: "games",
      endpoint: `/v1/games/multiget-place-details?placeIds=${placeId}`,
      method: "GET"
    })).json();
    if (Array.isArray(data) && data[0] && data[0].universeId)
      return data[0].universeId;
    throw new Error("Place not found");
  }
  __name(getUniverseIdFromPlaceId, "getUniverseIdFromPlaceId");
  function flushUniverseQueue() {
    let currentMap = new Map(universeQueue);
    universeQueue.clear(), universeTimer = null;
    let ids = Array.from(currentMap.keys());
    if (ids.length !== 0)
      for (let i = 0; i < ids.length; i += MAX_BATCH) {
        let chunk = ids.slice(i, i + MAX_BATCH), idsStr = chunk.length > 2 ? chunk.join(",") : `1,${chunk.join(",")}`;
        Promise.all([
          fetchWithRetry("games", `/v1/games?universeIds=${idsStr}`),
          fetchWithRetry("games", `/v1/games/votes?universeIds=${idsStr}`)
        ]).then(([gamesData, votesData]) => {
          let games = gamesData.data || [], votes = votesData.data || [], gameMap = new Map(games.map((g2) => [g2.id, g2])), voteMap = new Map(votes.map((v2) => [v2.id, v2]));
          chunk.forEach((id) => {
            let resolvers = currentMap.get(id), game = gameMap.get(id), vote = voteMap.get(id) || { upVotes: 0, downVotes: 0 };
            game ? resolvers.forEach((r) => r.resolve({ game, vote })) : resolvers.forEach((r) => r.reject(new Error("Game not found")));
          });
        }).catch((err) => {
          chunk.forEach((id) => {
            let resolvers = currentMap.get(id);
            resolvers && resolvers.forEach((r) => r.reject(err));
          });
        });
      }
  }
  __name(flushUniverseQueue, "flushUniverseQueue");
  function getGameData(universeId) {
    let id = parseInt(universeId, 10);
    return new Promise((resolve, reject) => {
      universeQueue.has(id) || universeQueue.set(id, []), universeQueue.get(id).push({ resolve, reject }), universeTimer || (universeTimer = setTimeout(flushUniverseQueue, BATCH_WAIT));
    });
  }
  __name(getGameData, "getGameData");
  var friendCachePromise = null;
  function getOnlineFriends(userId) {
    return friendCachePromise || (friendCachePromise = callRobloxApi({
      subdomain: "friends",
      endpoint: `/v1/users/${userId}/friends/online`,
      method: "GET"
    }).then((res) => res.json()).catch((e) => (console.warn("RoValra: Friend fetch error", e), { data: [] })), setTimeout(() => {
      friendCachePromise = null;
    }, 5e3)), friendCachePromise;
  }
  __name(getOnlineFriends, "getOnlineFriends");
  function createGameCard(options) {
    (typeof options == "number" || typeof options == "string") && (options = { placeId: options });
    let {
      game,
      gameId,
      placeId,
      stats,
      showVotes = !0,
      showPlayers = !0,
      thumbStyle = {},
      friendData
    } = options;
    if (!game && (gameId || placeId)) {
      let card2 = document.createElement("div");
      return card2.className = "rovalra-game-card", card2.innerHTML = `
            <div class="game-card-thumb-container shimmer"></div>
            <div class="game-card-name game-name-title shimmer"></div>
            <div class="game-card-name game-name-title game-name-title-half shimmer"></div>
        `, (async () => {
        try {
          let targetUniverseId = gameId;
          if (!targetUniverseId && placeId && (targetUniverseId = await getUniverseIdFromPlaceId(placeId)), !targetUniverseId) throw new Error("Could not resolve Universe ID");
          let userId = document.querySelector('meta[name="user-data"]')?.dataset?.userid, promises = [
            getGameData(targetUniverseId),
            fetchThumbnails([{ id: targetUniverseId }], "GameIcon", "150x150")
          ];
          userId && promises.push(getOnlineFriends(userId));
          let results = await Promise.all(promises), { game: gameInfo, vote: voteInfo } = results[0], thumbMap = results[1], friendsData = userId ? results[2] : null;
          if (!gameInfo) throw new Error("Game not found");
          let universeId = gameInfo.id, fetchedStats = {
            likes: /* @__PURE__ */ new Map([[universeId, { ratio: Math.floor(voteInfo.upVotes / (voteInfo.upVotes + voteInfo.downVotes) * 100) || 0, total: voteInfo.upVotes + voteInfo.downVotes }]]),
            players: /* @__PURE__ */ new Map([[universeId, gameInfo.playing]]),
            thumbnails: thumbMap
          }, fetchedFriendData = null;
          if (friendsData)
            try {
              let friend = friendsData.data?.find((f) => f.userPresence?.universeId === universeId);
              if (friend) {
                let [userRes, friendThumbMap] = await Promise.all([
                  callRobloxApi({ subdomain: "users", endpoint: `/v1/users/${friend.id}`, method: "GET" }),
                  fetchThumbnails([{ id: friend.id }], "AvatarHeadshot", "48x48")
                ]);
                if (userRes.ok) {
                  let userData = await userRes.json();
                  fetchedFriendData = {
                    id: friend.id,
                    name: userData.displayName,
                    thumbnail: friendThumbMap.get(friend.id)
                  };
                }
              }
            } catch (e) {
              console.warn("RoValra: Error fetching friend info", e);
            }
          let realCard = createGameCard({ game: gameInfo, stats: fetchedStats, showVotes, showPlayers, thumbStyle, friendData: fetchedFriendData });
          card2.replaceWith(realCard);
        } catch (e) {
          console.warn("RoValra: Error creating game card from ID", e), card2.innerHTML = '<div style="padding: 10px; color: var(--text-error);">Failed to load game</div>';
        }
      })(), card2;
    }
    if (!game) return document.createElement("div");
    let voteData = stats?.likes?.get(game.id) || { ratio: 0, total: 0 }, playerCount = stats?.players?.get(game.id) || 0, formattedPlayerCount = formatPlayerCount(playerCount), thumbnailData = stats?.thumbnails?.get(game.id), card = document.createElement("div");
    card.className = "rovalra-game-card";
    let infoHtml;
    friendData ? infoHtml = `
            <div class="game-card-friend-info game-card-info" data-testid="game-tile-stats-friends">
                <div class="info-avatar" style="width: 32px;">
                    <div class="avatar-card" role="button" tabindex="0">
                        <span class="thumbnail-2d-container avatar avatar-headshot avatar-headshot-xs">
                            <img class="avatar-card-image" src="${friendData.thumbnail?.imageUrl || ""}" alt="${friendData.name}" title="${friendData.name}">
                        </span>
                    </div>
                </div>
            </div>
        ` : infoHtml = `
            <div class="game-card-info">
                ${showVotes ? `
                    <span class="info-label icon-votes-gray"></span>
                    <span class="info-label vote-percentage-label ${voteData.total > 0 ? "" : "hidden"}">${voteData.ratio}%</span>
                    <span class="info-label no-vote ${voteData.total === 0 ? "" : "hidden"}"></span>
                ` : ""}
                ${showPlayers ? `
                    <span class="info-label icon-playing-counts-gray"></span>
                    <span class="info-label playing-counts-label" title="${playerCount.toLocaleString()}">${formattedPlayerCount}</span>
                ` : ""}
            </div>
        `, card.innerHTML = `
        <a class="game-card-link" href="https://www.roblox.com/games/${placeId || game.rootPlaceId}/unnamed">
            <div class="game-card-thumb-container"></div>
            ${safeHtml`<div class="game-card-name" title="${game.name}">${game.name}</div>`}
            ${infoHtml}
        </a>
    `;
    let thumbContainer = card.querySelector(".game-card-thumb-container");
    return thumbContainer && thumbContainer.appendChild(
      createThumbnailElement(
        thumbnailData,
        game.name,
        "game-card-thumb",
        thumbStyle
      )
    ), card;
  }
  __name(createGameCard, "createGameCard");

  // src/content/core/ui/items/serials.js
  function createSerialIcon(item, hideSerial) {
    if (item.serialNumber == null) return null;
    let serialVisibilityClass = hideSerial ? "hover-reveal" : "always-visible", serialIconElement = document.createElement("div");
    return serialIconElement.className = `rovalra-serial-container ${serialVisibilityClass}`, serialIconElement.innerHTML = purify.sanitize(`
        <div class="rovalra-serial-star">
            <span class="icon-shop-limited"></span>
        </div>
        <span class="rovalra-serial-number">#${item.serialNumber.toLocaleString()}</span>
    `), serialIconElement;
  }
  __name(createSerialIcon, "createSerialIcon");

  // src/content/core/ui/items/items.js
  var batchQueue = [], batchTimeout = null, BATCH_DELAY = 50;
  async function processBatch() {
    let currentBatch = [...batchQueue];
    batchQueue = [], batchTimeout = null;
    try {
      let ids = currentBatch.map((item) => item.id), [detailsRes, looksRes, thumbMap] = await Promise.all([
        callRobloxApi({
          subdomain: "catalog",
          endpoint: "/v1/catalog/items/details",
          method: "POST",
          body: { items: ids.map((id) => ({ itemType: "Asset", id })) }
        }),
        callRobloxApi({
          subdomain: "apis",
          endpoint: "/look-api/v1/looks/purchase-details",
          method: "POST",
          body: { assets: ids.map((id) => ({ id })) }
        }),
        fetchThumbnails(ids.map((id) => ({ id })), "Asset", "150x150")
      ]);
      if (!detailsRes.ok) throw new Error("Failed to fetch batch details");
      looksRes.ok || console.warn("RoValra: Looks API request failed, prices may be incomplete.");
      let detailsData = await detailsRes.json(), looksData = looksRes.ok ? await looksRes.json() : null, catalogDetailsMap = new Map(detailsData.data?.map((item) => [item.id, item])), looksDetailsMap = /* @__PURE__ */ new Map();
      looksData?.look?.items?.forEach((item) => {
        looksDetailsMap.set(item.id, item), item.assetsInBundle?.forEach((bundleAsset) => {
          looksDetailsMap.has(bundleAsset.id) || looksDetailsMap.set(bundleAsset.id, item);
        });
      }), currentBatch.forEach((request) => {
        let catalogItemData = catalogDetailsMap.get(request.id), looksItemData = looksDetailsMap.get(request.id), itemData = looksItemData || catalogItemData;
        if (catalogItemData) {
          let isLimited = itemData.itemRestrictions?.includes("Limited") || itemData.itemRestrictions?.includes("LimitedUnique") || itemData.itemRestrictions?.includes("Collectible"), rawPrice = itemData.priceInRobux ?? itemData.lowestPrice ?? itemData.price, item = {
            assetId: request.id,
            name: catalogItemData.name,
            recentAveragePrice: rawPrice || 0,
            itemRestrictions: itemData.itemRestrictions || [],
            itemType: catalogItemData.itemType,
            isOnHold: !1,
            bundleId: null
          };
          looksItemData?.itemType === "Bundle" && looksItemData.id !== request.id && (item.bundleId = looksItemData.id), itemData.isOffSale || itemData.noPriceStatus === "OffSale" || !itemData.isPurchasable ? isLimited && rawPrice != null ? item.price = rawPrice : item.priceText = "Off Sale" : (item.price = rawPrice, rawPrice === 0 && (item.priceText = "Free"));
          let realCard = createItemCard(item, thumbMap, request.config);
          request.placeholder.replaceWith(realCard);
        } else
          request.placeholder.innerHTML = '<div style="padding: 10px; color: var(--text-error);">Not Found</div>';
      });
    } catch (e) {
      console.warn("RoValra: Batch request failed", e), currentBatch.forEach((request) => {
        request.placeholder.innerHTML = '<div style="padding: 10px; color: var(--text-error);">Failed to load</div>';
      });
    }
  }
  __name(processBatch, "processBatch");
  function createItemCard(itemOrId, thumbnailCacheOrConfig, config = {}) {
    if (typeof itemOrId == "number" || typeof itemOrId == "string") {
      let itemId = parseInt(itemOrId), actualConfig = thumbnailCacheOrConfig && !thumbnailCacheOrConfig.get ? thumbnailCacheOrConfig : config, card2 = document.createElement("div");
      return card2.className = "rovalra-item-card", card2.style.minHeight = "100px", actualConfig.cardStyles ? Object.assign(card2.style, actualConfig.cardStyles) : (card2.style.width = "100%", card2.style.minWidth = "1%", card2.style.maxWidth = "150px"), card2.innerHTML = `
            <div class="rovalra-item-thumb-container shimmer" style="width: 100%; height: 150px; border-radius: 8px; margin-bottom: 4px;"></div>
            <div class="rovalra-item-name shimmer" style="height: 14px; width: 90%; margin-bottom: 4px; border-radius: 4px;"></div>
            <div class="rovalra-item-rap shimmer" style="height: 14px; width: 60%; border-radius: 4px;"></div>
        `, batchQueue.push({
        id: itemId,
        placeholder: card2,
        config: actualConfig
      }), batchTimeout && clearTimeout(batchTimeout), batchTimeout = setTimeout(processBatch, BATCH_DELAY), card2;
    }
    let item = itemOrId, thumbnailCache = thumbnailCacheOrConfig, { showOnHold = !0, showSerial = !0, hideSerial = !1 } = config, card = document.createElement("div");
    card.className = "rovalra-item-card", config.cardStyles ? Object.assign(card.style, config.cardStyles) : (card.style.width = "100%", card.style.minWidth = "1%", card.style.maxWidth = "150px"), item.price !== void 0 && item.price !== null && (card.dataset.rovalraPrice = item.price, item.bundleId && (card.dataset.rovalraBundleId = item.bundleId));
    let thumbData = thumbnailCache?.get ? thumbnailCache.get(item.assetId) : null, itemUrl = (item.itemType || "Asset") === "Bundle" ? `https://www.roblox.com/bundles/${item.assetId}/unnamed` : `https://www.roblox.com/catalog/${item.assetId}/unnamed`, priceHtml;
    item.priceText ? priceHtml = `<span>${item.priceText}</span>` : priceHtml = `<span class="icon-robux-16x16"></span><span>${typeof item.recentAveragePrice == "number" ? item.recentAveragePrice.toLocaleString() : "N/A"}</span>`;
    let thumbContainer = document.createElement("div");
    thumbContainer.className = "rovalra-item-thumb-container", thumbContainer.style.position = "relative", thumbContainer.style.width = "100%", thumbContainer.style.height = "100%", thumbContainer.style.maxHeight = "150px";
    let thumbnailElement = createThumbnailElement(
      thumbData,
      item.name,
      "rovalra-item-thumb"
    );
    if (showOnHold && item.isOnHold) {
      let onHoldIconElement = document.createElement("div");
      onHoldIconElement.className = "rovalra-on-hold-icon-container", onHoldIconElement.innerHTML = `
            <svg focusable="false" aria-hidden="true" viewBox="0 0 24 24">
              <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2m4.2 14.2L11 13V7h1.5v5.2l4.5 2.7z"></path>
            </svg>
        `, addTooltip(onHoldIconElement, "On Hold", { position: "top" }), thumbContainer.appendChild(onHoldIconElement);
    }
    if (showSerial) {
      let serialIcon = createSerialIcon(item, hideSerial);
      serialIcon && thumbContainer.appendChild(serialIcon);
    }
    thumbContainer.appendChild(thumbnailElement);
    let showLimitedIcon = !1, isUnique = !1;
    if (Array.isArray(item.itemRestrictions)) {
      let hasLimited = item.itemRestrictions.includes("Limited"), hasLimitedUnique = item.itemRestrictions.includes("LimitedUnique"), hasCollectible = item.itemRestrictions.includes("Collectible");
      showLimitedIcon = hasLimited || hasLimitedUnique || hasCollectible, isUnique = hasLimitedUnique || hasCollectible;
    } else
      isUnique = item.serialNumber != null, (isUnique || item.recentAveragePrice !== void 0) && (showLimitedIcon = !0);
    if (showLimitedIcon) {
      let limitedIconElement = document.createElement("span");
      limitedIconElement.className = isUnique ? "icon-label icon-limited-unique-label" : "icon-label icon-limited-label", thumbContainer.appendChild(limitedIconElement);
    }
    card.innerHTML = `
        <a href="${itemUrl}" class="rovalra-item-card-link">
            <div class="rovalra-item-name"></div>
            <div class="rovalra-item-rap">
                ${priceHtml}
            </div>
        </a>
    `;
    let nameDiv = card.querySelector(".rovalra-item-name");
    return nameDiv.title = item.name, nameDiv.textContent = item.name, card.querySelector("a").prepend(thumbContainer), card;
  }
  __name(createItemCard, "createItemCard");

  // src/content/core/ui/general/toggle.js
  function createToggle({ id, checked = !1, onChange }) {
    let button = document.createElement("button");
    button.type = "button", button.className = "btn-toggle", id && (button.id = id), button.innerHTML = `
        <span class="toggle-flip"></span>
        <span class="toggle-on"></span>
        <span class="toggle-off"></span>
    `;
    let setChecked = /* @__PURE__ */ __name((isChecked) => {
      button.classList.toggle("on", isChecked), button.setAttribute("aria-checked", isChecked);
    }, "setChecked");
    return button.addEventListener("click", () => {
      let newState = !button.classList.contains("on");
      setChecked(newState), onChange && onChange(newState);
    }), setChecked(checked), button;
  }
  __name(createToggle, "createToggle");

  // src/content/core/ui/general/pill.js
  function createPill(text2, tooltipText, options = {}) {
    typeof options == "string" && (options = { type: options });
    let { type, isButton = !1 } = options;
    if (!type) {
      let pill2 = document.createElement("div"), baseClasses = "relative clip flex justify-center items-center radius-circle stroke-none padding-left-medium padding-right-medium height-800 text-label-medium bg-shift-300 content-action-utility", buttonClasses = "group/interactable focus-visible:outline-focus disabled:outline-none cursor-pointer";
      if (pill2.className = isButton ? `${baseClasses} ${buttonClasses}` : baseClasses, isButton) {
        let presentation = document.createElement("div");
        presentation.setAttribute("role", "presentation"), presentation.className = "absolute inset-[0] transition-colors group-hover/interactable:bg-[var(--color-state-hover)] group-active/interactable:bg-[var(--color-state-press)] group-disabled/interactable:bg-none", pill2.appendChild(presentation);
      }
      let content = document.createElement("span");
      return content.className = "padding-y-xsmall text-no-wrap text-truncate-end", content.textContent = text2, pill2.appendChild(content), tooltipText && addTooltip(pill2, tooltipText, { position: "top" }), pill2;
    }
    let pill = document.createElement("div");
    return pill.className = `rovalra-pill ${type}`, pill.textContent = text2, addTooltip(pill, tooltipText, { position: "top" }), pill;
  }
  __name(createPill, "createPill");

  // src/content/core/ui/general/pillToggle.js
  function createPillToggle({ options, initialValue, onChange }) {
    let container = document.createElement("div");
    container.className = "rovalra-pill-toggle bg-shift-300 radius-circle flex items-center", container.style.display = "inline-flex", container.style.gap = "var(--padding-xsmall)", container.style.padding = "2px";
    let selectedValue = initialValue, buttons = /* @__PURE__ */ new Map();
    options.forEach((option) => {
      let pillButton = createPill(option.text, option.tooltip, { isButton: !0 });
      pillButton.dataset.value = option.value, pillButton.classList.remove("bg-shift-300"), pillButton.style.backgroundColor = "transparent";
      let content = pillButton.querySelector("span");
      content && (content.style.position = "relative", content.style.zIndex = "2"), container.appendChild(pillButton), buttons.set(option.value, pillButton), pillButton.addEventListener("click", () => {
        pillButton.classList.contains("disabled") || String(selectedValue) === String(option.value) || (selectedValue = option.value, updateSelected(), onChange && onChange(selectedValue));
      });
    });
    function updateSelected() {
      for (let [value, button] of buttons.entries()) {
        let presentation = button.querySelector('div[role="presentation"]');
        String(value) === String(selectedValue) ? (button.classList.replace("content-action-utility", "content-default"), presentation.style.backgroundColor = "var(--color-surface-100)") : (button.classList.replace("content-default", "content-action-utility"), presentation.style.backgroundColor = "transparent");
      }
    }
    return __name(updateSelected, "updateSelected"), selectedValue === void 0 && options.length > 0 && (selectedValue = options[0].value), selectedValue !== void 0 && updateSelected(), container;
  }
  __name(createPillToggle, "createPillToggle");

  // src/content/features/developer/tests.js
  function removeHomeElement3() {
    let homeElementToRemove = document.querySelector("li.cursor-pointer.btr-nav-node-header_home.btr-nav-header_home");
    homeElementToRemove && homeElementToRemove.remove();
  }
  __name(removeHomeElement3, "removeHomeElement");
  async function renderTestPage(contentDiv) {
    if (window.location.pathname.toLowerCase() !== "/test") return;
    contentDiv.innerHTML = "", contentDiv.style.position = "relative";
    let headerContainer = document.createElement("div");
    headerContainer.style.marginBottom = "20px", headerContainer.style.padding = "20px 0";
    let h1 = document.createElement("h1");
    h1.textContent = "RoValra General UI Test", h1.style.fontWeight = "800", h1.style.fontSize = "2.5em", h1.style.margin = "0", headerContainer.appendChild(h1), contentDiv.appendChild(headerContainer);
    let container = document.createElement("div");
    container.style.display = "flex", container.style.gap = "20px", container.style.flexWrap = "wrap", contentDiv.appendChild(container);
    let card = createGameCard(1818);
    container.appendChild(card);
    let frecard = createGameCard(1537690962);
    container.appendChild(frecard);
    let Longcard = createGameCard(14056754882);
    container.appendChild(Longcard);
    let itemCard = createItemCard(48894692);
    container.appendChild(itemCard);
    let freeitemCard = createItemCard(3443038622);
    container.appendChild(freeitemCard);
    let limiteduitemCard = createItemCard(16477149823);
    container.appendChild(limiteduitemCard);
    let limiteditemCard = createItemCard(76233968067050);
    container.appendChild(limiteditemCard);
    let radio = createRadioButton();
    container.appendChild(radio);
    let toggle = createToggle("RoValra-Toggle");
    container.appendChild(toggle);
    let pill = createPill("Test test");
    container.appendChild(pill);
    let pillToggle = createPillToggle({
      options: [
        { text: "Option 1", value: 1 },
        { text: "Option 2", value: 2, tooltip: "A tooltip for option 2" },
        { text: "Option 3", value: 3 },
        { text: "4", value: 4 }
      ],
      initialValue: 2,
      onChange: /* @__PURE__ */ __name((value) => console.log("Pill Toggle changed to:", value), "onChange")
    });
    container.appendChild(pillToggle), removeHomeElement3();
  }
  __name(renderTestPage, "renderTestPage");
  function init11() {
    chrome.storage.local.get("eastereggslinksEnabled", (result) => {
      result.eastereggslinksEnabled && observeElement(".content#content", (cDiv) => {
        renderTestPage(cDiv);
      });
    });
  }
  __name(init11, "init");

  // src/content/features/developer/apiDocs.js
  var CAPTURED_APIS_KEY2 = "rovalra_captured_apis";
  function removeHomeElement4() {
    let homeElementToRemove = document.querySelector("li.cursor-pointer.btr-nav-node-header_home.btr-nav-header_home");
    homeElementToRemove && homeElementToRemove.remove();
  }
  __name(removeHomeElement4, "removeHomeElement");
  function renderDocsPage(contentDiv, suppressWarning = !1) {
    if (window.location.pathname.toLowerCase() !== "/docs") return;
    if (contentDiv.innerHTML = "", contentDiv.style.position = "relative", contentDiv.style.backgroundColor = "var(--rovalra-container-background-color)", contentDiv.style.minHeight = "calc(100vh - 60px)", !suppressWarning) {
      let confirmBtn = document.createElement("button");
      confirmBtn.className = "btn-primary-md", confirmBtn.textContent = "I Understand";
      let { close } = createOverlay({
        title: "Warning: Advanced Feature",
        bodyContent: `
                <div class="flex flex-col gap-medium">
                    <p>This page allows you to execute API requests.</p>
                    <p><strong>These requests are performed using your account credentials.</strong></p>
                    <p>Do not execute any requests if you do not understand what they do. Misuse of this feature could lead to unwanted changes to your account.</p>
                </div>
            `,
        actions: [confirmBtn],
        preventBackdropClose: !0
      });
      confirmBtn.onclick = () => {
        close();
      };
    }
    let container = document.createElement("div");
    container.style.padding = "20px", container.style.maxWidth = "1200px", container.style.margin = "0 auto";
    let header = document.createElement("div");
    header.style.marginBottom = "30px", header.style.borderBottom = "1px solid var(--rovalra-secondary-text-color)", header.style.paddingBottom = "20px", header.style.display = "flex", header.style.justifyContent = "space-between", header.style.alignItems = "center";
    let titleGroup = document.createElement("div"), h1 = document.createElement("h1");
    h1.textContent = "RoValra API Documentation", h1.style.fontWeight = "800", h1.style.fontSize = "2.5em", h1.style.margin = "0 0 10px 0", h1.style.color = "var(--rovalra-main-text-color)";
    let p = document.createElement("p");
    p.textContent = "Captured API requests from your current session.", p.style.color = "var(--rovalra-secondary-text-color)", p.style.margin = "0", titleGroup.appendChild(h1), titleGroup.appendChild(p);
    let headerRight = document.createElement("div");
    headerRight.style.display = "flex", headerRight.style.alignItems = "center", headerRight.style.gap = "15px";
    let dataSize = document.createElement("span");
    dataSize.style.color = "var(--rovalra-secondary-text-color)", dataSize.style.fontSize = "14px";
    let clearBtn = document.createElement("button");
    clearBtn.textContent = "Clear Data", clearBtn.className = "btn-secondary-md", clearBtn.style.padding = "8px 16px", clearBtn.style.cursor = "pointer", clearBtn.onclick = () => {
      chrome.storage.local.remove(CAPTURED_APIS_KEY2, () => {
        renderDocsPage(contentDiv, !0);
      });
    }, headerRight.appendChild(dataSize), headerRight.appendChild(clearBtn), header.appendChild(titleGroup), header.appendChild(headerRight), container.appendChild(header), contentDiv.appendChild(container), chrome.storage.local.get(CAPTURED_APIS_KEY2, (result) => {
      let data = result[CAPTURED_APIS_KEY2] || {}, size = JSON.stringify(data).length, formattedSize = "0 B";
      if (size > 0) {
        let i = Math.floor(Math.log(size) / Math.log(1024));
        formattedSize = (size / Math.pow(1024, i)).toFixed(2) + " " + ["B", "KB", "MB", "GB"][i];
      }
      dataSize.textContent = formattedSize;
      let subdomains = Object.keys(data).sort();
      if (subdomains.length === 0) {
        let emptyState = document.createElement("div");
        emptyState.style.textAlign = "center", emptyState.style.padding = "40px", emptyState.style.color = "var(--rovalra-secondary-text-color)", emptyState.innerHTML = "<h3>No API calls captured yet</h3><p>Browse Roblox to populate this list.</p>", container.appendChild(emptyState), removeHomeElement4();
        return;
      }
      let controlsContainer = document.createElement("div");
      controlsContainer.style.display = "flex", controlsContainer.style.gap = "15px", controlsContainer.style.marginBottom = "20px", controlsContainer.style.alignItems = "center", controlsContainer.style.flexWrap = "wrap";
      let activeSubdomain = subdomains[0], searchTerm = "", endpointsContainer = document.createElement("div"), renderEndpoints = /* @__PURE__ */ __name((subdomain, filter = "") => {
        endpointsContainer.innerHTML = "";
        let rawEndpoints = data[subdomain], endpoints = {};
        Object.keys(rawEndpoints).forEach((rawPath) => {
          let normalizedPath = rawPath.split("?")[0].split("/").map((segment) => /^\d+$/.test(segment) ? "{id}" : /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(segment) ? "{uuid}" : segment).join("/");
          endpoints[normalizedPath] || (endpoints[normalizedPath] = {});
          let methods = rawEndpoints[rawPath];
          Object.keys(methods).forEach((method) => {
            endpoints[normalizedPath][method] || (endpoints[normalizedPath][method] = {
              ...methods[method],
              exampleEndpoint: rawPath
            });
          });
        });
        let endpointKeys = Object.keys(endpoints).sort();
        if (filter) {
          let lowerFilter = filter.toLowerCase();
          endpointKeys = endpointKeys.filter((key) => key.toLowerCase().includes(lowerFilter));
        }
        if (endpointKeys.length === 0) {
          endpointsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--rovalra-secondary-text-color);">No endpoints found matching filter.</div>';
          return;
        }
        let groups = {};
        endpointKeys.forEach((endpoint) => {
          let parts = endpoint.split("/"), groupName = parts.length > 1 && parts[1] ? parts[1] : "General";
          groups[groupName] || (groups[groupName] = []), groups[groupName].push(endpoint);
        }), Object.keys(groups).sort().forEach((groupName) => {
          let groupEndpoints = groups[groupName], section = document.createElement("div");
          section.style.marginBottom = "20px";
          let header2 = document.createElement("div");
          header2.style.padding = "10px 15px", header2.style.backgroundColor = "rgba(128, 128, 128, 0.1)", header2.style.borderRadius = "6px", header2.style.cursor = "pointer", header2.style.display = "flex", header2.style.justifyContent = "space-between", header2.style.alignItems = "center", header2.style.marginBottom = "10px", header2.style.userSelect = "none";
          let title = document.createElement("span");
          title.textContent = groupName, title.style.fontWeight = "bold", title.style.fontSize = "18px", title.style.color = "var(--rovalra-main-text-color)";
          let count = document.createElement("span");
          count.textContent = `${groupEndpoints.length} endpoints`, count.style.fontSize = "12px", count.style.color = "var(--rovalra-secondary-text-color)", count.style.backgroundColor = "rgba(128, 128, 128, 0.1)", count.style.padding = "2px 8px", count.style.borderRadius = "10px";
          let leftSide = document.createElement("div");
          leftSide.style.display = "flex", leftSide.style.alignItems = "center", leftSide.style.gap = "10px", leftSide.appendChild(title), leftSide.appendChild(count);
          let arrow = document.createElement("span");
          arrow.textContent = "\u25BC", arrow.style.transition = "transform 0.2s", header2.appendChild(leftSide), header2.appendChild(arrow);
          let content = document.createElement("div");
          content.style.display = "block", header2.onclick = () => {
            let isCollapsed = content.style.display === "none";
            content.style.display = isCollapsed ? "block" : "none", arrow.style.transform = isCollapsed ? "rotate(0deg)" : "rotate(-90deg)";
          }, section.appendChild(header2), section.appendChild(content), endpointsContainer.appendChild(section), groupEndpoints.forEach((endpoint) => {
            let methods = endpoints[endpoint];
            Object.keys(methods).forEach((method) => {
              let details = methods[method], card = document.createElement("div");
              card.style.marginBottom = "15px", card.style.borderRadius = "4px", card.style.overflow = "hidden", card.style.border = "1px solid";
              let color = "#888", bg = "#eee";
              switch (method) {
                case "GET":
                  color = "#61affe", bg = "rgba(97, 175, 254, 0.1)";
                  break;
                case "POST":
                  color = "#49cc90", bg = "rgba(73, 204, 144, 0.1)";
                  break;
                case "PUT":
                  color = "#fca130", bg = "rgba(252, 161, 48, 0.1)";
                  break;
                case "DELETE":
                  color = "#f93e3e", bg = "rgba(249, 62, 62, 0.1)";
                  break;
                case "PATCH":
                  color = "#50e3c2", bg = "rgba(80, 227, 194, 0.1)";
                  break;
              }
              card.style.borderColor = color;
              let cardHeader = document.createElement("div");
              cardHeader.style.backgroundColor = bg, cardHeader.style.padding = "10px 15px", cardHeader.style.display = "flex", cardHeader.style.alignItems = "center", cardHeader.style.cursor = "pointer", cardHeader.style.userSelect = "none";
              let methodBadge = document.createElement("span");
              methodBadge.textContent = method, methodBadge.style.backgroundColor = color, methodBadge.style.color = "#fff", methodBadge.style.padding = "6px 15px", methodBadge.style.borderRadius = "3px", methodBadge.style.fontWeight = "700", methodBadge.style.fontSize = "14px", methodBadge.style.minWidth = "80px", methodBadge.style.textAlign = "center", methodBadge.style.marginRight = "15px";
              let pathSpan = document.createElement("span");
              pathSpan.textContent = endpoint, pathSpan.style.fontFamily = "monospace", pathSpan.style.fontSize = "16px", pathSpan.style.color = "var(--rovalra-main-text-color)", pathSpan.style.wordBreak = "break-all", cardHeader.appendChild(methodBadge), cardHeader.appendChild(pathSpan);
              let cardBody = document.createElement("div");
              cardBody.style.display = "none", cardBody.style.padding = "20px", cardBody.style.backgroundColor = "var(--rovalra-container-background-color)", cardBody.style.borderTop = `1px solid ${color}`;
              let tryItOutTitle = document.createElement("h4");
              tryItOutTitle.textContent = "Try it out", tryItOutTitle.style.marginTop = "0", cardBody.appendChild(tryItOutTitle);
              let urlInput = document.createElement("input");
              urlInput.type = "text";
              let baseUrl = subdomain === "rovalra.com" ? "https://apis.rovalra.com" : `https://${subdomain}.roblox.com`;
              urlInput.value = baseUrl + (details.exampleEndpoint || endpoint), urlInput.className = "form-control input-field", urlInput.style.width = "100%", urlInput.style.marginBottom = "10px", urlInput.style.fontFamily = "monospace", cardBody.appendChild(urlInput);
              let bodyInput = null;
              if (method !== "GET" && method !== "HEAD") {
                let bodyLabel = document.createElement("div");
                bodyLabel.textContent = "Request Body (JSON):", bodyLabel.style.marginBottom = "5px", bodyLabel.style.fontWeight = "bold", cardBody.appendChild(bodyLabel), bodyInput = document.createElement("textarea"), bodyInput.className = "form-control input-field", bodyInput.style.width = "100%", bodyInput.style.minHeight = "100px", bodyInput.style.fontFamily = "monospace", bodyInput.style.marginBottom = "10px", details.exampleBody && (bodyInput.value = typeof details.exampleBody == "string" ? details.exampleBody : JSON.stringify(details.exampleBody, null, 2)), cardBody.appendChild(bodyInput);
              }
              let executeBtn = document.createElement("button");
              executeBtn.textContent = "Execute", executeBtn.className = "btn-primary-md", executeBtn.style.marginRight = "10px", subdomain === "rovalra.com" && endpoint.includes("/process_servers") && (executeBtn.disabled = !0, executeBtn.textContent = "Execution Disabled", executeBtn.className = "btn-control-md", executeBtn.style.opacity = "0.6");
              let responseContainer = document.createElement("div");
              responseContainer.style.marginTop = "15px", responseContainer.style.display = "none", executeBtn.onclick = async () => {
                responseContainer.style.display = "block", responseContainer.innerHTML = "Loading...";
                try {
                  let targetUrl = urlInput.value, targetEndpoint = targetUrl;
                  try {
                    let u3 = new URL(targetUrl);
                    targetEndpoint = u3.pathname + u3.search;
                  } catch {
                  }
                  let reqOptions = {
                    subdomain: subdomain === "rovalra.com" ? "apis" : subdomain,
                    endpoint: targetEndpoint,
                    method,
                    isRovalraApi: subdomain === "rovalra.com"
                  };
                  if (bodyInput && bodyInput.value)
                    try {
                      reqOptions.body = JSON.parse(bodyInput.value);
                    } catch {
                      reqOptions.body = bodyInput.value;
                    }
                  let response = await callRobloxApi(reqOptions), statusColor = response.ok ? "#49cc90" : "#f93e3e", responseText = "";
                  try {
                    let json = await response.json();
                    responseText = JSON.stringify(json, null, 2);
                  } catch {
                    responseText = await response.text();
                  }
                  let safeStatusText = purify.sanitize(response.statusText), safeResponseText = purify.sanitize(responseText);
                  responseContainer.innerHTML = `
                                <div style="margin-bottom: 5px;"><strong>Status:</strong> <span style="color: ${statusColor}; font-weight: bold;">${response.status} ${safeStatusText}</span></div>
                                <pre style="background: rgba(0,0,0,0.1); padding: 10px; border-radius: 4px; overflow: auto; max-height: 400px;">${safeResponseText}</pre>
                            `;
                } catch (err) {
                  responseContainer.innerHTML = `<div style="color: #f93e3e;">Error: ${err.message}</div>`;
                }
              }, cardBody.appendChild(executeBtn), cardBody.appendChild(responseContainer), cardHeader.onclick = () => {
                cardBody.style.display = cardBody.style.display === "none" ? "block" : "none";
              }, card.appendChild(cardHeader), card.appendChild(cardBody), content.appendChild(card);
            });
          });
        });
      }, "renderEndpoints"), dropdownItems = subdomains.map((sub) => ({
        label: sub === "rovalra.com" ? "apis.rovalra.com" : `${sub}.roblox.com`,
        value: sub
      })), { element: dropdownElement } = createDropdown({
        items: dropdownItems,
        initialValue: activeSubdomain,
        onValueChange: /* @__PURE__ */ __name((value) => {
          activeSubdomain = value, renderEndpoints(activeSubdomain, searchTerm);
        }, "onValueChange")
      });
      dropdownElement.style.minWidth = "250px", dropdownElement.style.zIndex = "10";
      let searchInput = document.createElement("input");
      searchInput.type = "text", searchInput.placeholder = "Search endpoints...", searchInput.className = "form-control input-field", searchInput.style.flex = "1", searchInput.style.minWidth = "200px", searchInput.style.padding = "8px 12px", searchInput.style.backgroundColor = "var(--rovalra-container-background-color)", searchInput.style.border = "1px solid var(--rovalra-secondary-text-color)", searchInput.style.color = "var(--rovalra-main-text-color)", searchInput.style.borderRadius = "8px", searchInput.style.height = "38px", searchInput.addEventListener("input", (e) => {
        searchTerm = e.target.value, renderEndpoints(activeSubdomain, searchTerm);
      }), controlsContainer.appendChild(dropdownElement), controlsContainer.appendChild(searchInput), container.appendChild(controlsContainer), container.appendChild(endpointsContainer), renderEndpoints(activeSubdomain);
    }), removeHomeElement4();
  }
  __name(renderDocsPage, "renderDocsPage");
  function init12() {
    window.location.pathname.toLowerCase() === "/docs" && chrome.storage.local.get("EnableRobloxApiDocs", (result) => {
      if (!result.EnableRobloxApiDocs) return;
      let contentDiv = document.querySelector(".content#content");
      contentDiv ? renderDocsPage(contentDiv) : observeElement(".content#content", (cDiv) => {
        renderDocsPage(cDiv);
      });
    });
  }
  __name(init12, "init");

  // src/content/core/utils/trackers/servers.js
  var latestPresence = null, subscribers = /* @__PURE__ */ new Set();
  function broadcast(presence) {
    subscribers.forEach((callback) => callback(presence));
  }
  __name(broadcast, "broadcast");
  chrome.runtime.onMessage.addListener((request) => {
    if (request.action === "presenceUpdate") {
      let presence = request.presence;
      JSON.stringify(presence) !== JSON.stringify(latestPresence) && (latestPresence = presence, broadcast(presence));
    }
  });
  function init13() {
    chrome.storage.local.get({ recentServersEnabled: !0 }, (settings) => {
      if (!settings.recentServersEnabled) return;
      let currentUserElement = document.querySelector('meta[name="user-data"]'), currentUserId = currentUserElement ? currentUserElement.dataset.userid : null;
      currentUserId && chrome.runtime.sendMessage({ action: "updateUserId", userId: currentUserId }), chrome.runtime.sendMessage({ action: "getLatestPresence" }, (response) => {
        chrome.runtime.lastError || response && response.presence && (latestPresence = response.presence, broadcast(latestPresence));
      });
    });
  }
  __name(init13, "init");

  // src/content/features/navigation/QoLToggles.js
  function init14() {
    chrome.storage.local.get({ qolTogglesEnabled: !0 }, (settings) => {
      if (!settings.qolTogglesEnabled)
        return;
      (/* @__PURE__ */ __name(async () => {
        if (document.getElementById("rovalra-qol-toggle")) return;
        let assets3 = getAssets(), button = await createNavbarButton({
          id: "rovalra-qol-toggle",
          iconSvgData: assets3.qolIcon
        });
        if (!button) return;
        let permissionLevels = {
          AllUsers: 4,
          All: 4,
          FriendsFollowingAndFollowers: 3,
          Followers: 3,
          FriendsAndFollowing: 2,
          Following: 2,
          Friends: 1,
          NoOne: 0
        }, onlineToJoinMap = {
          AllUsers: "All",
          FriendsFollowingAndFollowers: "Followers",
          FriendsAndFollowing: "Following",
          Friends: "Friends",
          NoOne: "NoOne"
        }, joinToOnlineMap = {
          All: "AllUsers",
          Followers: "FriendsFollowingAndFollowers",
          Following: "FriendsAndFollowing",
          Friends: "Friends",
          NoOne: "NoOne"
        }, currentOnlineStatus = "AllUsers", currentJoinStatus = "AllUsers";
        try {
          let response = await callRobloxApi({
            subdomain: "apis",
            endpoint: "/user-settings-api/v1/user-settings/settings-and-options"
          });
          if (response.ok) {
            let data = await response.json();
            data.whoCanSeeMyOnlineStatus?.currentValue && (currentOnlineStatus = data.whoCanSeeMyOnlineStatus.currentValue), data.whoCanJoinMeInExperiences?.currentValue && (currentJoinStatus = data.whoCanJoinMeInExperiences.currentValue);
          }
        } catch (e) {
          console.warn("RoValra: Failed to fetch online status", e);
        }
        currentJoinStatus = onlineToJoinMap[currentJoinStatus] || currentJoinStatus, chrome.storage.local.get([], (data) => {
          let labelMap = {
            onlineStatus: "Online Status",
            joinStatus: "Experience Status"
          }, menu = createDropdownMenu({
            trigger: button,
            items: [
              { label: labelMap.onlineStatus, value: "onlineStatus" },
              { label: labelMap.joinStatus, value: "joinStatus" }
            ],
            onValueChange: /* @__PURE__ */ __name(() => {
            }, "onValueChange"),
            position: "center"
          });
          menu.panel.style.transform = "translateX(-50%)", menu.panel.style.setProperty("min-width", "200px", "important");
          let updatePosition = /* @__PURE__ */ __name(() => {
            button.offsetWidth > 0 && (menu.panel.style.marginLeft = `${button.offsetWidth / 2}px`);
          }, "updatePosition");
          button.addEventListener("click", updatePosition), updatePosition(), menu.panel.querySelectorAll(".rovalra-dropdown-item").forEach((btn) => {
            let value = btn.dataset.value;
            if (!value) return;
            let div = document.createElement("div");
            for (div.className = btn.className, div.setAttribute("role", "option"), div.setAttribute("data-value", value); btn.firstChild; )
              div.appendChild(btn.firstChild);
            if (value === "onlineStatus" || value === "joinStatus") {
              let isOnlineStatus = value === "onlineStatus", statusOptions = [
                { label: "Everyone", value: isOnlineStatus ? "AllUsers" : "All" },
                { label: "Connections, Followers, & Following", value: isOnlineStatus ? "FriendsFollowingAndFollowers" : "Followers" },
                { label: "Connections & Following", value: isOnlineStatus ? "FriendsAndFollowing" : "Following" },
                { label: "Connections", value: "Friends" },
                { label: "No one", value: "NoOne" }
              ], initialValue = isOnlineStatus ? currentOnlineStatus : currentJoinStatus, { element: statusDropdown, setValue } = createDropdown({
                items: statusOptions,
                initialValue,
                onValueChange: /* @__PURE__ */ __name((newValue) => {
                  callRobloxApi({
                    subdomain: "apis",
                    endpoint: "/user-settings-api/v1/user-settings",
                    method: "POST",
                    body: isOnlineStatus ? { whoCanSeeMyOnlineStatus: newValue } : { whoCanJoinMeInExperiences: newValue }
                  }).catch((e) => console.error("Failed to update status", e));
                  let onlineDropdownEl = document.getElementById("rovalra-qol-onlineStatus-dropdown"), joinDropdownEl = document.getElementById("rovalra-qol-joinStatus-dropdown");
                  if (isOnlineStatus) {
                    currentOnlineStatus = newValue;
                    let onlineLevel = permissionLevels[currentOnlineStatus], joinLevel = permissionLevels[currentJoinStatus];
                    if (onlineLevel < joinLevel) {
                      let newJoinValue = onlineToJoinMap[currentOnlineStatus];
                      joinDropdownEl && joinDropdownEl.rovalraSetValue && (joinDropdownEl.rovalraSetValue(newJoinValue), currentJoinStatus = newJoinValue, callRobloxApi({
                        subdomain: "apis",
                        endpoint: "/user-settings-api/v1/user-settings",
                        method: "POST",
                        body: { whoCanJoinMeInExperiences: newJoinValue }
                      }).catch((e) => console.error("Failed to update join status", e)));
                    }
                  } else {
                    currentJoinStatus = newValue;
                    let joinLevel = permissionLevels[currentJoinStatus], onlineLevel = permissionLevels[currentOnlineStatus];
                    if (joinLevel > onlineLevel) {
                      let newOnlineValue = joinToOnlineMap[currentJoinStatus];
                      onlineDropdownEl && onlineDropdownEl.rovalraSetValue && (onlineDropdownEl.rovalraSetValue(newOnlineValue), currentOnlineStatus = newOnlineValue, callRobloxApi({
                        subdomain: "apis",
                        endpoint: "/user-settings-api/v1/user-settings",
                        method: "POST",
                        body: { whoCanSeeMyOnlineStatus: newOnlineValue }
                      }).catch((e) => console.error("Failed to update online status", e)));
                    }
                  }
                  if (isOnlineStatus && newValue === "NoOne" && joinDropdownEl && joinDropdownEl.rovalraSetValue) {
                    let joinDropdownEl2 = document.getElementById("rovalra-qol-joinStatus-dropdown");
                    joinDropdownEl2 && joinDropdownEl2.rovalraSetValue && (joinDropdownEl2.rovalraSetValue("NoOne"), callRobloxApi({
                      subdomain: "apis",
                      endpoint: "/user-settings-api/v1/user-settings",
                      method: "POST",
                      body: { whoCanJoinMeInExperiences: "NoOne" }
                    }).catch((e) => console.error("Failed to update join status", e)));
                  }
                }, "onValueChange")
              });
              statusDropdown.id = `rovalra-qol-${value}-dropdown`, statusDropdown.rovalraSetValue = setValue, statusDropdown.style.marginLeft = "auto", statusDropdown.style.minWidth = "140px", statusDropdown.style.maxWidth = "140px", statusDropdown.addEventListener("click", (e) => e.stopPropagation());
              let trigger = statusDropdown.querySelector(".rovalra-dropdown-trigger");
              trigger && (trigger.style.height = "30px", trigger.style.minHeight = "30px", trigger.style.padding = "0 8px", trigger.style.fontSize = "12px", trigger.style.minWidth = "100%");
              let textWrapper = div.querySelector(".text-truncate-split.flex.flex-col");
              textWrapper && textWrapper.appendChild(statusDropdown);
            } else {
              let radio = createRadioButton({
                id: `rovalra-qol-${value}`,
                checked: !!data[value],
                onChange: /* @__PURE__ */ __name((newState) => {
                  chrome.storage.local.set({ [value]: newState });
                }, "onChange")
              });
              radio.style.marginLeft = "auto";
              let textWrapper = div.querySelector(".text-truncate-split.flex.flex-col");
              textWrapper && textWrapper.appendChild(radio), div.addEventListener("click", () => {
                let currentChecked = radio.getAttribute("aria-checked") === "true";
                radio.setChecked(!currentChecked), chrome.storage.local.set({ [value]: !currentChecked });
              });
            }
            btn.parentNode.replaceChild(div, btn);
          });
        });
      }, "addQoLButton"))();
    });
  }
  __name(init14, "init");

  // src/content/features/sitewide/copyid.js
  function init15() {
    chrome.runtime.onMessage.addListener((request) => {
      request.action === "copyToClipboard" && request.text && navigator.clipboard.writeText(request.text).catch((err) => {
        console.error("RoValra: Failed to copy ID", err);
      });
    }), document.addEventListener(
      "mousedown",
      (e) => {
        if (e.button !== 2) return;
        let link = e.target.closest("a"), ids = [];
        if (link) {
          let url = link.href, bundleMatch = url.match(/\/bundles\/(\d+)/), catalogMatch = url.match(/\/catalog\/(\d+)/), gamePassMatch = url.match(/\/game-pass\/(\d+)/), badgeMatch = url.match(/\/badges\/(\d+)/), groupMatch = url.match(/\/(?:groups|communities)\/(\d+)/), eventMatch = url.match(/\/events\/(\d+)/), devProductMatch = url.match(/\/developer-product\/\d+\/product\/(\d+)/);
          if (bundleMatch)
            ids.push({ type: "Bundle", id: bundleMatch[1] });
          else if (catalogMatch)
            ids.push({ type: "Asset", id: catalogMatch[1] });
          else if (gamePassMatch)
            ids.push({ type: "GamePass", id: gamePassMatch[1] });
          else if (badgeMatch)
            ids.push({ type: "Badge", id: badgeMatch[1] });
          else if (groupMatch)
            ids.push({ type: "Community", id: groupMatch[1] });
          else if (eventMatch)
            ids.push({ type: "Event", id: eventMatch[1] });
          else if (devProductMatch)
            ids.push({ type: "Developer Product", id: devProductMatch[1] });
          else {
            let placeId = getPlaceIdFromUrl(url);
            placeId && (ids.push({ type: "Place", id: placeId }), ids.push({ type: "Universe", id: placeId }));
            let assetId = getAssetIdFromUrl(url);
            assetId && ids.push({ type: "Asset", id: assetId });
          }
          let userId = getUserIdFromUrl(url);
          userId && ids.push({ type: "User", id: userId });
        }
        chrome.runtime.sendMessage({
          action: "updateContextMenu",
          ids
        });
      },
      { capture: !0 }
    );
  }
  __name(init15, "init");

  // src/content/core/utils/rbxm.js
  var RBXM_SIGNATURE = "<roblox!", PROP_TYPES = {
    STRING: 1,
    BOOL: 2,
    INT: 3,
    FLOAT: 4,
    DOUBLE: 5,
    UDIM: 6,
    UDIM2: 7,
    RAY: 8,
    FACES: 9,
    AXES: 10,
    BRICKCOLOR: 11,
    COLOR3: 12,
    VECTOR2: 13,
    VECTOR3: 14,
    CFRAME: 16,
    ENUM: 19,
    REF: 20,
    INT64: 21,
    SHARED_STRING: 22,
    OPTIONAL: 26
  }, ByteReader = class {
    static {
      __name(this, "ByteReader");
    }
    constructor(buffer) {
      this.buffer = buffer, this.view = new DataView(buffer), this.index = 0;
    }
    jump(count) {
      this.index += count;
    }
    readUInt8() {
      return this.view.getUint8(this.index++);
    }
    readUInt32LE() {
      let val = this.view.getUint32(this.index, !0);
      return this.index += 4, val;
    }
    readInt32LE() {
      let val = this.view.getInt32(this.index, !0);
      return this.index += 4, val;
    }
    readString(len) {
      let bytes = new Uint8Array(this.buffer, this.index, len);
      return this.index += len, new TextDecoder().decode(bytes);
    }
    readBytes(len) {
      let bytes = new Uint8Array(this.buffer, this.index, len);
      return this.index += len, bytes;
    }
    getRemaining() {
      return this.buffer.byteLength - this.index;
    }
    readInterleavedInt32Array(count) {
      let values = new Int32Array(count);
      if (count === 0) return values;
      let byteCount = count * 4, rawBytes = new Uint8Array(this.buffer, this.index, byteCount);
      this.index += byteCount;
      for (let i = 0; i < count; i++) {
        let b1 = rawBytes[i], b2 = rawBytes[i + count], b3 = rawBytes[i + count * 2], b4 = rawBytes[i + count * 3];
        values[i] = b1 | b2 << 8 | b3 << 16 | b4 << 24;
      }
      return values;
    }
    readInterleavedFloatArray(count) {
      let intValues = this.readInterleavedInt32Array(count);
      return new Float32Array(intValues.buffer);
    }
  };
  function decompressLz4(input, outputSize) {
    let output = new Uint8Array(outputSize), i = 0, j2 = 0;
    for (; i < input.length; ) {
      let token = input[i++], literalLength = token >> 4;
      if (literalLength > 0) {
        if (literalLength === 15) {
          let lenByte;
          do
            lenByte = input[i++], literalLength += lenByte;
          while (lenByte === 255);
        }
        for (let l = 0; l < literalLength; l++)
          output[j2++] = input[i++];
      }
      if (i >= input.length) break;
      let offset = input[i++] | input[i++] << 8, matchLength = (token & 15) + 4;
      if (matchLength === 19) {
        let lenByte;
        do
          lenByte = input[i++], matchLength += lenByte;
        while (lenByte === 255);
      }
      let pos = j2 - offset;
      for (let m2 = 0; m2 < matchLength; m2++)
        output[j2++] = output[pos++];
    }
    return output.buffer;
  }
  __name(decompressLz4, "decompressLz4");
  function parseRbxm(buffer) {
    try {
      let reader = new ByteReader(buffer);
      if (reader.readString(8) !== RBXM_SIGNATURE) return [];
      reader.jump(8), reader.readUInt32LE(), reader.readUInt32LE(), reader.jump(8);
      let instances = /* @__PURE__ */ new Map(), classMetadata = /* @__PURE__ */ new Map(), roots = [];
      for (; reader.getRemaining() > 4; ) {
        let chunkType = reader.readString(4);
        if (chunkType === "END\0") break;
        let compressedLength = reader.readUInt32LE(), decompressedLength = reader.readUInt32LE();
        reader.jump(4);
        let chunkData = reader.readBytes(compressedLength), dataBuffer;
        compressedLength === 0 ? dataBuffer = chunkData.buffer.slice(chunkData.byteOffset, chunkData.byteOffset + decompressedLength) : dataBuffer = decompressLz4(chunkData, decompressedLength);
        let chunkReader = new ByteReader(dataBuffer);
        if (chunkType === "INST") {
          let classId = chunkReader.readUInt32LE(), classNameLen = chunkReader.readUInt32LE(), className = chunkReader.readString(classNameLen), isService = chunkReader.readUInt8(), count = chunkReader.readUInt32LE(), ids = chunkReader.readInterleavedInt32Array(count), realIds = [], currentId = 0;
          for (let i = 0; i < count; i++)
            currentId += ids[i], realIds.push(currentId);
          classMetadata.set(classId, { className, instanceIds: realIds }), realIds.forEach((id) => {
            instances.set(id, {
              ClassName: className,
              Reference: id.toString(),
              Properties: {},
              Children: []
            });
          });
        } else if (chunkType === "PROP") {
          let classId = chunkReader.readUInt32LE(), propNameLen = chunkReader.readUInt32LE(), propName = chunkReader.readString(propNameLen), propType = chunkReader.readUInt8(), classData = classMetadata.get(classId);
          if (!classData) continue;
          let instanceIds = classData.instanceIds, count = instanceIds.length;
          if (propType === PROP_TYPES.STRING)
            for (let i = 0; i < count; i++) {
              let len = chunkReader.readUInt32LE(), val = chunkReader.readString(len);
              instances.get(instanceIds[i]).Properties[propName] = val;
            }
          else if (propType === PROP_TYPES.BOOL)
            for (let i = 0; i < count; i++) {
              let val = chunkReader.readUInt8() === 1;
              instances.get(instanceIds[i]).Properties[propName] = val;
            }
          else if (propType === PROP_TYPES.FLOAT) {
            let values = chunkReader.readInterleavedFloatArray(count);
            for (let i = 0; i < count; i++)
              instances.get(instanceIds[i]).Properties[propName] = values[i];
          } else if (propType === PROP_TYPES.DOUBLE)
            for (let i = 0; i < count; i++)
              ;
          else if (propType === PROP_TYPES.INT || propType === PROP_TYPES.ENUM) {
            let values = chunkReader.readInterleavedInt32Array(count);
            for (let i = 0; i < count; i++)
              instances.get(instanceIds[i]).Properties[propName] = values[i];
          }
        } else if (chunkType === "PRNT") {
          let version = chunkReader.readUInt8(), count = chunkReader.readUInt32LE(), childIdsDelta = chunkReader.readInterleavedInt32Array(count), parentIdsDelta = chunkReader.readInterleavedInt32Array(count), childId = 0, parentId = 0;
          for (let i = 0; i < count; i++) {
            childId += childIdsDelta[i], parentId += parentIdsDelta[i];
            let childObj = instances.get(childId), parentObj = instances.get(parentId);
            childObj && parentObj && parentObj.Children.push(childObj);
          }
        }
      }
      let childrenRefs = /* @__PURE__ */ new Set();
      return instances.forEach((inst) => {
        inst.Children.forEach((child) => childrenRefs.add(child.Reference));
      }), instances.forEach((inst, ref) => {
        childrenRefs.has(ref.toString()) || roots.push(inst);
      }), roots;
    } catch (e) {
      return console.error("[Rovalra RBXM Parser] Failed:", e), [];
    }
  }
  __name(parseRbxm, "parseRbxm");

  // src/content/core/utils/assetStreamer.js
  var RBXM_SIGNATURE_BYTES = [60, 114, 111, 98, 108, 111, 120, 33];
  function isBinaryFormat(buffer) {
    if (buffer.byteLength < 8) return !1;
    let signatureBytes = new Uint8Array(buffer, 0, 8);
    for (let i = 0; i < RBXM_SIGNATURE_BYTES.length; i++)
      if (signatureBytes[i] !== RBXM_SIGNATURE_BYTES[i]) return !1;
    return !0;
  }
  __name(isBinaryFormat, "isBinaryFormat");
  function parseRobloxXml(textContent) {
    let robloxNode = new DOMParser().parseFromString(textContent, "text/xml").getElementsByTagName("roblox")[0];
    if (!robloxNode) return [];
    let resultTree = [], parseItem = /* @__PURE__ */ __name((node) => {
      let className = node.getAttribute("class"), reference = node.getAttribute("refer"), instance = {
        ClassName: className,
        Reference: reference,
        Properties: {},
        Children: []
      };
      for (let child of node.children)
        if (child.tagName === "Properties")
          for (let prop of child.children) {
            let propName = prop.getAttribute("name");
            prop.tagName === "string" || prop.tagName === "ProtectedString" || prop.tagName === "BinaryString" ? instance.Properties[propName] = prop.textContent : prop.tagName === "float" || prop.tagName === "double" || prop.tagName === "int" || prop.tagName === "int64" ? instance.Properties[propName] = Number(prop.textContent) : prop.tagName === "bool" ? instance.Properties[propName] = prop.textContent === "true" : instance.Properties[propName] = prop.textContent;
          }
        else child.tagName === "Item" && instance.Children.push(parseItem(child));
      return instance;
    }, "parseItem");
    for (let child of robloxNode.children)
      child.tagName === "Item" && resultTree.push(parseItem(child));
    return resultTree;
  }
  __name(parseRobloxXml, "parseRobloxXml");
  async function checkAssetsInBatch(assetIds) {
    if (assetIds.length === 0) return [];
    let createDefaultResult = /* @__PURE__ */ __name((id) => ({ assetId: id, root: null, format: null, isValid: !1 }), "createDefaultResult"), requestBody = assetIds.map((id) => ({
      assetId: id,
      requestId: id.toString()
    }));
    try {
      let batchApiResponse = await callRobloxApi({
        subdomain: "assetdelivery",
        endpoint: "/v2/assets/batch",
        method: "POST",
        body: requestBody,
        sanitize: !1
      });
      if (!batchApiResponse.ok)
        return console.error(`[Rovalra Asset Parser] AssetDelivery batch API failed: ${batchApiResponse.status}`), assetIds.map((id) => createDefaultResult(id));
      let batchData = await batchApiResponse.json(), assetUrlMap = /* @__PURE__ */ new Map();
      batchData.forEach((item) => {
        item.locations && item.locations[0] && item.locations[0].location && assetUrlMap.set(parseInt(item.requestId, 10), item.locations[0].location);
      });
      let processingPromises = assetIds.map(async (id) => {
        let assetUrl = assetUrlMap.get(id);
        if (!assetUrl) return createDefaultResult(id);
        try {
          let response = await fetch(assetUrl);
          if (!response.ok) return createDefaultResult(id);
          let buffer = await response.arrayBuffer(), parsedRoot = null, format = null;
          if (isBinaryFormat(buffer))
            format = "RBXM", parsedRoot = parseRbxm(buffer);
          else {
            format = "XML";
            let text2 = new TextDecoder("utf-8").decode(buffer);
            text2.includes("<roblox") && (parsedRoot = parseRobloxXml(text2));
          }
          return parsedRoot ? {
            assetId: id,
            root: parsedRoot,
            format,
            isValid: !0
          } : createDefaultResult(id);
        } catch (error) {
          return console.error(`[Rovalra Asset Parser] Error parsing asset ${id}:`, error), createDefaultResult(id);
        }
      });
      return Promise.all(processingPromises);
    } catch (error) {
      return console.error("[Rovalra Asset Parser] Critical error:", error), assetIds.map((id) => createDefaultResult(id));
    }
  }
  __name(checkAssetsInBatch, "checkAssetsInBatch");

  // src/content/core/ui/catalog/input.js
  function createStyledInput({ id, label = "", placeholder = " " }) {
    let container = document.createElement("div");
    container.className = "rovalra-catalog-input-wrapper";
    let inputBase = document.createElement("div");
    inputBase.className = "rovalra-catalog-input-base";
    let input = document.createElement("input");
    input.type = "text", input.id = id, input.name = id, input.className = "rovalra-catalog-input-field", input.placeholder = placeholder, input.setAttribute("autocomplete", "off"), input.setAttribute("autocorrect", "off"), input.setAttribute("autocapitalize", "off"), input.setAttribute("spellcheck", "false"), input.setAttribute("data-lpignore", "true"), input.setAttribute("data-1p-ignore", "true"), input.setAttribute("data-bwignore", "true"), input.setAttribute("data-form-type", "other");
    let labelElement = document.createElement("label");
    labelElement.htmlFor = id, labelElement.className = "rovalra-catalog-input-label", labelElement.textContent = label;
    let fieldset = document.createElement("fieldset");
    fieldset.setAttribute("aria-hidden", "true"), fieldset.className = "rovalra-catalog-input-fieldset";
    let legend = document.createElement("legend");
    legend.className = "rovalra-catalog-input-legend", legend.innerHTML = safeHtml`<span>${label || "&#8203;"}</span>`, fieldset.appendChild(legend);
    let checkShrink = /* @__PURE__ */ __name(() => {
      input.value || input.classList.contains("Mui-focused") ? labelElement.classList.add("MuiInputLabel-shrink") : labelElement.classList.remove("MuiInputLabel-shrink");
    }, "checkShrink");
    return input.addEventListener("focus", () => {
      labelElement.classList.add("Mui-focused"), inputBase.classList.add("Mui-focused"), container.classList.add("Mui-focused"), input.classList.add("Mui-focused"), checkShrink();
    }), input.addEventListener("blur", () => {
      labelElement.classList.remove("Mui-focused"), container.classList.remove("Mui-focused"), inputBase.classList.remove("Mui-focused"), input.classList.remove("Mui-focused"), checkShrink();
    }), input.addEventListener("input", checkShrink), inputBase.append(input, fieldset), container.append(labelElement, inputBase), checkShrink(), { container, input, label: labelElement };
  }
  __name(createStyledInput, "createStyledInput");

  // src/content/core/ui/FiltersUI.js
  function injectStyles() {
    if (document.getElementById("rovalra-filters-ui-styles")) return;
    let style = document.createElement("style");
    style.id = "rovalra-filters-ui-styles", style.textContent = `
        #rovalra-fx-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
        }
        #rovalra-fx-dropdown[data-state="open"] {
            display: block;
        }
    `, document.head.appendChild(style);
  }
  __name(injectStyles, "injectStyles");
  function createAvatarFilterUI({ avatarFiltersEnabled, searchbarEnabled, onApply, onSearch, filterConfig = [] }) {
    injectStyles();
    let container = document.createElement("div");
    if (container.id = "rovalra-fx-container", Object.assign(container.style, {
      display: "flex",
      alignItems: "center",
      gap: "12px",
      marginBottom: "12px",
      flexWrap: "nowrap"
    }), avatarFiltersEnabled) {
      let createFilterRow = function(config) {
        let row = document.createElement("div");
        row.className = "flex items-center justify-between";
        let label = document.createElement("label");
        label.className = "text-body", label.textContent = config.label, row.appendChild(label);
        let inputControl;
        switch (config.type) {
          case "text":
          case "number": {
            let { container: styledInputContainer, input: styledInput } = createStyledInput({
              id: config.id,
              label: config.label,
              placeholder: config.placeholder || " "
            });
            styledInput.type = config.type, config.type === "number" && styledInput.addEventListener("keydown", (e) => {
              ["e", "E"].includes(e.key) && e.preventDefault();
            }), config.min !== void 0 && (styledInput.min = config.min), label.remove(), styledInputContainer.style.width = "100%", inputControl = styledInputContainer;
            break;
          }
          case "toggle":
            inputControl = createRadioButton({
              id: config.id,
              onChange: /* @__PURE__ */ __name((isChecked) => {
                config.onChange && config.onChange(isChecked), config.isMaster && config.controls?.forEach((controlledId) => {
                  let controlledElement = document.getElementById(controlledId);
                  controlledElement && (controlledElement.style.display = isChecked ? "flex" : "none");
                });
              }, "onChange")
            });
            break;
          case "dropdown":
            let { element: dropdownElement, setValue } = createDropdown({
              items: config.options,
              initialValue: config.initialValue,
              onValueChange: /* @__PURE__ */ __name((value) => {
                let hiddenSelect2 = document.getElementById(config.id);
                hiddenSelect2 && (hiddenSelect2.value = value, hiddenSelect2.dispatchEvent(new Event("change", { bubbles: !0 })));
              }, "onValueChange")
            }), hiddenSelect = document.createElement("select");
            hiddenSelect.id = config.id, hiddenSelect.style.display = "none", config.options.forEach((opt) => {
              let option = document.createElement("option");
              option.value = opt.value, hiddenSelect.appendChild(option);
            }), dropdownElement.appendChild(hiddenSelect), inputControl = dropdownElement, inputControl.style.flexShrink = "0";
            break;
          case "color":
            let controlsContainer = document.createElement("div");
            controlsContainer.className = "flex items-center gap-small";
            let colorPicker = document.createElement("input");
            colorPicker.type = "color", colorPicker.id = config.colorPickerId, colorPicker.value = config.defaultValue || "#000000", colorPicker.className = "input-field", Object.assign(colorPicker.style, { width: "40px", height: "30px", padding: "2px", minWidth: "40px", border: "none", background: "none" });
            let colorToggle = createRadioButton({ id: config.id });
            colorPicker.addEventListener("input", () => {
              colorToggle.getAttribute("aria-checked") !== "true" && colorToggle.setChecked(!0);
            }), controlsContainer.append(colorPicker, colorToggle), inputControl = controlsContainer;
            break;
        }
        return inputControl && row.appendChild(inputControl), row;
      };
      __name(createFilterRow, "createFilterRow");
      let buttonWrapper = document.createElement("div");
      buttonWrapper.style.position = "relative";
      let toggleButton = document.createElement("button");
      toggleButton.id = "rovalra-fx-toggle-btn", toggleButton.type = "button", toggleButton.className = "rovalra-dropdown-trigger relative clip group/interactable focus-visible:outline-focus disabled:outline-none flex items-center justify-between width-full bg-none stroke-standard radius-medium height-1000 padding-x-medium text-body-medium stroke-default content-default";
      let triggerPresentationDiv = document.createElement("div");
      triggerPresentationDiv.setAttribute("role", "presentation"), triggerPresentationDiv.className = "absolute inset-[0] transition-colors group-hover/interactable:bg-[var(--color-state-hover)] group-active/interactable:bg-[var(--color-state-press)] group-disabled/interactable:bg-none";
      let triggerValue = document.createElement("span");
      triggerValue.className = "text-no-wrap text-truncate-split content-default", triggerValue.textContent = "Filter Items";
      let chevron = document.createElement("span");
      chevron.className = "rovalra-dropdown-chevron size-500 icon icon-regular-chevron-large-down content-default";
      let dropdown = document.createElement("div");
      dropdown.id = "rovalra-fx-dropdown", dropdown.className = "rovalra-dropdown-content foundation-web-menu bg-surface-100 stroke-standard stroke-default shadow-transient-high radius-large", dropdown.style.minWidth = "340px", dropdown.style.maxHeight = "none", dropdown.style.zIndex = "10010", dropdown.setAttribute("data-state", "closed"), dropdown.addEventListener("click", (e) => {
        e.stopPropagation();
      });
      let headerContainer = document.createElement("div");
      headerContainer.className = "padding-x-large padding-bottom-medium flex items-center justify-between";
      let headerTitle = document.createElement("h3");
      headerTitle.className = "text-heading-medium", headerTitle.textContent = "Filter Items";
      let closeButton = createCloseButton({ onClick: /* @__PURE__ */ __name(() => {
        dropdown.setAttribute("data-state", "closed"), toggleButton.setAttribute("data-state", "closed"), toggleButton.classList.remove("filter-button-active");
      }, "onClick") });
      headerContainer.appendChild(headerTitle), headerContainer.appendChild(closeButton);
      let filterOptionsContainer = document.createElement("div");
      filterOptionsContainer.className = "padding-x-large padding-bottom-large flex flex-col gap-medium", filterOptionsContainer.style.maxHeight = "60vh", filterOptionsContainer.style.overflowY = "visible", filterConfig.forEach((config) => {
        if (config.type === "wrapper") {
          let wrapper = document.createElement("div");
          wrapper.id = config.id, wrapper.style.display = "none", wrapper.className = "flex flex-col gap-medium pl-large mt-medium border-l-2 border-l-neutral-200", config.children.forEach((childConfig) => {
            let childRow = createFilterRow(childConfig);
            childRow && wrapper.appendChild(childRow);
          }), filterOptionsContainer.appendChild(wrapper);
          return;
        }
        let row = createFilterRow(config);
        row && filterOptionsContainer.appendChild(row);
      });
      let applyBtn = document.createElement("button");
      applyBtn.id = "rovalra-price-apply-btn", applyBtn.textContent = "Apply Filter", applyBtn.className = "apply-button btn-primary-md btn-full-width", applyBtn.style.marginTop = "20px", applyBtn.style.backgroundColor = "rgb(51, 95, 255)", applyBtn.style.borderWidth = "0px", applyBtn.style.color = "white", applyBtn.onclick = async () => {
        onApply && await onApply() === !1 || (dropdown.setAttribute("data-state", "closed"), toggleButton.setAttribute("data-state", "closed"), toggleButton.classList.remove("filter-button-active"));
      }, filterOptionsContainer.appendChild(applyBtn), dropdown.appendChild(headerContainer), dropdown.appendChild(filterOptionsContainer), buttonWrapper.appendChild(toggleButton), toggleButton.append(triggerPresentationDiv, triggerValue, chevron), buttonWrapper.appendChild(dropdown), container.appendChild(buttonWrapper), toggleButton.addEventListener("click", (e) => {
        if (e.stopPropagation(), toggleButton.textContent.includes("Scanning")) return;
        let isOpen = dropdown.getAttribute("data-state") === "open";
        dropdown.setAttribute("data-state", isOpen ? "closed" : "open"), toggleButton.setAttribute("data-state", isOpen ? "closed" : "open"), toggleButton.classList.toggle("filter-button-active", !isOpen);
      }), document.addEventListener("click", (e) => {
        !container.contains(e.target) && dropdown.getAttribute("data-state") === "open" && (dropdown.setAttribute("data-state", "closed"), toggleButton.setAttribute("data-state", "closed"), toggleButton.classList.remove("filter-button-active"));
      });
    }
    if (searchbarEnabled) {
      let searchInput = document.createElement("input");
      searchInput.id = "rovalra-fx-search-bar", searchInput.className = "form-control input-field", searchInput.type = "text", searchInput.placeholder = "Search", Object.assign(searchInput.style, {
        flexGrow: "1",
        width: "auto"
      }), searchInput.addEventListener("input", onSearch), container.appendChild(searchInput);
    }
    return container;
  }
  __name(createAvatarFilterUI, "createAvatarFilterUI");

  // src/content/features/avatar/filters.js
  function init16() {
    window.location.pathname.includes("/my/avatar") && chrome.storage.local.get({
      avatarFiltersEnabled: !1,
      searchbarEnabled: !1
    }, (settings) => {
      !settings.avatarFiltersEnabled && !settings.searchbarEnabled || (function() {
        "use strict";
        let TRANSPARENT_PIXEL = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", itemDataCache = /* @__PURE__ */ new Map(), domMetadata = /* @__PURE__ */ new WeakMap(), selectedFilters = /* @__PURE__ */ new Set(), priceFilter = { min: { active: !1, value: null }, max: { active: !1, value: null } }, availabilityFilter = "all", creatorFilter = { active: !1, name: "" }, activeCategoryHash = window.location.hash, scanSessionId = 0, domUpdateAnimationFrame = null, scanQueue = /* @__PURE__ */ new Set(), scanQueueTimer = null, activeObservers = [];
        function analyzeAssetTree(roots) {
          let detectedEffects = /* @__PURE__ */ new Set();
          if (!roots || !Array.isArray(roots)) return detectedEffects;
          function traverse(instance) {
            if (!instance) return;
            let className = instance.ClassName;
            if ((className === "ParticleEmitter" || className === "Fire" || className === "Sparkles") && detectedEffects.add("itemsWithEffects"), (className === "SurfaceAppearance" || className === "MaterialVariant" || className === "MetalnessMap" || className === "RoughnessMap" || className === "NormalMap") && detectedEffects.add("surfaceAppearance"), instance.Children && instance.Children.length > 0)
              for (let child of instance.Children)
                traverse(child);
          }
          return __name(traverse, "traverse"), roots.forEach((root) => traverse(root)), detectedEffects;
        }
        __name(analyzeAssetTree, "analyzeAssetTree");
        function isFilteringActive() {
          if (selectedFilters.size > 0 || priceFilter.min.active || priceFilter.max.active || availabilityFilter !== "all" || creatorFilter.active) return !0;
          let searchInput = document.getElementById("rovalra-fx-search-bar");
          return searchInput && searchInput.value.length > 0;
        }
        __name(isFilteringActive, "isFilteringActive");
        function fullStateReset() {
          scanSessionId++, activeObservers.forEach((obs) => {
            obs && (typeof obs.disconnect == "function" ? obs.disconnect() : obs.selector && (obs.active = !1));
          }), activeObservers = [], scanQueueTimer && (clearTimeout(scanQueueTimer), scanQueueTimer = null), scanQueue.clear(), domUpdateAnimationFrame && (cancelAnimationFrame(domUpdateAnimationFrame), domUpdateAnimationFrame = null), itemDataCache = /* @__PURE__ */ new Map(), domMetadata = /* @__PURE__ */ new WeakMap(), selectedFilters.clear(), priceFilter = { min: { active: !1, value: null }, max: { active: !1, value: null } }, availabilityFilter = "all", creatorFilter = { active: !1, name: "" }, activeCategoryHash = window.location.hash, document.querySelectorAll(".rovalra-filtering-enabled").forEach((el2) => {
            el2.classList.remove("rovalra-filtering-enabled");
          });
          let existingUI = document.getElementById("rovalra-fx-container");
          existingUI && existingUI.remove();
        }
        __name(fullStateReset, "fullStateReset"), document.addEventListener("rovalra-catalog-details-response", (event) => {
          let data = event.detail;
          !data || !data.data || itemDataCache.size !== 0 && data.data.forEach((item) => {
            let cacheEntry = itemDataCache.get(item.id);
            cacheEntry && (cacheEntry.isLimited = item.itemRestrictions?.includes("Limited") || item.itemRestrictions?.includes("LimitedUnique") || item.itemRestrictions?.includes("Collectible"), cacheEntry.name = item.name, cacheEntry.searchName = (item.name || "").toLowerCase(), cacheEntry.price = item.price, cacheEntry.creatorName = item.creatorName, cacheEntry.creatorSearchName = (item.creatorName || "").toLowerCase(), cacheEntry.isOffsale = (item.priceStatus === "Off Sale" || item.isOffSale === !0) && !cacheEntry.isLimited, cacheEntry.isValid = !0);
          });
        });
        async function processItemIds(assetIds, currentSession) {
          if (assetIds.length !== 0)
            for (let i = 0; i < assetIds.length; i += 100) {
              if (currentSession !== scanSessionId) return;
              let chunk = assetIds.slice(i, i + 100), chunkIdsNeedingEffects = [];
              if (chunk.forEach((id) => {
                if (!itemDataCache) return;
                let entry = itemDataCache.get(id);
                entry ? entry.isValid || chunkIdsNeedingEffects.push(id) : (entry = {
                  assetId: id,
                  effects: /* @__PURE__ */ new Set(),
                  isValid: !1,
                  isLimited: !1,
                  isOffsale: !1,
                  name: "Loading...",
                  searchName: "",
                  price: null,
                  creatorName: "Loading...",
                  creatorSearchName: ""
                }, itemDataCache.set(id, entry), chunkIdsNeedingEffects.push(id));
              }), chunkIdsNeedingEffects.length > 0)
                try {
                  let parsedResults = await checkAssetsInBatch(chunkIdsNeedingEffects);
                  if (currentSession !== scanSessionId) return;
                  parsedResults.forEach((result) => {
                    let cacheEntry = itemDataCache.get(result.assetId);
                    cacheEntry && (result.root ? cacheEntry.effects = analyzeAssetTree(result.root) : cacheEntry.effects = /* @__PURE__ */ new Set());
                  });
                } catch (err) {
                  console.warn("Asset batch check failed", err);
                }
              currentSession === scanSessionId && triggerDomUpdate();
            }
        }
        __name(processItemIds, "processItemIds");
        function determineVisibility(meta, entry, searchTerm) {
          if (searchTerm && !(entry && entry.searchName ? entry.searchName : meta.searchName).includes(searchTerm))
            return !1;
          if (!(selectedFilters.size > 0 || priceFilter.min.active || priceFilter.max.active || creatorFilter.active || availabilityFilter !== "all")) return !0;
          if (!entry || !entry.isValid) return !1;
          if (selectedFilters.size > 0) {
            for (let filterId of selectedFilters)
              if (!(filterId === "limited" ? entry.isLimited : entry.effects.has(filterId))) return !1;
          }
          if (priceFilter.min.active || priceFilter.max.active) {
            let val = entry.price;
            if (typeof val != "number" || priceFilter.min.active && val < priceFilter.min.value || priceFilter.max.active && val > priceFilter.max.value) return !1;
          }
          if (availabilityFilter !== "all") {
            if (availabilityFilter === "onsale" && entry.isOffsale) return !1;
            if (availabilityFilter === "offsale" && !entry.isOffsale) return !1;
          }
          return !(creatorFilter.active && (!entry.creatorSearchName || !entry.creatorSearchName.includes(creatorFilter.name.toLowerCase())));
        }
        __name(determineVisibility, "determineVisibility");
        let filterUpdatePending = !1;
        function triggerDomUpdate() {
          filterUpdatePending || (filterUpdatePending = !0, domUpdateAnimationFrame && cancelAnimationFrame(domUpdateAnimationFrame), domUpdateAnimationFrame = requestAnimationFrame(applyFilterToDOM));
        }
        __name(triggerDomUpdate, "triggerDomUpdate");
        function applyFilterToDOM() {
          filterUpdatePending = !1, domUpdateAnimationFrame = null;
          let spinner = document.getElementById("rovalra-filter-loading");
          spinner && (spinner.style.display = "none");
          let activeTabPane = document.querySelector(".tab-pane.active");
          if (!activeTabPane) return;
          let searchInput = document.getElementById("rovalra-fx-search-bar"), searchTerm = searchInput ? searchInput.value.trim().toLowerCase() : "", active = isFilteringActive(), listContainer = activeTabPane.querySelector("ul.item-cards-stackable");
          listContainer && (active ? listContainer.classList.add("rovalra-filtering-enabled") : listContainer.classList.remove("rovalra-filtering-enabled"));
          let itemCards = activeTabPane.getElementsByClassName("list-item");
          for (let i = 0, len = itemCards.length; i < len; i++) {
            let card = itemCards[i], meta = domMetadata.get(card);
            if (!meta) continue;
            if (!active) {
              card.classList.contains("rovalra-fx-hidden") && card.classList.remove("rovalra-fx-hidden"), card.classList.add("rovalra-show");
              let img2 = meta.img;
              img2 && img2.dataset.rovalraSrc && (img2.src = img2.dataset.rovalraSrc, delete img2.dataset.rovalraSrc);
              continue;
            }
            let itemData = itemDataCache.get(meta.id), shouldShow = determineVisibility(meta, itemData, searchTerm), img = meta.img;
            if (shouldShow)
              card.classList.add("rovalra-show"), card.classList.remove("rovalra-fx-hidden"), img && img.dataset.rovalraSrc && (img.src = img.dataset.rovalraSrc, delete img.dataset.rovalraSrc);
            else if (card.classList.remove("rovalra-show"), img) {
              let currentSrc = img.src;
              currentSrc && !currentSrc.startsWith("data:") && (img.dataset.rovalraSrc = currentSrc, img.src = TRANSPARENT_PIXEL);
            }
          }
        }
        __name(applyFilterToDOM, "applyFilterToDOM");
        async function applyAllFilters() {
          let currentSession = scanSessionId;
          addLoadingSpinner(), updateToggleButtonText(), selectedFilters.clear(), document.querySelectorAll('#rovalra-fx-dropdown button[role="checkbox"]').forEach((btn) => {
            let filterId = btn.id.replace("rovalra-filter-", "");
            btn.getAttribute("aria-checked") === "true" && selectedFilters.add(filterId);
          });
          let creatorVal = document.getElementById("rovalra-creator-name")?.value.trim();
          creatorFilter = creatorVal ? { active: !0, name: creatorVal } : { active: !1, name: "" };
          let minPrice = parseInt(document.getElementById("rovalra-min-price-value")?.value, 10), maxPrice = parseInt(document.getElementById("rovalra-max-price-value")?.value, 10);
          priceFilter.min = !isNaN(minPrice) && minPrice >= 0 ? { active: !0, value: minPrice } : { active: !1, value: null }, priceFilter.max = !isNaN(maxPrice) && maxPrice >= 0 ? { active: !0, value: maxPrice } : { active: !1, value: null }, availabilityFilter = document.getElementById("rovalra-availability-filter")?.value || "all", triggerDomUpdate();
          let activeTabPane = document.querySelector(".tab-pane.active"), itemIdsToRecheck = /* @__PURE__ */ new Set();
          activeTabPane && activeTabPane.querySelectorAll(".list-item").forEach((card) => {
            let meta = domMetadata.get(card);
            if (meta && meta.id) {
              let cacheEntry = itemDataCache.get(meta.id);
              (!cacheEntry || !cacheEntry.isValid) && itemIdsToRecheck.add(meta.id);
            }
          });
          try {
            itemIdsToRecheck.size > 0 && await processItemIds(Array.from(itemIdsToRecheck), currentSession);
          } catch (e) {
            console.error("Filter process error", e);
          } finally {
            currentSession === scanSessionId && triggerDomUpdate();
          }
        }
        __name(applyAllFilters, "applyAllFilters");
        function updateToggleButtonText() {
          let btn = document.getElementById("rovalra-fx-toggle-btn");
          if (!btn) return;
          let count = selectedFilters.size + (priceFilter.min.active ? 1 : 0) + (priceFilter.max.active ? 1 : 0) + (availabilityFilter !== "all" ? 1 : 0) + (creatorFilter.active ? 1 : 0);
          btn.querySelector("span").textContent = "Filter Items", btn.classList.toggle("filter-applied", count > 0);
        }
        __name(updateToggleButtonText, "updateToggleButtonText");
        function ensureUIInActiveTab() {
          let activeTab = document.querySelector(".tab-pane.active");
          if (!activeTab) return;
          let currentHash = window.location.hash;
          currentHash !== activeCategoryHash && fullStateReset();
          let container = document.getElementById("rovalra-fx-container");
          if (container && (container.dataset.category !== currentHash || container.parentElement !== activeTab) && (container.remove(), container = null), activeTab.id === "scale" || activeTab.id === "bodyColors") {
            container && container.remove();
            return;
          }
          let isCostumesTab = activeTab.id === "costumes", showFilters = settings.avatarFiltersEnabled && !isCostumesTab, showSearch = settings.searchbarEnabled;
          if (!showFilters && !showSearch) {
            container && container.remove();
            return;
          }
          if (!container) {
            container = document.createElement("div"), container.id = "rovalra-fx-container", container.dataset.category = currentHash;
            let filterUI = createAvatarFilterUI({
              avatarFiltersEnabled: showFilters,
              searchbarEnabled: showSearch,
              onApply: applyAllFilters,
              onSearch: /* @__PURE__ */ __name(() => triggerDomUpdate(), "onSearch"),
              filterConfig: showFilters ? [
                { id: "rovalra-creator-name", type: "text", label: "Creator Name" },
                { id: "rovalra-min-price-value", type: "number", label: "Min Price", min: 0 },
                { id: "rovalra-max-price-value", type: "number", label: "Max Price", min: 0 },
                { id: "rovalra-availability-filter", type: "dropdown", label: "Availability", initialValue: "all", options: [{ value: "all", label: "Show All" }, { value: "onsale", label: "Onsale Only" }, { value: "offsale", label: "Offsale Only" }] },
                { id: "rovalra-filter-itemsWithEffects", type: "toggle", label: "Effects" },
                { id: "rovalra-filter-limited", type: "toggle", label: "Limiteds" }
              ] : []
            }), creatorInput = filterUI.querySelector("#rovalra-creator-name");
            creatorInput && ["keydown", "keypress", "keyup", "input", "change", "focus", "focusin", "click", "mousedown"].forEach((evt) => {
              creatorInput.addEventListener(evt, (e) => {
                e.stopPropagation();
              });
            }), container.appendChild(filterUI), activeTab.prepend(container);
          }
          if (showFilters || showSearch) {
            updateToggleButtonText();
            let listSelector = "ul.item-cards-stackable", existingList = activeTab.querySelector(listSelector);
            if (existingList)
              attachObserverToList(existingList);
            else {
              let listObs = observeElement(listSelector, (list) => attachObserverToList(list), { scope: activeTab, once: !0 });
              listObs && activeObservers.push(listObs);
            }
          }
        }
        __name(ensureUIInActiveTab, "ensureUIInActiveTab");
        function attachObserverToList(listElement) {
          if (listElement.dataset.rovalraObserved === "true") return;
          listElement.dataset.rovalraObserved = "true", isFilteringActive() && listElement.classList.add("rovalra-filtering-enabled");
          let itemObs = observeElement("li.list-item", (card) => {
            let thumb = card.querySelector(".item-card-thumb"), img = card.querySelector(".item-card-thumb img"), id = thumb ? parseInt(thumb.getAttribute("data-thumbnail-target-id"), 10) : null;
            if (!id) return;
            let nameContainer = card.querySelector(".item-card-thumb-container") || card.querySelector(".item-card-name"), nameText = nameContainer && (nameContainer.dataset.itemName || nameContainer.getAttribute("data-item-name") || nameContainer.textContent) || "";
            domMetadata.set(card, {
              id,
              searchName: nameText.toLowerCase(),
              img
            });
            let entry = itemDataCache.get(id);
            if (entry || scanQueue.has(id) || (scanQueue.add(id), scanQueueTimer || (scanQueueTimer = setTimeout(() => {
              let idsToProcess = Array.from(scanQueue);
              scanQueue.clear(), scanQueueTimer = null, processItemIds(idsToProcess, scanSessionId);
            }, 100))), isFilteringActive()) {
              let searchInput = document.getElementById("rovalra-fx-search-bar"), searchTerm = searchInput ? searchInput.value.trim().toLowerCase() : "", meta = domMetadata.get(card);
              if (determineVisibility(meta, entry, searchTerm))
                card.classList.add("rovalra-show"), card.classList.remove("rovalra-fx-hidden");
              else if (card.classList.remove("rovalra-show"), img) {
                let currentSrc = img.src;
                currentSrc && !currentSrc.startsWith("data:") && (img.dataset.rovalraSrc = currentSrc, img.src = TRANSPARENT_PIXEL);
              }
            } else
              card.classList.add("rovalra-show");
          }, { multiple: !0, scope: listElement });
          itemObs && activeObservers.push(itemObs);
        }
        __name(attachObserverToList, "attachObserverToList");
        function addLoadingSpinner() {
          let spinner = document.getElementById("rovalra-filter-loading");
          spinner ? spinner.style.display = "block" : (spinner = document.createElement("div"), spinner.id = "rovalra-filter-loading", spinner.textContent = "Filtering...", spinner.style.cssText = "position:absolute; top: 60px; right: 20px; background: rgba(0,0,0,0.8); color: white; padding: 5px 10px; border-radius: 4px; z-index: 2000; font-size: 12px; pointer-events: none;", document.querySelector(".tab-pane.active")?.prepend(spinner));
        }
        __name(addLoadingSpinner, "addLoadingSpinner");
        function injectStyles3() {
          if (document.getElementById("rovalra-fx-styles")) return;
          let style = document.createElement("style");
          style.id = "rovalra-fx-styles", style.textContent = `
                    .rovalra-fx-hidden { display: none !important; }
                    .rovalra-filtering-enabled .list-item { display: none; }
                    .rovalra-filtering-enabled .list-item.rovalra-show { display: inline-block !important; vertical-align: top; }
                    #rovalra-fx-container { position: relative; margin-bottom: 33px; z-index: 1; }
                    #rovalra-fx-dropdown { position: absolute; top: 100%; left: 0; right: 0; background-color: var(rgb(25, 26, 31)); border: 1px solid var(--rovalra-border-color); border-radius: 8px; padding: 6px; z-index: 100 !important; box-shadow: 0 4px 12px rgba(0,0,0,0.5); display: none; }
                    #rovalra-fx-dropdown[data-state="open"] { display: block; }
                    #rovalra-fx-toggle-btn.filter-button-active { background-color: ${document.documentElement.style.getPropertyValue("--filter-button-active-background")} !important; color: ${document.documentElement.style.getPropertyValue("--filter-button-active-text")} !important; }
                    .rovalra-fx-filter-row { display: flex; flex-direction: row; align-items: center; gap: 8px; margin-top: 12px; justify-content: space-between; }
                    .rovalra-fx-filter-row label { color: ${document.documentElement.style.getPropertyValue("--rovalra-main-text-color")}; margin-right: auto; font-size: 1rem; white-space: nowrap; }
                    .tab-horizontal-submenu { z-index: 2;}
                    `, document.head.appendChild(style);
        }
        __name(injectStyles3, "injectStyles");
        function cleanupFeature() {
          document.getElementById("rovalra-fx-container")?.remove();
        }
        __name(cleanupFeature, "cleanupFeature");
        function initBreadcrumbMonitor() {
          let hasObservedBreadcrumb = !1, bcObs = observeElement(".breadcrumb-container", () => {
            hasObservedBreadcrumb && (fullStateReset(), setTimeout(ensureUIInActiveTab, 100)), hasObservedBreadcrumb = !0;
          });
          bcObs && activeObservers.push(bcObs);
        }
        __name(initBreadcrumbMonitor, "initBreadcrumbMonitor");
        function initObserver() {
          injectStyles3(), window.addEventListener("hashchange", () => {
            fullStateReset(), setTimeout(ensureUIInActiveTab, 100);
          }), initBreadcrumbMonitor();
          let tabContent = document.querySelector(".tab-content.rbx-tab-content");
          if (tabContent) {
            let tabObs = observeElement(".tab-pane", (pane) => {
              let attrObserver = observeAttributes(pane, (mutation) => {
                mutation.attributeName === "class" && pane.classList.contains("active") && ensureUIInActiveTab();
              }, ["class"]);
              activeObservers.push(attrObserver);
            }, { multiple: !0, scope: tabContent });
            tabObs && activeObservers.push(tabObs), ensureUIInActiveTab();
          } else
            setTimeout(initObserver, 500);
        }
        __name(initObserver, "initObserver"), observeElement("#horizontal-tabs", initObserver, { onRemove: cleanupFeature });
      })();
    });
  }
  __name(init16, "init");

  // src/content/features/avatar/R6Warning.js
  function init17() {
    chrome.storage.local.get({ forceR6Enabled: !0 }, (settings) => {
      if (!settings.forceR6Enabled)
        return;
      let toggleGroupSelector = ".avatar-type-contents-container .MuiToggleButtonGroup-root", modalSelector = 'div[role="presentation"].MuiDialog-root', viewToggleSelector = ".toggle-three-dee", lastToggleClickTime = 0;
      function forceViewRefresh() {
        let toggleBtn = document.querySelector(viewToggleSelector);
        if (!toggleBtn) return;
        let originalText = toggleBtn.textContent.trim();
        toggleBtn.click(), setTimeout(() => {
          toggleBtn.textContent.trim() !== originalText && toggleBtn.click();
        }, 150);
      }
      __name(forceViewRefresh, "forceViewRefresh");
      function handleToggleGroupFound(groupContainer) {
        if (groupContainer.dataset.rovalraR6Patched) return;
        groupContainer.dataset.rovalraR6Patched = "true";
        let buttons = groupContainer.querySelectorAll("button");
        buttons.forEach((btn) => {
          btn.addEventListener("click", () => {
            lastToggleClickTime = Date.now(), buttons.forEach((b2) => {
              let isSelected = b2 === btn;
              b2.setAttribute("aria-pressed", isSelected), isSelected ? b2.classList.add("selected", "Mui-selected") : b2.classList.remove("selected", "Mui-selected");
            });
          }, { capture: !0 });
        });
      }
      __name(handleToggleGroupFound, "handleToggleGroupFound");
      function handleModalFound(modal) {
        if (Date.now() - lastToggleClickTime > 500)
          return;
        let allButtons = modal.querySelectorAll("button"), switchBtn = Array.from(allButtons).find(
          (b2) => b2.textContent.trim().toLowerCase() === "switch"
        ) || (allButtons.length > 0 ? allButtons[allButtons.length - 1] : null);
        switchBtn && (modal.style.visibility = "hidden", modal.style.opacity = "0", modal.style.pointerEvents = "none", switchBtn.click(), setTimeout(() => {
          forceViewRefresh();
        }, 200));
      }
      __name(handleModalFound, "handleModalFound"), observeElement(toggleGroupSelector, handleToggleGroupFound, { multiple: !0 }), observeElement(modalSelector, handleModalFound, { multiple: !0 });
    });
  }
  __name(init17, "init");

  // src/content/features/avatar/avatarRotator.js
  function init18() {
    window.location.pathname.includes("/my/avatar") && chrome.storage.local.get("avatarRotatorEnabled", (data) => {
      data.avatarRotatorEnabled && observeElement(".breadcrumb-container", (container) => {
        if (!window.location.pathname.includes("/my/avatar") || container.querySelector(".rovalra-avatar-rotator-btn")) return;
        let li = document.createElement("li");
        li.style.float = "right", li.style.display = "flex", li.style.alignItems = "center", li.style.gap = "5px";
        let stopBtn = document.createElement("button");
        stopBtn.type = "button", stopBtn.className = "btn-control-xs rovalra-avatar-rotator-stop-btn", stopBtn.textContent = "Stop Rotator", stopBtn.style.display = "none", stopBtn.onclick = () => {
          chrome.storage.local.set({ rovalra_avatar_rotator_enabled: !1 });
        };
        let rotatorBtn = document.createElement("button");
        rotatorBtn.type = "button", rotatorBtn.className = "btn-secondary-xs rovalra-avatar-rotator-btn", rotatorBtn.textContent = "Avatar Rotator";
        let nextPageCursor = "", isLoading = !1, avatarListContainer = null, selectedAvatars = /* @__PURE__ */ new Set(), setRotatorsBtn = null, disableRotatorBtn = null;
        function updateButtonState() {
          let count = selectedAvatars.size;
          setRotatorsBtn && (setRotatorsBtn.disabled = count < 2, setRotatorsBtn.textContent = count < 2 ? "Select at least 2 avatars" : `Set as rotators (${count})`);
          let statusText = document.getElementById("rovalra-avatar-status");
          statusText && (statusText.textContent = `Select avatars to rotate between. (${count} selected)`, statusText.style.color = "");
        }
        __name(updateButtonState, "updateButtonState");
        async function fetchAndRenderAvatars(reset = !1) {
          if (isLoading || (reset && (nextPageCursor = "", avatarListContainer && (avatarListContainer.innerHTML = "")), nextPageCursor === null && !reset)) return;
          isLoading = !0;
          let loadBtn = document.getElementById("rovalra-avatar-load-more");
          loadBtn && (loadBtn.textContent = "Loading...");
          try {
            let queryParams = new URLSearchParams({
              sortOption: "1",
              pageLimit: "50",
              "itemCategories[0].ItemSubType": "3",
              "itemCategories[0].ItemType": "Outfit"
            });
            nextPageCursor && queryParams.append("pageToken", nextPageCursor);
            let response = await callRobloxApiJson({
              subdomain: "avatar",
              endpoint: `/v1/avatar-inventory?${queryParams.toString()}`,
              method: "GET"
            });
            if (response.avatarInventoryItems && response.avatarInventoryItems.length > 0) {
              let outfitIds = response.avatarInventoryItems.map((item) => item.itemId), thumbnails = await getBatchThumbnails(outfitIds, "Outfit", "150x150");
              response.avatarInventoryItems.forEach((outfit, index) => {
                let card = document.createElement("div");
                card.className = "rovalra-avatar-card", card.style.cssText = "display: flex; flex-direction: column; align-items: center; width: 100px; margin: 5px; cursor: pointer; border-radius: 10px; padding: 5px; transition: all 0.2s; position: relative;";
                let radio = createRadioButton({
                  id: `avatar-radio-${outfit.itemId}`,
                  checked: selectedAvatars.has(outfit.itemId),
                  onChange: /* @__PURE__ */ __name((checked) => {
                    checked ? selectedAvatars.add(outfit.itemId) : selectedAvatars.delete(outfit.itemId), updateButtonState();
                  }, "onChange")
                });
                radio.style.position = "absolute", radio.style.top = "5px", radio.style.right = "5px", radio.style.zIndex = "10", card.onclick = () => {
                  radio.disabled || radio.click();
                };
                let thumbData = thumbnails.find((t) => t.targetId === outfit.itemId), img = createThumbnailElement(thumbData, outfit.itemName, "rovalra-avatar-thumb", { width: "100px", height: "100px", borderRadius: "8px", objectFit: "cover" }), name = document.createElement("span");
                name.textContent = outfit.itemName, name.style.cssText = "font-size: 12px; text-align: center; margin-top: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 100%;", card.appendChild(radio), card.appendChild(img), card.appendChild(name), avatarListContainer.appendChild(card);
              }), avatarListContainer && avatarListContainer.parentElement && (avatarListContainer.parentElement.style.height = "auto"), updateButtonState();
            }
            nextPageCursor = response.nextPageToken || null;
          } catch (error) {
            console.error("RoValra: Failed to fetch avatars", error);
          } finally {
            isLoading = !1, loadBtn && (loadBtn.textContent = "Load More", loadBtn.style.display = nextPageCursor ? "block" : "none");
          }
        }
        __name(fetchAndRenderAvatars, "fetchAndRenderAvatars"), rotatorBtn.addEventListener("click", () => {
          chrome.storage.local.get(["rovalra_avatar_rotator_ids", "rovalra_avatar_rotator_enabled", "rovalra_avatar_rotator_interval"], (data2) => {
            selectedAvatars.clear(), data2.rovalra_avatar_rotator_ids && Array.isArray(data2.rovalra_avatar_rotator_ids) && data2.rovalra_avatar_rotator_ids.forEach((id) => selectedAvatars.add(id)), avatarListContainer = document.createElement("div"), avatarListContainer.style.cssText = "display: flex; flex-wrap: wrap; justify-content: center; width: 100%; overflow-y: auto; flex: 1;";
            let loadMoreBtn = document.createElement("button");
            loadMoreBtn.id = "rovalra-avatar-load-more", loadMoreBtn.className = "btn-control-sm", loadMoreBtn.textContent = "Load More", loadMoreBtn.style.cssText = "display: none; margin: 10px auto; flex-shrink: 0;", loadMoreBtn.onclick = () => fetchAndRenderAvatars();
            let placeholderText = document.createElement("div");
            placeholderText.id = "rovalra-avatar-status", placeholderText.textContent = `Select avatars to rotate between. (${selectedAvatars.size} selected)`, placeholderText.style.cssText = "padding: 0 10px 10px 10px; text-align: center; font-size: 12px; opacity: 0.8; flex-shrink: 0;";
            let settingsContainer = document.createElement("div");
            settingsContainer.style.cssText = "display: flex; align-items: center; justify-content: center; gap: 10px; padding: 0 0 10px 0; flex-shrink: 0;";
            let { container: inputContainer, input: intervalInput } = createStyledInput({
              id: "rovalra-rotator-interval",
              label: "Interval (seconds)"
            });
            intervalInput.type = "number", intervalInput.min = "5", intervalInput.value = data2.rovalra_avatar_rotator_interval || "5", inputContainer.style.width = "150px", inputContainer.style.marginTop = "5px", intervalInput.dispatchEvent(new Event("input")), intervalInput.addEventListener("change", () => {
              parseInt(intervalInput.value) < 5 && (intervalInput.value = 5);
            }), settingsContainer.appendChild(inputContainer);
            let wrapper = document.createElement("div");
            wrapper.style.cssText = "display: flex; flex-direction: column; width: 100%; height: 550px;", wrapper.appendChild(settingsContainer), wrapper.appendChild(placeholderText), wrapper.appendChild(avatarListContainer), wrapper.appendChild(loadMoreBtn), setRotatorsBtn = document.createElement("button"), setRotatorsBtn.className = "btn-primary-md", setRotatorsBtn.textContent = "Select at least 2 avatars", setRotatorsBtn.disabled = !0, setRotatorsBtn.onclick = () => {
              let avatars = Array.from(selectedAvatars), interval = parseInt(intervalInput.value, 10) || 5;
              chrome.storage.local.set({
                rovalra_avatar_rotator_ids: avatars,
                rovalra_avatar_rotator_enabled: !0,
                rovalra_avatar_rotator_interval: interval
              }), setRotatorsBtn.textContent = "Rotators Active!", disableRotatorBtn && (disableRotatorBtn.style.display = "inline-block"), setTimeout(() => updateButtonState(), 2e3);
            }, disableRotatorBtn = document.createElement("button"), disableRotatorBtn.className = "btn-control-md", disableRotatorBtn.textContent = "Disable", disableRotatorBtn.style.display = data2.rovalra_avatar_rotator_enabled ? "inline-block" : "none", disableRotatorBtn.onclick = () => {
              chrome.storage.local.set({
                rovalra_avatar_rotator_enabled: !1
              }), disableRotatorBtn.style.display = "none";
            }, createOverlay({
              title: "Avatar Rotator",
              bodyContent: wrapper,
              showLogo: !0,
              maxWidth: "600px",
              maxHeight: "600px",
              actions: [disableRotatorBtn, setRotatorsBtn]
            }), fetchAndRenderAvatars(!0);
          });
        }), li.appendChild(stopBtn), li.appendChild(rotatorBtn), container.appendChild(li);
        function updateStopButtonVisibility() {
          chrome.storage.local.get("rovalra_avatar_rotator_enabled", (data2) => {
            stopBtn.style.display = data2.rovalra_avatar_rotator_enabled ? "inline-block" : "none";
          });
        }
        __name(updateStopButtonVisibility, "updateStopButtonVisibility"), updateStopButtonVisibility(), chrome.storage.onChanged.addListener((changes, namespace) => {
          namespace === "local" && changes.rovalra_avatar_rotator_enabled && updateStopButtonVisibility();
        });
      }, { multiple: !0 });
    });
  }
  __name(init18, "init");

  // src/content/core/utils/itemCategories.js
  var categoriesCache = null, pendingPromise = null;
  async function fetchCategories() {
    return categoriesCache || pendingPromise || (pendingPromise = (async () => {
      try {
        let data = await callRobloxApiJson({
          subdomain: "catalog",
          endpoint: "/v1/categories",
          method: "GET"
        }), processed = [], classicSubcats = ["ClassicShirts", "ClassicTShirts", "ClassicPants"];
        for (let cat of data)
          if (cat.category === "Clothing") {
            let clothingSubcats = [], classicSubcategoryObjects = [], classicAssetTypeIds = /* @__PURE__ */ new Set();
            cat.subcategories.forEach((sub) => {
              classicSubcats.includes(sub.subcategory) ? (classicSubcategoryObjects.push(sub), sub.assetTypeIds && sub.assetTypeIds.forEach((id) => classicAssetTypeIds.add(id))) : clothingSubcats.push(sub);
            }), cat.subcategories = clothingSubcats, cat.assetTypeIds = cat.assetTypeIds.filter((id) => !classicAssetTypeIds.has(id)), processed.push(cat), classicSubcategoryObjects.length > 0 && processed.push({
              category: "ClassicClothing",
              assetTypeIds: Array.from(classicAssetTypeIds),
              bundleTypeIds: [],
              categoryId: 999,
              name: "Classic Clothing",
              orderIndex: cat.orderIndex,
              subcategories: classicSubcategoryObjects,
              isSearchable: !0
            });
          } else
            processed.push(cat);
        return categoriesCache = processed, processed;
      } catch (error) {
        return console.error("RoValra: Failed to fetch item categories", error), categoriesCache = [], [];
      }
    })(), pendingPromise);
  }
  __name(fetchCategories, "fetchCategories");
  async function getAllCategories() {
    return await fetchCategories();
  }
  __name(getAllCategories, "getAllCategories");
  async function getIdsByCategory(categoryName) {
    let cat = (await fetchCategories()).find((c) => c.category === categoryName || c.name === categoryName);
    return cat ? {
      assetTypeIds: cat.assetTypeIds || [],
      bundleTypeIds: cat.bundleTypeIds || []
    } : null;
  }
  __name(getIdsByCategory, "getIdsByCategory");
  async function getIdsBySubcategory(subcategoryName) {
    let categories = await fetchCategories();
    for (let cat of categories) {
      let sub = cat.subcategories.find((s) => s.subcategory === subcategoryName || s.name === subcategoryName);
      if (sub)
        return {
          assetTypeIds: sub.assetTypeIds || [],
          bundleTypeIds: sub.bundleTypeIds || []
        };
    }
    return null;
  }
  __name(getIdsBySubcategory, "getIdsBySubcategory");

  // src/content/features/avatar/multiEquip.js
  function init19() {
    let updateState = /* @__PURE__ */ __name(async (enabled) => {
      if (document.dispatchEvent(new CustomEvent("rovalra-multi-equip", { detail: { enabled } })), enabled)
        try {
          let [accData, clothingData, hairData] = await Promise.all([
            getIdsByCategory("Accessories"),
            getIdsByCategory("Clothing"),
            getIdsBySubcategory("HairAccessories")
          ]), accIds = new Set(accData?.assetTypeIds || []);
          hairData?.assetTypeIds && hairData.assetTypeIds.forEach((id) => accIds.add(id)), document.dispatchEvent(new CustomEvent("rovalra-multi-equip", {
            detail: {
              enabled,
              accessories: Array.from(accIds),
              layered: clothingData?.assetTypeIds || []
            }
          }));
        } catch (e) {
          console.warn("RoValra: Failed to fetch dynamic categories for multi-equip", e);
        }
    }, "updateState");
    chrome.storage.local.get("multiEquipEnabled", (data) => {
      updateState(data.multiEquipEnabled === !0);
    }), chrome.storage.onChanged.addListener((changes, namespace) => {
      namespace === "local" && changes.multiEquipEnabled && updateState(changes.multiEquipEnabled.newValue === !0);
    });
  }
  __name(init19, "init");

  // src/content/features/catalog/itemsales.js
  var cachedItemsData = null, currentActiveItemId = null;
  function init20() {
    chrome.storage.local.get({ itemSalesEnabled: !1 }, async (settings) => {
      if (!settings.itemSalesEnabled) return;
      let url = window.location.href, regex = /https:\/\/www\.roblox\.com\/(?:[a-z]{2}\/)?(?:catalog|bundles)\/(\d+)/, match = url.match(regex);
      if (!match) {
        currentActiveItemId = null;
        return;
      }
      let itemId = parseInt(match[1], 10);
      if (currentActiveItemId = itemId, !cachedItemsData)
        try {
          cachedItemsData = await callRobloxApiJson({
            isRovalraApi: !0,
            subdomain: "www",
            endpoint: "/static/json/items.json"
          });
        } catch (e) {
          console.error("RoValra: Failed to load items.json", e);
          return;
        }
      if (!cachedItemsData || !cachedItemsData.item) return;
      let item = cachedItemsData.item.find((i) => i.id === itemId || parseInt(i.id, 10) === itemId);
      item && observeElement(".price-row-container", (foundElement) => {
        if (currentActiveItemId !== itemId || foundElement.dataset.rovalraItemSalesInjected === String(itemId)) return;
        foundElement.parentNode.querySelector(".rovalra-item-sales-container")?.remove();
        let container = document.createElement("div");
        container.className = "rovalra-item-sales-container";
        let createRow = /* @__PURE__ */ __name((label, value, showTooltip = !1, isHtml = !1) => {
          let row = document.createElement("div");
          row.className = "clearfix item-info-row-container";
          let labelDiv = document.createElement("div");
          labelDiv.className = "font-header-1 text-subheader text-label text-overflow row-label", labelDiv.textContent = label;
          let valueDiv = document.createElement("div");
          if (valueDiv.className = "font-body text", isHtml ? valueDiv.innerHTML = purify.sanitize(value) : valueDiv.textContent = value, showTooltip) {
            let infoIcon = document.createElement("span");
            infoIcon.className = "icon-moreinfo", infoIcon.style.marginLeft = "1px", infoIcon.style.cursor = "pointer", infoIcon.style.verticalAlign = "middle", infoIcon.style.transform = "scale(0.8)", addTooltip(infoIcon, "The sales and revenue stats are from a leak and are likely inaccurate.", { position: "top" }), valueDiv.appendChild(infoIcon);
          }
          return row.appendChild(labelDiv), row.appendChild(valueDiv), row;
        }, "createRow"), salesRow = createRow("Sales", item.sales.toLocaleString(), !0);
        container.appendChild(salesRow);
        let revenueRow = createRow("Revenue", `<span class="icon-robux-16x16" style="vertical-align: text-bottom; margin-right: 0px;"></span>${(item.revenue / 100).toFixed(2)}`, !1, !0);
        container.appendChild(revenueRow), foundElement.parentNode.insertBefore(container, foundElement.nextSibling), foundElement.dataset.rovalraItemSalesInjected = String(itemId);
      });
    });
  }
  __name(init20, "init");

  // src/content/features/catalog/40method.js
  var ROVALRA_PLACE_ID = "107845747621646", assetToSubcategoryMap = null, classicClothingSubcategories = null, metadataPromise = null, itemDetailsCache = /* @__PURE__ */ new Map(), ROVALRA_TEMPLATE_ASSET_ID = 107845747621646;
  async function fetchTemplateBlobViaBatch() {
    let batchResponse = await callRobloxApi({
      subdomain: "assetdelivery",
      endpoint: "/v2/assets/batch",
      method: "POST",
      body: [
        {
          requestId: "rovalra_req_" + Date.now(),
          assetId: ROVALRA_TEMPLATE_ASSET_ID,
          type: "Place",
          format: "rbxl"
        }
      ]
    });
    if (!batchResponse.ok)
      throw new Error(`Batch API failed: ${batchResponse.status}`);
    let batchData = await batchResponse.json();
    if (!batchData || !batchData[0] || !batchData[0].locations || !batchData[0].locations[0])
      throw new Error("Could not retrieve template download location from Batch API");
    let cdnUrl = batchData[0].locations[0].location, fileResponse = await callRobloxApi({
      fullUrl: cdnUrl,
      method: "GET",
      credentials: "omit"
    });
    if (!fileResponse.ok)
      throw new Error("Failed to download file from CDN");
    return await fileResponse.blob();
  }
  __name(fetchTemplateBlobViaBatch, "fetchTemplateBlobViaBatch");
  async function publishTemplateToPlace(targetPlaceId) {
    try {
      let fileBlob = await fetchTemplateBlobViaBatch(), formData = new FormData(), requestData = {
        assetType: "Place",
        assetId: parseInt(targetPlaceId),
        published: !0,
        creationContext: {}
      };
      formData.append("request", JSON.stringify(requestData)), formData.append("fileContent", fileBlob, "place.rbxl");
      let response = await callRobloxApi({
        subdomain: "apis",
        endpoint: `/assets/user-auth/v1/assets/${targetPlaceId}`,
        method: "PATCH",
        body: formData
      });
      if (!response.ok) {
        let txt = await response.text();
        throw new Error(`Patch upload failed: ${response.status} ${txt}`);
      }
      return !0;
    } catch (error) {
      throw console.error("Mania Ext: Auto-publish failed", error), error;
    }
  }
  __name(publishTemplateToPlace, "publishTemplateToPlace");
  function getItemDetails(itemId, itemType = "Asset") {
    let key = `${itemId}_${itemType}`;
    if (itemDetailsCache.has(key)) return itemDetailsCache.get(key);
    let promise = callRobloxApiJson({
      subdomain: "catalog",
      endpoint: "/v1/catalog/items/details",
      method: "POST",
      body: { items: [{ id: parseInt(itemId), itemType }] }
    }).catch((err) => (itemDetailsCache.delete(key), null));
    return itemDetailsCache.set(key, promise), promise;
  }
  __name(getItemDetails, "getItemDetails");
  async function fetchCatalogMetadata() {
    if (!(assetToSubcategoryMap && classicClothingSubcategories))
      return metadataPromise || (metadataPromise = (async () => {
        try {
          let [assetToSubResponse, subcategoriesResponse] = await Promise.all([
            callRobloxApiJson({
              subdomain: "catalog",
              endpoint: "/v1/asset-to-subcategory",
              method: "GET"
            }),
            callRobloxApiJson({
              subdomain: "catalog",
              endpoint: "/v1/subcategories",
              method: "GET"
            })
          ]);
          assetToSubcategoryMap = assetToSubResponse;
          let classicKeys = ["ClassicShirts", "ClassicPants", "ClassicTShirts"];
          if (classicClothingSubcategories = [], subcategoriesResponse)
            for (let key of classicKeys)
              subcategoriesResponse[key] !== void 0 && classicClothingSubcategories.push(subcategoriesResponse[key]);
        } catch (error) {
          console.warn("Mania Ext: Failed to fetch catalog metadata", error);
        } finally {
          metadataPromise = null;
        }
      })(), metadataPromise);
  }
  __name(fetchCatalogMetadata, "fetchCatalogMetadata");
  async function fetchGamesForGroup(groupId) {
    let allGames = [], nextCursor = null;
    do {
      let url = `/universes/v1/search?CreatorType=Group&CreatorTargetId=${groupId}&IsArchived=false&Surface=CreatorHubCreations&PageSize=100&SortParam=LastUpdated&SortOrder=Desc` + (nextCursor ? `&cursor=${nextCursor}` : ""), response = await callRobloxApiJson({
        subdomain: "apis",
        endpoint: url
      });
      response.data && (allGames = allGames.concat(response.data)), nextCursor = response.nextPageCursor;
    } while (nextCursor);
    return allGames;
  }
  __name(fetchGamesForGroup, "fetchGamesForGroup");
  async function updateGameDescription(universeId, sourcePlaceId) {
    try {
      let versionResponse = await callRobloxApiJson({
        subdomain: "develop",
        endpoint: "/v1/assets/latest-versions",
        method: "POST",
        body: {
          assetIds: [parseInt(sourcePlaceId)],
          versionStatus: "Published"
        }
      }), versionNumber = "Unknown";
      versionResponse && versionResponse.results && versionResponse.results.length > 0 && (versionNumber = versionResponse.results[0].versionNumber);
      let configResponse = await callRobloxApiJson({
        subdomain: "develop",
        endpoint: `/v1/universes/${universeId}/configuration`,
        method: "GET"
      });
      if (!configResponse) return;
      let newDescription = `SourcePlaceId: ${sourcePlaceId} Version: ${versionNumber}`, patchBody = {
        name: configResponse.name,
        description: newDescription,
        isFriendsOnly: configResponse.isFriendsOnly,
        studioAccessToApisAllowed: configResponse.isStudioAccessToApisAllowed
      };
      await callRobloxApiJson({
        subdomain: "develop",
        endpoint: `/v2/universes/${universeId}/configuration`,
        method: "PATCH",
        body: patchBody
      });
    } catch (e) {
      console.warn("Mania Ext: Failed to update game description", e);
    }
  }
  __name(updateGameDescription, "updateGameDescription");
  async function validateGameSync(universeId, placeId) {
    try {
      let versionResponse = await callRobloxApiJson({
        subdomain: "develop",
        endpoint: "/v1/assets/latest-versions",
        method: "POST",
        body: {
          assetIds: [parseInt(ROVALRA_PLACE_ID)],
          versionStatus: "Published"
        }
      }), latestVersion = 0;
      versionResponse && versionResponse.results && versionResponse.results.length > 0 && (latestVersion = versionResponse.results[0].versionNumber);
      let description = "";
      if (placeId) {
        let gameDetails = await callRobloxApiJson({
          subdomain: "games",
          endpoint: `/v1/games/multiget-place-details?placeIds=${placeId}`,
          method: "GET"
        });
        gameDetails && gameDetails.length > 0 && (description = gameDetails[0].description || "");
      } else {
        let configResponse = await callRobloxApiJson({
          subdomain: "develop",
          endpoint: `/v1/universes/${universeId}/configuration`,
          method: "GET"
        });
        configResponse && (description = configResponse.description || "");
      }
      let match = description.match(/SourcePlaceId:\s*(\d+)\s*Version:\s*(\d+)/);
      if (!match) return { valid: !1, reason: "missing_metadata" };
      let sourceId = match[1], currentVersion = parseInt(match[2], 10);
      return sourceId !== ROVALRA_PLACE_ID || currentVersion < latestVersion ? { valid: !1, reason: "outdated", current: currentVersion, latest: latestVersion } : { valid: !0 };
    } catch {
      return { valid: !0 };
    }
  }
  __name(validateGameSync, "validateGameSync");
  var getCurrentUserId = /* @__PURE__ */ __name(() => {
    let meta = document.querySelector('meta[name="user-data"]');
    return meta ? meta.getAttribute("data-userid") : null;
  }, "getCurrentUserId"), getCartItems = /* @__PURE__ */ __name(() => {
    let cartModal = document.querySelector(".shopping-cart-modal");
    if (!cartModal) return [];
    let cartItems = [];
    return cartModal.querySelectorAll(".cart-item-container").forEach((container) => {
      let link = container.querySelector(".item-details-container a.item-name"), priceText = container.querySelector(".item-price .price-text");
      if (link && priceText) {
        let match = link.getAttribute("href").match(/\/(?:[a-z]{2}(?:-[a-z]{2})?\/)?catalog\/(\d+)\//i);
        match && cartItems.push({
          id: match[1],
          name: link.textContent.trim(),
          price: parseInt(priceText.textContent.replace(/,/g, ""), 10),
          thumbnail: null
        });
      }
    }), cartItems;
  }, "getCartItems"), getBatchPurchaseItems = /* @__PURE__ */ __name((modal) => {
    let thumbnails = modal.querySelectorAll(".modal-multi-item-image-container img"), items = [];
    return thumbnails.forEach((img) => {
      let alt = img.getAttribute("alt");
      alt && items.push({
        name: alt.trim()
      });
    }), items;
  }, "getBatchPurchaseItems"), validateCartMatch = /* @__PURE__ */ __name((modalItems, cartItems) => {
    if (modalItems.length !== cartItems.length) return !1;
    let modalNames = new Set(modalItems.map((item) => item.name)), cartNames = new Set(cartItems.map((item) => item.name));
    for (let name of modalNames)
      if (!cartNames.has(name)) return !1;
    return !0;
  }, "validateCartMatch"), checkItemOwnership = /* @__PURE__ */ __name(async (userId, itemId, itemType) => {
    try {
      let type = {
        Asset: "Asset",
        Bundle: "Bundle",
        GamePass: "GamePass"
      }[itemType] || "Asset", response = await callRobloxApi({
        subdomain: "inventory",
        endpoint: `/v1/users/${userId}/items/${type}/${itemId}`,
        method: "GET"
      });
      if (response.ok) {
        let data = await response.json();
        return data && data.data && data.data.length > 0;
      }
      return !1;
    } catch (error) {
      return console.warn("Mania Ext: Could not check item ownership:", error), !1;
    }
  }, "checkItemOwnership"), getUniverseId = /* @__PURE__ */ __name(() => {
    let meta = document.getElementById("game-detail-meta-data");
    return meta ? meta.getAttribute("data-universe-id") : null;
  }, "getUniverseId");
  async function fetchGamePassesForUniverse(universeId) {
    let gamePasses = [], cursor = "";
    try {
      do {
        let url = `/game-passes/v1/universes/${universeId}/game-passes?pageSize=50&passView=Full` + (cursor ? `&cursor=${cursor}` : ""), response = await callRobloxApiJson({
          subdomain: "apis",
          endpoint: url,
          method: "GET"
        });
        response.gamePasses && (gamePasses = gamePasses.concat(response.gamePasses)), cursor = response.nextPageToken;
      } while (cursor);
    } catch (error) {
      console.warn("Mania Ext: Failed to fetch game passes via API", error);
    }
    return gamePasses;
  }
  __name(fetchGamePassesForUniverse, "fetchGamePassesForUniverse");
  var detectAndAddSaveButton = /* @__PURE__ */ __name(() => {
    observeElement('.modal-dialog .modal-content[role="document"], .modal-dialog .modal-content', (modal) => {
      let handleUpdate = /* @__PURE__ */ __name(() => {
        modal.querySelector(".btn-save-robux") || addSaveButton(modal);
      }, "handleUpdate");
      handleUpdate();
      let observer = new MutationObserver(handleUpdate);
      observer.observe(modal, { childList: !0, subtree: !0 }), modal._rovalraSaveBtnObserver = observer;
    }, {
      multiple: !0,
      onRemove: /* @__PURE__ */ __name((modal) => {
        modal._rovalraSaveBtnObserver && (modal._rovalraSaveBtnObserver.disconnect(), delete modal._rovalraSaveBtnObserver);
      }, "onRemove")
    });
  }, "detectAndAddSaveButton"), createAndShowPopup = /* @__PURE__ */ __name((onSave, initialState = null) => {
    let currentUserId = getCurrentUserId();
    if (!currentUserId) {
      alert("Could not identify your user ID. Please make sure you are logged in.");
      return;
    }
    let bodyContent = document.createElement("div");
    bodyContent.innerHTML = purify.sanitize(`
        <div id="sr-view-main">
            <h4 class="text font-header-2" style="margin:0 0 12px 0;">Set Up an Experience</h4>
            <p class="text font-body" style="margin: 0 0 10px 0; line-height:1.4;">
                <strong>Only a specific template works</strong>
            </p>
            <p class="text font-body" style="margin: 0 0 8px 0;">Select a group you can manage experiences in:</p>
            <div id="sr-group-dropdown-container" style="margin-bottom: 16px;"></div>
            <div style="display:flex;align-items:center;gap:8px;margin:12px 0 8px 0;">
                <hr style="flex:1;border:none;border-top:1px solid rgba(255,255,255,0.15);" />
                <span class="text font-body" style="font-size:12px;opacity:.7;">OR</span>
                <hr style="flex:1;border:none;border-top:1px solid rgba(255,255,255,0.15);" />
            </div>
            <p class="text font-body" style="margin: 0 0 8px 0;">Manually enter a Place ID:</p>
            <div id="sr-game-id-input-container" style="width: 100%;"></div>
            <div style="display:flex;align-items:center;gap:8px;margin:12px 0 8px 0;">
                <hr style="flex:1;border:none;border-top:1px solid rgba(255,255,255,0.15);" />
                <span class="text font-body" style="font-size:12px;opacity:.7;">OR</span>
                <hr style="flex:1;border:none;border-top:1px solid rgba(255,255,255,0.15);" />
            </div>
            <button id="sr-use-rovalra-group-btn" class="btn-secondary-md btn-min-width" style="width: 100%;">Donate Saved Robux to RoValra</button>
            <p class="text font-body" style="margin:12px 0 0 0;font-size:12px;opacity:.65;">Estimated savings shown later are approximate and may be inaccurate.</p>
        </div>
        
        <div id="sr-view-non-owner-ack" class="sr-hidden">
            <h4 class="text font-header-2" style="margin: 0 0 10px 0;">Important Information</h4>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height: 1.5;"><strong>Owner Account:</strong> The group owner CANNOT be the same account you are buying items with. The owner should be a secured alt account with 2FA enabled and a strong, unique password.</p>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height: 1.5;"><strong>Payouts:</strong> Only the group's owner account can pay out the saved Robux from the group's funds.</p>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height: 1.5;"><strong>Pending Robux:</strong> Be aware that after using this feature, the Robux will be pending for approximately one month before they can be paid out.</p>
            <button class="btn-cta-md btn-min-width" id="sr-acknowledge-btn" style="width: 100%; margin-top: 10px;">I Acknowledge</button>
        </div>

        <div id="sr-view-owner-warning" class="sr-hidden">
            <h4 class="text font-header-2" style="margin: 0 0 10px 0;">Ownership Detected</h4>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height: 1.5;">The 40% method will not work if you are the owner of this group. Please select a different group or transfer ownership to a secured alt account.</p>
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn-secondary-md btn-min-width" id="sr-owner-warning-back-btn" style="flex: 1;">Go Back</button>
            </div>
        </div>
        <div id="sr-view-manual-ack" class="sr-hidden">
            <h4 class="text font-header-2" style="margin: 0 0 10px 0;">Experience Accepted</h4>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height:1.5;">
                <strong>Only specific experiences work.</strong> Ensure this experience is set up with the required scripts to handle in-game purchases.
            </p>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height:1.5;">
                Make sure the experience belongs to a group <strong>you control, but is not owned by this account</strong>. Preferably the group should be owned by an alt. If you own the group, the 40% method will not work.
            </p>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height:1.5;">
                The saved Robux will be pending for roughly one month before payout. Use a secure alt as group owner for payouts.
            </p>
            <button id="sr-manual-ack-btn" class="btn-cta-md btn-min-width" style="width:100%;">I Understand & Continue</button>
        </div>
        
        <div id="sr-view-wip" class="sr-hidden">
            <h4 class="text font-header-2" style="margin: 0 0 10px 0;">Create Experience</h4>
            <p class="text font-body" style="margin: 5px 0 16px 0; line-height: 1.5;">Create a new experience for this group to use the 40% method.</p>
            <div id="sr-create-game-error" class="text font-body" style="margin-bottom: 10px; font-size: 12px; color: #d32f2f; display: none;"></div>
            <button class="btn-cta-md btn-min-width" id="sr-create-new-game-btn" style="width: 100%;">Create New Experience</button>
        </div>

        <div id="sr-view-manual-create-instructions" class="sr-hidden">
            <h4 class="text font-header-2" style="margin: 0 0 10px 0;">Create New Experience</h4>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height: 1.5;">To create a new experience for this method:</p>
            <div style="margin-bottom: 16px; border-radius: 8px; overflow: hidden;">
                <iframe width="100%" height="250" src="https://www.youtube.com/embed/-kUAWWmmkaQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
            </div>
            <ol class="text font-body" style="margin: 0 0 16px 0; padding-left: 20px; line-height: 1.5;">
                <li>Open the uncopylocked experience in Studio: <a href="#" id="sr-edit-game-link" style="text-decoration: underline;">Open Studio</a></li>
                <li>In Studio, go to <strong>File > Game Settings > Security > Turn on "Allow Third Party Sales" > File > Publish to Roblox As...</strong></li>
                <li>Select this group from the Creator list.</li>
                <li>Click <strong>Create</strong> and the experience will be published</li>
            </ol>
            <p class="text font-body" style="margin: 0 0 16px 0; line-height: 1.5;">Once published, click the button below and we'll automatically find and select it for you.</p>
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn-secondary-md btn-min-width" id="sr-manual-create-back-btn" style="flex: 1;">Back</button>
                <button class="btn-cta-md btn-min-width" id="sr-manual-create-done-btn" style="flex: 1;">I've Published the Game</button>
            </div>
        </div>

        <div id="sr-view-finding-game" class="sr-hidden">
            <div style="text-align: center; padding: 20px 0;">
                <div id="sr-finding-game-spinner" style="margin: 0 auto 16px;"></div>
                <h4 class="text font-header-2" style="margin: 0 0 8px 0;">Finding Your Experience</h4>
                <p class="text font-body" style="margin: 0;">Please wait while we look for your newly published experience...</p>
            </div>
        </div>

        <div id="sr-view-rovalra-group" class="sr-hidden">
            <h4 class="text font-header-2" style="margin: 0 0 10px 0;">Donate to RoValra</h4>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height: 1.5;"><strong>How it works:</strong> Your purchase will go through a game owned by RoValra, and RoValra will earn a commission on your purchase which will help support RoValra's development.</p>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height: 1.5;"><strong>No Setup Required:</strong> Perfect if you don't have your own group or want to support the extension!</p>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height: 1.5;"><strong>Requirements:</strong></p>
            <ul class="text font-body" style="margin: 0 0 10px 0; padding-left: 20px; line-height: 1.5;">
                <li>The saved Robux will go to RoValra to help fund development</li>
                <li>You still get the item you're purchasing</li>
                <li>And you will support RoValra at no extra cost for you.</li>
            </ul>
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn-secondary-md btn-min-width" id="sr-rovalra-back-btn" style="flex: 1;">Back</button>
                <button class="btn-cta-md btn-min-width" id="sr-rovalra-confirm-btn" style="flex: 1;">I Understand & Continue</button>
            </div>
        </div>

        <div id="sr-view-validation-warning" class="sr-hidden">
            <h4 class="text font-header-2" style="margin: 0 0 10px 0;">Validation Warning</h4>
            <div id="sr-validation-message-container"></div>
            <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 16px;">
                <button class="btn-cta-md btn-min-width" id="sr-validation-create-btn" style="display: none;">Create New Experience</button>
                <button class="btn-cta-md btn-min-width" id="sr-validation-update-btn" style="display: none;">Update Experience</button>
                <button class="btn-secondary-md btn-min-width" id="sr-validation-use-anyway-btn">Use Anyway</button>
            </div>
        </div>

        <div id="sr-view-permission-error" class="sr-hidden">
            <h4 class="text font-header-2" style="margin: 0 0 10px 0;">Permission Required</h4>
            <p class="text font-body" style="margin: 5px 0 12px 0; line-height: 1.5;">You don't have permission to manage experiences for this group. You need a role with creation/management rights. You can pick a different group or choose the donate option instead.</p>
            <div style="display: flex; gap: 8px;">
                <button class="btn-secondary-md btn-min-width" id="sr-permission-error-back-btn" style="flex: 1;">Back to Group Selection</button>
            </div>
        </div>

        <div id="sr-view-update-instructions" class="sr-hidden">
            <h4 class="text font-header-2" style="margin: 0 0 10px 0;">Update Experience</h4>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height: 1.5;">
                Experience: <strong id="sr-update-game-name">Loading...</strong>
            </p>
            <p class="text font-body" style="margin: 5px 0 10px 0; line-height: 1.5;">Your experience is outdated. To ensure it works correctly, please update it.</p>
            
            <div style="background-color: rgba(211, 47, 47, 0.1); border: 1px solid rgba(211, 47, 47, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                <p class="text font-body" style="margin: 0 0 8px 0; font-weight: 600; color: #d32f2f;">\u26A0\uFE0F WARNING: This will overwrite your game!</p>
                <p class="text font-body" style="margin: 0; font-size: 14px;">Updating will replace the entire experience with the latest 40% method template. Any existing work in this place will be overwritten.</p>
            </div>

            <div style="margin-bottom: 16px;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="sr-update-agree-checkbox" style="width: 16px; height: 16px;">
                    <span class="text font-body" style="font-size: 14px;">I agree to overwrite this experience</span>
                </label>
            </div>

            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn-secondary-md btn-min-width" id="sr-update-use-anyway-btn" style="flex: 1;">Use Anyway</button>
                <button class="btn-cta-md btn-min-width" id="sr-update-confirm-btn" style="flex: 1;" disabled>Update Now</button>
            </div>
        </div>
    `, { ADD_ATTR: ["target", "allow", "allowfullscreen", "frameborder"], ADD_TAGS: ["iframe"] });
    let saveBtn = document.createElement("button");
    saveBtn.textContent = "Save & Continue", saveBtn.className = "btn-cta-md btn-min-width", saveBtn.id = "sr-save-btn";
    let { overlay, close } = createOverlay({
      title: "Set Up Your Game",
      bodyContent,
      actions: [saveBtn],
      maxWidth: "500px",
      showLogo: !0
    });
    overlay.addEventListener("click", (e) => {
      e.target === overlay && (e.stopPropagation(), e.stopImmediatePropagation());
    }, !0);
    let style = document.createElement("style");
    style.textContent = ".sr-hidden { display: none !important; }", document.head.appendChild(style);
    let gameIdInputContainer = bodyContent.querySelector("#sr-game-id-input-container"), { container: gameIdInputWrapper, input: gameIdInput } = createStyledInput({
      id: "sr-game-id-input",
      label: "Place ID",
      placeholder: " "
    });
    gameIdInputContainer.appendChild(gameIdInputWrapper);
    let gameIdErrorEl = document.createElement("div");
    gameIdErrorEl.id = "sr-game-id-error", gameIdErrorEl.className = "text font-body", gameIdErrorEl.style.cssText = "margin-top:6px;font-size:12px;color:#d32f2f;display:none;", gameIdInputContainer.appendChild(gameIdErrorEl);
    let findingGameSpinner = bodyContent.querySelector("#sr-finding-game-spinner");
    findingGameSpinner && findingGameSpinner.appendChild(createSpinner({ size: "48px", color: "currentColor" }));
    let groupDropdownContainer = bodyContent.querySelector("#sr-group-dropdown-container"), viewMain = bodyContent.querySelector("#sr-view-main"), viewNonOwnerAck = bodyContent.querySelector("#sr-view-non-owner-ack"), viewOwnerWarning = bodyContent.querySelector("#sr-view-owner-warning"), ownerWarningBackBtn = bodyContent.querySelector("#sr-owner-warning-back-btn"), viewWIP = bodyContent.querySelector("#sr-view-wip"), viewManualCreateInstructions = bodyContent.querySelector("#sr-view-manual-create-instructions"), viewFindingGame = bodyContent.querySelector("#sr-view-finding-game"), viewRoValraGroup = bodyContent.querySelector("#sr-view-rovalra-group"), viewPermissionError = bodyContent.querySelector("#sr-view-permission-error"), viewValidationWarning = bodyContent.querySelector("#sr-view-validation-warning"), viewUpdateInstructions = bodyContent.querySelector("#sr-view-update-instructions"), updateUseAnywayBtn = bodyContent.querySelector("#sr-update-use-anyway-btn"), updateGameNameEl = bodyContent.querySelector("#sr-update-game-name"), updateConfirmBtn = bodyContent.querySelector("#sr-update-confirm-btn"), updateAgreeCheckbox = bodyContent.querySelector("#sr-update-agree-checkbox"), validationUseAnywayBtn = bodyContent.querySelector("#sr-validation-use-anyway-btn"), validationCreateBtn = bodyContent.querySelector("#sr-validation-create-btn"), validationUpdateBtn = bodyContent.querySelector("#sr-validation-update-btn"), permissionErrorBackBtn = bodyContent.querySelector("#sr-permission-error-back-btn"), acknowledgeBtn = bodyContent.querySelector("#sr-acknowledge-btn"), useRoValraGroupBtn = bodyContent.querySelector("#sr-use-rovalra-group-btn"), rovalraBackBtn = bodyContent.querySelector("#sr-rovalra-back-btn"), rovalraConfirmBtn = bodyContent.querySelector("#sr-rovalra-confirm-btn"), createNewGameBtn = bodyContent.querySelector("#sr-create-new-game-btn"), manualAckView = bodyContent.querySelector("#sr-view-manual-ack"), manualAckBtn = bodyContent.querySelector("#sr-manual-ack-btn"), manualCreateBackBtn = bodyContent.querySelector("#sr-manual-create-back-btn"), manualCreateDoneBtn = bodyContent.querySelector("#sr-manual-create-done-btn"), notFoundBackBtn = bodyContent.querySelector("#sr-not-found-back-btn"), notFoundRetryBtn = bodyContent.querySelector("#sr-not-found-retry-btn"), editGameLink = bodyContent.querySelector("#sr-edit-game-link"), manualPlaceIdCandidate = null, manualUniverseIdCandidate = null, lastValidationReason = null, initialUserPlaceVersion = 0, safeSaveSettings = /* @__PURE__ */ __name((placeId, useGroup, onSuccess) => {
      typeof chrome < "u" && chrome.storage && chrome.storage.local ? chrome.storage.local.set({
        RobuxPlaceId: placeId,
        useRoValraGroup: useGroup
      }, () => {
        chrome.runtime.lastError ? (console.error("Mania Ext: Storage save error:", chrome.runtime.lastError), alert("Failed to save settings: " + chrome.runtime.lastError.message)) : onSuccess && onSuccess();
      }) : (console.error("Mania Ext: Storage API unavailable."), alert("Failed to save settings. Storage API unavailable."));
    }, "safeSaveSettings"), groupDropdown = null, selectedGroupId = null, initialGroupGames = [], showValidationWarning = /* @__PURE__ */ __name(async (reason, placeId, universeId, gameName = null) => {
      lastValidationReason = reason, gameName && updateGameNameEl && (updateGameNameEl.textContent = gameName);
      let container = bodyContent.querySelector("#sr-validation-message-container");
      if (validationUpdateBtn.style.display = "none", validationCreateBtn.style.display = "none", reason === "missing_metadata" || reason === "wrong_source" ? (container.innerHTML = purify.sanitize(`
                <p class="text font-body" style="margin-bottom: 10px;">This experience does not appear to support the 40% method (missing or invalid metadata).</p>
                <p class="text font-body" style="margin-bottom: 10px;">You can update the experience to fix this, or create a new one.</p>
            `), validationCreateBtn.style.display = "block", validationUpdateBtn.style.display = "block") : reason === "outdated" ? (container.innerHTML = purify.sanitize(`
                <p class="text font-body" style="margin-bottom: 10px;">Your game version is out of sync with the latest template.</p>
                <p class="text font-body" style="margin-bottom: 10px;">Please update your game to avoid issues with purchases.</p>
            `), validationUpdateBtn.style.display = "block") : container.innerHTML = '<p class="text font-body">Validation failed. Please check your game settings.</p>', manualPlaceIdCandidate = placeId, manualUniverseIdCandidate = universeId, viewMain.classList.add("sr-hidden"), saveBtn.style.display = "none", reason === "outdated") {
        try {
          let vResp = await callRobloxApiJson({
            subdomain: "develop",
            endpoint: "/v1/assets/latest-versions",
            method: "POST",
            body: { assetIds: [placeId], versionStatus: "Published" }
          });
          vResp && vResp.results && vResp.results.length > 0 && (initialUserPlaceVersion = vResp.results[0].versionNumber);
        } catch (e) {
          console.error("Mania Ext: Failed to fetch initial place version", e);
        }
        viewUpdateInstructions.classList.remove("sr-hidden");
        return;
      }
      initialState && initialState.view, viewValidationWarning.classList.remove("sr-hidden");
    }, "showValidationWarning"), handleGroupSelection = /* @__PURE__ */ __name(async (groupId) => {
      if (groupId) {
        selectedGroupId = groupId, viewMain.classList.add("sr-hidden"), saveBtn.style.display = "none";
        try {
          let data = await callRobloxApiJson({
            subdomain: "groups",
            endpoint: `/v1/groups/${groupId}`
          });
          data.owner && String(data.owner.userId) === currentUserId ? viewOwnerWarning.classList.remove("sr-hidden") : viewNonOwnerAck.classList.remove("sr-hidden");
        } catch (error) {
          console.error("Failed to fetch group details:", error), close(), alert("Could not check group ownership. Please try again.");
        }
      }
    }, "handleGroupSelection"), loadGroups = /* @__PURE__ */ __name(async () => {
      try {
        let data = await callRobloxApiJson({
          subdomain: "apis",
          endpoint: "/creator-home-api/v1/groups"
        }), groupItems = [
          { value: "", label: "-- Please choose a group --" },
          ...data.groups.map((group) => ({
            value: String(group.id),
            label: group.name
          }))
        ];
        groupDropdown = createDropdown({
          items: groupItems,
          initialValue: "",
          onValueChange: handleGroupSelection,
          showFlags: !1
        }), groupDropdownContainer.appendChild(groupDropdown.element);
        try {
          groupDropdown.element.style.width = "100%";
          let selectEl = groupDropdown.element.querySelector("select");
          selectEl && (selectEl.style.height = "40px", selectEl.style.borderRadius = "8px", selectEl.style.padding = "0 14px", selectEl.style.boxSizing = "border-box", selectEl.style.width = "100%");
        } catch {
        }
      } catch (error) {
        console.error("Mania Ext: Failed to fetch groups:", error), groupDropdownContainer.innerHTML = purify.sanitize('<div class="text font-body" style="color: var(--rovalra-secondary-text-color);">Failed to load groups. Please refresh and try again.</div>');
      }
    }, "loadGroups");
    acknowledgeBtn.addEventListener("click", () => {
      if (manualPlaceIdCandidate !== null) {
        let placeIdToSave = manualPlaceIdCandidate;
        manualPlaceIdCandidate = null, viewNonOwnerAck.classList.add("sr-hidden"), safeSaveSettings(placeIdToSave, !1, async () => {
          close(), await showInitialConfirmation(placeIdToSave, !1), onSave();
        });
      } else
        viewNonOwnerAck.classList.add("sr-hidden"), viewWIP.classList.remove("sr-hidden");
    }), manualAckBtn.addEventListener("click", () => {
      if (manualAckView.classList.add("sr-hidden"), manualPlaceIdCandidate !== null) {
        let placeIdToSave = manualPlaceIdCandidate;
        manualPlaceIdCandidate = null, safeSaveSettings(placeIdToSave, !1, async () => {
          close(), await showInitialConfirmation(placeIdToSave, !1), onSave();
        });
      }
    }), createNewGameBtn.addEventListener("click", async () => {
      let errorEl = bodyContent.querySelector("#sr-create-game-error");
      if (errorEl && (errorEl.style.display = "none"), !selectedGroupId) {
        alert("No group selected. Please try again.");
        return;
      }
      createNewGameBtn.disabled = !0;
      let originalText = createNewGameBtn.textContent;
      createNewGameBtn.textContent = "Creating...";
      try {
        let createResponse = await callRobloxApiJson({
          subdomain: "apis",
          endpoint: `/universes/v1/universes/create?groupId=${selectedGroupId}`,
          method: "POST",
          body: {
            templatePlaceId: 95206881,
            isPublish: !0
          }
        });
        if (!createResponse || !createResponse.rootPlaceId)
          throw new Error("Failed to create universe");
        let newUniverseId = createResponse.universeId, newPlaceId = createResponse.rootPlaceId;
        console.log(`Mania Ext: Created Universe ${newUniverseId}, Place ${newPlaceId}`), createNewGameBtn.textContent = "Uploading Template...", await publishTemplateToPlace(newPlaceId, newUniverseId), createNewGameBtn.textContent = "Configuring...", await updateGameDescription(newUniverseId, ROVALRA_PLACE_ID);
        try {
          await callRobloxApiJson({
            subdomain: "develop",
            endpoint: `/v2/universes/${newUniverseId}/configuration`,
            method: "PATCH",
            body: {
              permissions: {
                IsThirdPartyPurchaseAllowed: !0
              }
            }
          });
        } catch (permErr) {
          console.warn("Could not auto-enable third party sales", permErr);
        }
        createNewGameBtn.textContent = "Done!", safeSaveSettings(newPlaceId, !1, async () => {
          close(), await showInitialConfirmation(newPlaceId, !1), typeof onSave == "function" && onSave();
        });
      } catch (error) {
        console.error("Mania Ext: Create Game Error", error), errorEl ? (error.response && error.response.code === "InvalidRequest" && error.response.message === "User is not authorized to perform this action" ? errorEl.textContent = "You don't have permission to manage experiences in this group. Please give yourself a role with the right permissions." : errorEl.textContent = `Error creating experience: ${error.message}. Please try again.`, errorEl.style.display = "block") : alert(`Error creating experience: ${error.message}. Please try again.`), createNewGameBtn.textContent = originalText, createNewGameBtn.disabled = !1;
      }
    }), manualCreateBackBtn.addEventListener("click", () => {
      viewManualCreateInstructions.classList.add("sr-hidden"), viewWIP.classList.remove("sr-hidden");
    }), editGameLink && editGameLink.addEventListener("click", async (e) => {
      e.preventDefault(), await launchStudioForGame(ROVALRA_PLACE_ID);
    }), manualCreateDoneBtn.addEventListener("click", async () => {
      viewManualCreateInstructions.classList.add("sr-hidden"), viewFindingGame.classList.remove("sr-hidden");
      try {
        await new Promise((resolve) => setTimeout(resolve, 3e3));
        let newGroupGames = await fetchGamesForGroup(selectedGroupId), initialGameIds = new Set(initialGroupGames.map((g2) => g2.rootPlaceId)), newGames = newGroupGames.filter((g2) => !initialGameIds.has(g2.rootPlaceId));
        if (newGames.length === 1) {
          let newGame = newGames[0], rootPlaceId = newGame.rootPlaceId;
          await updateGameDescription(newGame.id, ROVALRA_PLACE_ID), safeSaveSettings(rootPlaceId, !1, async () => {
            close(), await showInitialConfirmation(rootPlaceId, !1), onSave();
          });
        } else
          viewFindingGame.classList.add("sr-hidden");
      } catch (error) {
        console.error("Failed to find new experience:", error), viewFindingGame.classList.add("sr-hidden");
      }
    }), useRoValraGroupBtn.addEventListener("click", () => {
      viewMain.classList.add("sr-hidden"), saveBtn.style.display = "none", viewRoValraGroup.classList.remove("sr-hidden");
    }), rovalraBackBtn.addEventListener("click", () => {
      viewRoValraGroup.classList.add("sr-hidden"), viewMain.classList.remove("sr-hidden"), saveBtn.style.display = "";
    }), ownerWarningBackBtn && ownerWarningBackBtn.addEventListener("click", () => {
      if (viewOwnerWarning.classList.add("sr-hidden"), viewMain.classList.remove("sr-hidden"), saveBtn.style.display = "", selectedGroupId = null, groupDropdown && groupDropdown.element) {
        let selectEl = groupDropdown.element.querySelector("select");
        selectEl && (selectEl.value = "");
      }
    }), permissionErrorBackBtn && permissionErrorBackBtn.addEventListener("click", () => {
      if (viewPermissionError.classList.add("sr-hidden"), viewMain.classList.remove("sr-hidden"), saveBtn.style.display = "", selectedGroupId = null, groupDropdown && groupDropdown.element) {
        let selectEl = groupDropdown.element.querySelector("select");
        selectEl && (selectEl.value = "");
      }
    });
    let handleUseAnyway = /* @__PURE__ */ __name(() => {
      manualPlaceIdCandidate !== null ? safeSaveSettings(manualPlaceIdCandidate, !1, () => {
        close(), onSave();
      }) : (close(), onSave());
    }, "handleUseAnyway");
    validationUseAnywayBtn.addEventListener("click", handleUseAnyway), validationCreateBtn.addEventListener("click", () => {
      viewValidationWarning.classList.add("sr-hidden"), createNewGameBtn.click();
    }), validationUpdateBtn.addEventListener("click", () => {
      viewValidationWarning.classList.add("sr-hidden"), viewUpdateInstructions.classList.remove("sr-hidden");
    }), updateUseAnywayBtn.addEventListener("click", handleUseAnyway), updateAgreeCheckbox && updateAgreeCheckbox.addEventListener("change", () => {
      updateConfirmBtn.disabled = !updateAgreeCheckbox.checked;
    }), updateConfirmBtn.addEventListener("click", async () => {
      let originalText = updateConfirmBtn.textContent;
      updateConfirmBtn.textContent = "Updating...", updateConfirmBtn.disabled = !0;
      try {
        if (await publishTemplateToPlace(manualPlaceIdCandidate), manualUniverseIdCandidate) {
          await updateGameDescription(manualUniverseIdCandidate, ROVALRA_PLACE_ID);
          try {
            await callRobloxApiJson({
              subdomain: "develop",
              endpoint: `/v2/universes/${manualUniverseIdCandidate}/configuration`,
              method: "PATCH",
              body: { permissions: { IsThirdPartyPurchaseAllowed: !0 } }
            });
          } catch (permErr) {
            console.warn("Could not auto-enable third party sales", permErr);
          }
        }
        viewUpdateInstructions.classList.add("sr-hidden"), manualAckView.classList.remove("sr-hidden");
      } catch (e) {
        console.error("Mania Ext: Update failed", e), alert(`Update failed: ${e.message}. Please try again.`);
      } finally {
        updateConfirmBtn.textContent = originalText, updateConfirmBtn.disabled = !updateAgreeCheckbox.checked;
      }
    }), rovalraConfirmBtn.addEventListener("click", async () => {
      safeSaveSettings("ROVALRA_GROUP", !0, async () => {
        close(), await showInitialConfirmation("ROVALRA_GROUP", !0), onSave();
      });
    }), saveBtn.addEventListener("click", async () => {
      gameIdErrorEl.style.display = "none", gameIdErrorEl.textContent = "";
      let gameId = gameIdInput.value.trim(), parsedId = parseInt(gameId, 10);
      if (!gameId || isNaN(parsedId) || String(parsedId) !== gameId) {
        gameIdErrorEl.textContent = "Please enter a valid numeric Experience / Place ID.", gameIdErrorEl.style.display = "block";
        return;
      }
      try {
        let data = await callRobloxApiJson({
          subdomain: "games",
          endpoint: `/v1/games/multiget-place-details?placeIds=${parsedId}`,
          method: "GET"
        });
        if (!Array.isArray(data) || data.length === 0) {
          gameIdErrorEl.textContent = "That Experience / Place ID does not exist. Double-check the number.", gameIdErrorEl.style.display = "block";
          return;
        }
        let universeId = data[0].universeId, gameName = data[0].name, validation = await validateGameSync(universeId, parsedId);
        if (!validation.valid) {
          showValidationWarning(validation.reason, parsedId, universeId, gameName);
          return;
        }
      } catch (e) {
        console.error("Failed to validate place ID:", e), gameIdErrorEl.textContent = "Could not validate the ID. Please try again.", gameIdErrorEl.style.display = "block";
        return;
      }
      manualPlaceIdCandidate = parsedId, viewMain.classList.add("sr-hidden"), saveBtn.style.display = "none", manualAckView.classList.remove("sr-hidden");
    }), initialState && initialState.view === "validation-warning" ? showValidationWarning(initialState.reason, initialState.placeId, initialState.universeId, initialState.gameName) : loadGroups();
  }, "createAndShowPopup");
  var showInitialConfirmation = /* @__PURE__ */ __name(async (savedPlaceId, useRoValraGroup) => {
    if (!getCurrentUserId()) return !1;
    let gameName = "Unknown Experience", gameThumbnailUrl = "", actualPlaceId = savedPlaceId, universeId = null;
    (useRoValraGroup || savedPlaceId === "ROVALRA_GROUP") && (actualPlaceId = ROVALRA_PLACE_ID, gameName = "RoValra Group Experience");
    try {
      let gameData = await callRobloxApiJson({
        subdomain: "games",
        endpoint: `/v1/games/multiget-place-details?placeIds=${actualPlaceId}`,
        method: "GET"
      });
      if (gameData && gameData.length > 0) {
        gameName = gameData[0].name || "Unknown Experience";
        let universeId2 = gameData[0].universeId;
        if (universeId2) {
          let thumbnailData = (await fetchThumbnails([{ id: universeId2 }], "GameIcon", "150x150")).get(universeId2);
          thumbnailData && thumbnailData.state === "Completed" && (gameThumbnailUrl = thumbnailData.imageUrl);
        }
      }
    } catch (error) {
      console.warn("Mania Ext: Could not fetch game details:", error);
    }
    let isDonating = useRoValraGroup || savedPlaceId === "ROVALRA_GROUP", confirmBody = document.createElement("div");
    confirmBody.style.cssText = "padding: 10px 0;", confirmBody.innerHTML = purify.sanitize(`
        <div style="padding: 16px 0; margin-bottom: 16px; text-align: center; border-bottom: 1px solid rgb(73, 77, 90);">
            <div class="text font-body" style="margin-bottom: 4px; font-weight: 600;">${isDonating ? "ESTIMATED COMMISSION" : "ESTIMATED SAVINGS"}</div>
            <div class="text font-body" style="font-size: 14px; opacity: .85;">Catalog items: 40% \u2022 Game passes: 10%</div>
            ${isDonating ? '<div class="text font-body" style="margin-top: 4px;">\u2764\uFE0F Donating to RoValra \u2764\uFE0F</div>' : ""}
        </div>
        <div style="padding: 12px 0; margin-bottom: 16px; border-bottom: 1px solid rgb(73, 77, 90);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                <span class="text font-body" style="font-weight: 600;">USING EXPERIENCE</span>
                <button id="change-game-btn" class="btn-secondary-sm text font-body" style="padding: 6px 12px;">
                    Change
                </button>
            </div>
            <div style="display: flex; gap: 12px; align-items: center;">
                ${gameThumbnailUrl ? `
                    <img src="${gameThumbnailUrl}" alt="${gameName}" style="width: 60px; height: 60px; border-radius: 4px; flex-shrink: 0;">
                ` : `
                    <div style="width: 60px; height: 60px; background: #bdbebe; border-radius: 4px; flex-shrink: 0;"></div>
                `}
                <div style="flex: 1; min-width: 0;">
                    <div class="text font-body" style="font-weight: 600; margin-bottom: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${gameName}</div>
                    <div class="text font-body" style="font-size: 12px;">Place ID: ${actualPlaceId}</div>
                    ${useRoValraGroup || savedPlaceId === "ROVALRA_GROUP" ? '<div class="text font-body" style="font-size: 12px;">Donating to RoValra \u2764\uFE0F</div>' : ""}
                </div>
            </div>
        </div>
        <div style="padding: 12px 0; margin-bottom: 16px; border-bottom: 1px solid rgb(73, 77, 90);">
            <div class="text font-body" style="font-weight: 600; margin-bottom: 8px;">HOW THIS WORKS</div>
            <ol class="text font-body" style="margin: 0; padding-left: 20px;">
                <li>Roblox will launch and join the server automatically</li>
                <li>Once you're in-game, the purchase prompt will show and you just buy the item using that.</li>
                <li>The item goes to you, ${useRoValraGroup || savedPlaceId === "ROVALRA_GROUP" ? "and RoValra will earn a commission on your purchase which will help support the extension, at no extra cost for you." : "but 40% of the Robux goes to your group"}</li>
                ${useRoValraGroup || savedPlaceId === "ROVALRA_GROUP" ? "" : "<li>Robux will be pending for ~1 month</li>"}
            </ol>
        </div>
        
    `);
    let confirmBtn = document.createElement("button");
    confirmBtn.textContent = "Got It", confirmBtn.className = "btn-cta-md btn-min-width";
    let { overlay: confirmOverlay, close: closeConfirm } = createOverlay({
      title: "Confirm 40% Method Purchase",
      bodyContent: confirmBody,
      actions: [confirmBtn],
      maxWidth: "500px",
      showLogo: !0
    });
    return confirmOverlay.addEventListener("click", (e) => {
      e.target === confirmOverlay && (e.stopPropagation(), e.stopImmediatePropagation());
    }, !0), confirmBody.querySelector("#change-game-btn").addEventListener("click", () => {
      closeConfirm(), createAndShowPopup(() => {
      });
    }), new Promise((resolve) => {
      confirmBtn.addEventListener("click", () => {
        closeConfirm(), resolve(!0);
      });
      let closeBtn = confirmOverlay.querySelector(".foundation-web-dialog-close-container button");
      closeBtn && closeBtn.addEventListener("click", () => {
        closeConfirm(), resolve(!1);
      });
    });
  }, "showInitialConfirmation"), activePurchaseContext = null, executeCartPurchase = /* @__PURE__ */ __name(async (cartItems, prefetchData = null, bypassValidation = !1) => {
    activePurchaseContext = { cancelled: !1 };
    let ctx = activePurchaseContext, ensureNotCancelled = /* @__PURE__ */ __name(() => {
      if (ctx.cancelled) throw new Error("Purchase cancelled");
    }, "ensureNotCancelled"), currentUserId = getCurrentUserId();
    if (!currentUserId) {
      alert("Could not identify your user ID. Please make sure you are logged in.");
      return;
    }
    try {
      let itemIds = cartItems.map((item) => ({ id: parseInt(item.id) })), thumbnailMap;
      prefetchData && prefetchData.cartThumbnails ? thumbnailMap = await prefetchData.cartThumbnails : thumbnailMap = await fetchThumbnails(itemIds, "Asset", "150x150"), cartItems.forEach((item) => {
        let thumbnailData = thumbnailMap.get(parseInt(item.id));
        thumbnailData && thumbnailData.state === "Completed" && (item.thumbnail = thumbnailData.imageUrl);
      });
    } catch (error) {
      console.warn("Mania Ext: Could not fetch cart item thumbnails:", error);
    }
    let result;
    prefetchData && prefetchData.storage ? result = await prefetchData.storage : result = await new Promise((resolve) => {
      chrome.storage.local.get(["RobuxPlaceId", "useRoValraGroup"], resolve);
    });
    let savedPlaceId = result.RobuxPlaceId, useRoValraGroup = result.useRoValraGroup === !0;
    if (!savedPlaceId) {
      alert('No saved Place ID. Please set one up first using the "Save Robux" button.');
      return;
    }
    let gameName = "Unknown Experience", gameThumbnailUrl = "", actualPlaceId = savedPlaceId, universeId = null;
    if ((useRoValraGroup || savedPlaceId === "ROVALRA_GROUP") && (actualPlaceId = ROVALRA_PLACE_ID, gameName = "RoValra Group Experience"), prefetchData && prefetchData.gameInfo)
      try {
        let info = await prefetchData.gameInfo;
        info && info.data && info.data.length > 0 && (gameName = info.data[0].name || "Unknown Experience", universeId = info.data[0].universeId), prefetchData.gameThumb && (gameThumbnailUrl = await prefetchData.gameThumb || "");
      } catch (e) {
        console.warn("Mania Ext: Prefetch game info error", e);
      }
    else
      try {
        let gameData = await callRobloxApiJson({
          subdomain: "games",
          endpoint: `/v1/games/multiget-place-details?placeIds=${actualPlaceId}`,
          method: "GET"
        });
        if (gameData && gameData.length > 0 && (gameName = gameData[0].name || "Unknown Experience", universeId = gameData[0].universeId, universeId)) {
          let thumbnailData = (await fetchThumbnails([{ id: universeId }], "GameIcon", "150x150")).get(universeId);
          thumbnailData && thumbnailData.state === "Completed" && (gameThumbnailUrl = thumbnailData.imageUrl);
        }
      } catch (error) {
        console.warn("Mania Ext: Could not fetch game details:", error);
      }
    if (!useRoValraGroup && savedPlaceId !== "ROVALRA_GROUP" && universeId && !bypassValidation) {
      let validation = await validateGameSync(universeId, actualPlaceId);
      if (!validation.valid) {
        let reason = validation.reason;
        reason === "missing_metadata" && (reason = "outdated"), createAndShowPopup(() => {
          let freshPrefetch = prefetchData ? { ...prefetchData, storage: null, gameInfo: null, gameThumb: null } : null;
          executeCartPurchase(cartItems, freshPrefetch, !0);
        }, { view: "validation-warning", reason, placeId: actualPlaceId, universeId, gameName });
        return;
      }
    }
    let userRobux = 0;
    if (prefetchData && prefetchData.balance)
      try {
        userRobux = (await prefetchData.balance).robux || 0;
      } catch {
      }
    else
      try {
        userRobux = (await callRobloxApiJson({
          subdomain: "economy",
          endpoint: `/v1/users/${currentUserId}/currency`,
          method: "GET"
        })).robux || 0;
      } catch (error) {
        console.warn("Could not fetch user balance:", error);
      }
    ensureNotCancelled();
    let ownershipChecks;
    prefetchData && prefetchData.cartOwnership ? ownershipChecks = await prefetchData.cartOwnership : ownershipChecks = await Promise.all(
      cartItems.map((item) => checkItemOwnership(currentUserId, item.id, "Asset"))
    );
    let ownedItems = [], itemsToPurchase = [];
    if (cartItems.forEach((item, index) => {
      ownershipChecks[index] ? ownedItems.push(item) : itemsToPurchase.push(item);
    }), itemsToPurchase.length === 0) {
      let errorBody = document.createElement("div");
      errorBody.innerHTML = purify.sanitize(`
            <div style="padding: 20px; text-align: center;">
                <div style="font-size: 48px; margin-bottom: 16px;">\u2713</div>
                <h3 class="text font-header-2" style="margin: 0 0 12px 0;">All Items Already Owned</h3>
                <p class="text font-body" style="margin: 0;">You already own all ${cartItems.length} items in your cart. No purchase needed!</p>
            </div>
        `);
      let { overlay, close } = createOverlay({
        title: "Already Owned",
        bodyContent: errorBody,
        actions: [],
        maxWidth: "400px",
        showLogo: !0
      });
      return;
    }
    let actualTotalPrice = itemsToPurchase.reduce((sum, item) => sum + item.price, 0), robuxAfterPurchase = userRobux - actualTotalPrice, isDonating = useRoValraGroup || savedPlaceId === "ROVALRA_GROUP", totalSavings = Math.round(actualTotalPrice * 0.4), itemsHtml = "";
    cartItems.forEach((item, index) => {
      let isOwned = ownershipChecks[index];
      itemsHtml += `
            <div style="display: flex; gap: 12px; align-items: center; padding: 8px 4px; ${isOwned ? "opacity: 0.6;" : ""}">
                ${item.thumbnail ? `<img src="${item.thumbnail}" alt="${item.name}" style="width: 60px; height: 60px; border-radius: 4px; flex-shrink: 0; object-fit: cover;">` : '<div style="width: 60px; height: 60px; background: #bdbebe; border-radius: 4px; flex-shrink: 0;"></div>'}
                <div style="flex: 1; min-width: 0;">
                    <div class="text font-body" style="font-size: 14px; font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-bottom: 4px;">${item.name}${isOwned ? ' <span style="color: #ffa500;">(Already Owned)</span>' : ""}</div>
                    <div class="text font-body" style="font-size: 13px; display: flex; align-items: center; gap: 4px;"><span class="icon-robux-16x16"></span>${item.price.toLocaleString()}</div>
                </div>
            </div>
        `;
    });
    let finalConfirmBody = document.createElement("div");
    finalConfirmBody.style.cssText = "padding: 0;", finalConfirmBody.innerHTML = purify.sanitize(`
        <div style="padding: 12px 0 8px; text-align: center; border-bottom: 1px solid rgb(73, 77, 90);">
            <div class="text font-body" style="font-size: 16px; font-weight: 700;">Cart Purchase Summary</div>
            ${isDonating ? '<div class="text font-body" style="margin-top: 4px; font-size: 12px;">\u2764\uFE0F Donating to RoValra \u2764\uFE0F</div>' : ""}
        </div>
        <div style="padding: 8px 0; border-bottom: 1px solid rgb(73, 77, 90);">
            <div class="text font-body" style="font-weight: 600; margin-bottom: 6px; font-size: 13px;">PURCHASING ${itemsToPurchase.length} ITEM${itemsToPurchase.length !== 1 ? "S" : ""}${ownedItems.length > 0 ? ` (${ownedItems.length} Already Owned)` : ""}</div>
            <div style="display: flex; flex-direction: column; gap: 4px; max-height: 180px; overflow-y: auto;">
                ${itemsHtml}
            </div>
        </div>
        <details style="border-bottom: 1px solid rgb(73, 77, 90); padding: 8px 0;">
            <summary style="cursor: pointer; list-style: none; display: flex; align-items: center; justify-content: space-between;">
                <span class="text font-body" style="font-weight: 600; font-size: 13px;">USING EXPERIENCE</span>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <button id="change-experience-btn" class="btn-secondary-sm text font-body" style="padding: 4px 10px; font-size: 12px;" onclick="event.stopPropagation();">
                        Change
                    </button>
                    <span style="font-size: 12px;">\u25BC</span>
                </div>
            </summary>
            <div style="padding-top: 8px; display: flex; gap: 10px; align-items: center;">
                ${gameThumbnailUrl ? `
                    <img src="${gameThumbnailUrl}" alt="${gameName}" style="width: 40px; height: 40px; border-radius: 4px; flex-shrink: 0;">
                ` : `
                    <div style="width: 40px; height: 40px; background: #bdbebe; border-radius: 4px; flex-shrink: 0;"></div>
                `}
                <div style="flex: 1; min-width: 0;">
                    <div class="text font-body" style="font-weight: 600; font-size: 13px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${gameName}</div>
                    <div class="text font-body" style="font-size: 11px; opacity: 0.7;">Place ID: ${actualPlaceId}</div>
                    ${isDonating ? '<div class="text font-body" style="font-size: 11px; opacity: 0.7;">Donating to RoValra \u2764\uFE0F</div>' : ""}
                </div>
            </div>
        </details>
        <div style="padding: 8px 0;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                <span class="text font-body" style="font-size: 13px;">Total:</span>
                <span class="text font-body" style="font-weight: 600; display: flex; align-items: center; gap: 4px;"><span class="icon-robux-16x16"></span>${actualTotalPrice.toLocaleString()}</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                <span class="text font-body" style="font-size: 13px;">Balance:</span>
                <span class="text font-body" style="display: flex; align-items: center; gap: 4px;"><span class="icon-robux-16x16"></span>${userRobux.toLocaleString()}</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid rgb(73, 77, 90);">
                <span class="text font-body" style="font-size: 13px;">After:</span>
                <span class="text font-body" style="font-weight: 600; ${robuxAfterPurchase < 0 ? "color: #d32f2f;" : ""} display: flex; align-items: center; gap: 4px;"><span class="icon-robux-16x16"></span>${robuxAfterPurchase.toLocaleString()}</span>
            </div>
            <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(0,128,0,0.05); border-radius: 4px;">
                <span class="text font-body" style="font-weight: 600; font-size: 13px;">${isDonating ? "RoValra gets:" : "You Save:"}</span>
                <span class="text font-body" style="font-size: 18px; font-weight: 700; display: flex; align-items: center; gap: 4px;"><span class="icon-robux-16x16"></span>${totalSavings.toLocaleString()}</span>
            </div>
        </div>
        ${robuxAfterPurchase < 0 ? '<div style="padding: 8px; border-radius: 4px; background: rgba(211, 47, 47, 0.1); margin-bottom: 8px; border: 1px solid rgba(211, 47, 47, 0.3);"><span class="text font-body" style="color: #d32f2f; font-weight: 600; font-size: 13px;">\u26A0\uFE0F Insufficient Balance</span></div>' : ""}
    `);
    let finalConfirmBtn = document.createElement("button");
    finalConfirmBtn.textContent = "Confirm Cart Purchase", finalConfirmBtn.className = "btn-cta-md btn-min-width", finalConfirmBtn.disabled = robuxAfterPurchase < 0;
    let finalCancelBtn = document.createElement("button");
    finalCancelBtn.textContent = "Cancel", finalCancelBtn.className = "btn-secondary-md btn-min-width";
    let { overlay: finalConfirmOverlay, close: origCloseFinalConfirm } = createOverlay({
      title: "Confirm Cart Purchase",
      bodyContent: finalConfirmBody,
      actions: [finalCancelBtn, finalConfirmBtn],
      maxWidth: "500px",
      showLogo: !0
    });
    finalConfirmOverlay.addEventListener("click", (e) => {
      e.target === finalConfirmOverlay && (e.stopPropagation(), e.stopImmediatePropagation());
    }, !0);
    let closeFinalConfirm = /* @__PURE__ */ __name(() => {
      ctx.cancelled || (ctx.cancelled = !0), origCloseFinalConfirm();
    }, "closeFinalConfirm"), changeExperienceBtn = finalConfirmBody.querySelector("#change-experience-btn");
    if (changeExperienceBtn && changeExperienceBtn.addEventListener("click", () => {
      closeFinalConfirm(), createAndShowPopup(() => {
        executeCartPurchase(cartItems, totalPrice);
      });
    }), !await new Promise((resolve) => {
      let settled = !1, finish = /* @__PURE__ */ __name((val) => {
        settled || (settled = !0, resolve(val));
      }, "finish");
      finalConfirmBtn.addEventListener("click", () => {
        if (ctx.cancelled) return finish(!1);
        ctx.cancelled = !1, origCloseFinalConfirm(), finish(!0);
      }), finalCancelBtn.addEventListener("click", () => {
        ctx.cancelled = !0, origCloseFinalConfirm(), finish(!1);
      });
      let closeBtn = finalConfirmOverlay.querySelector(".foundation-web-dialog-close-container button");
      closeBtn && closeBtn.addEventListener("click", () => {
        ctx.cancelled = !0, finish(!1);
      });
    }) || ctx.cancelled)
      return;
    let placeIdToUse = useRoValraGroup || savedPlaceId === "ROVALRA_GROUP" ? actualPlaceId : savedPlaceId, launchData = itemsToPurchase.map((item) => `asset:${item.id}`).join(",");
    launchMultiplayerGame(placeIdToUse, launchData);
  }, "executeCartPurchase"), execute40MethodPurchase = /* @__PURE__ */ __name(async (itemId, robuxPrice, isGamePass = !1, isBundle = !1, itemDetails = null, prefetchData = null, bypassValidation = !1) => {
    activePurchaseContext = { cancelled: !1 };
    let ctx = activePurchaseContext || { cancelled: !1 }, ensureNotCancelled = /* @__PURE__ */ __name(() => {
      if (ctx.cancelled) throw new Error("Purchase cancelled");
    }, "ensureNotCancelled"), currentUserId = getCurrentUserId();
    if (!currentUserId) {
      alert("Could not identify your user ID. Please make sure you are logged in.");
      return;
    }
    let result;
    prefetchData && prefetchData.storage ? result = await prefetchData.storage : result = await new Promise((resolve) => {
      chrome.storage.local.get(["RobuxPlaceId", "useRoValraGroup"], resolve);
    });
    let savedPlaceId = result.RobuxPlaceId, useRoValraGroup = result.useRoValraGroup === !0;
    if (!savedPlaceId) {
      alert('No saved Place ID. Please set one up first using the "Save Robux" button.');
      return;
    }
    let itemName = itemDetails?.name || "Unknown Item", itemThumbnail = itemDetails?.thumbnail || "", assetType = null;
    if (prefetchData && prefetchData.itemDetails)
      try {
        let details = await prefetchData.itemDetails;
        if (details && details.data && details.data[0]) {
          let item = details.data[0];
          (!itemName || itemName === "Unknown Item") && (itemName = item.name), assetType = item.assetType;
        }
      } catch {
      }
    if (itemId && (!itemDetails || !itemDetails.thumbnail || !isGamePass && !isBundle))
      if (isGamePass)
        try {
          let thumbnailData = (await fetchThumbnails(
            [{ id: parseInt(itemId) }],
            "GamePass",
            "150x150"
          )).get(parseInt(itemId));
          thumbnailData && thumbnailData.state === "Completed" && (itemThumbnail = thumbnailData.imageUrl);
        } catch (error) {
          console.warn("Mania Ext: Could not fetch game pass thumbnail:", error);
        }
      else
        try {
          let catalogData = await getItemDetails(itemId, isBundle ? "Bundle" : "Asset");
          if (catalogData && catalogData.data && catalogData.data.length > 0) {
            let item = catalogData.data[0];
            itemName = item.name || "Unknown Item", assetType = item.assetType;
            let itemIdForThumbnail = item.collectibleItemId || itemId, thumbnailType = "Asset";
            isBundle && (thumbnailType = "BundleThumbnail");
            let thumbnailData = (await fetchThumbnails(
              [{ id: parseInt(itemIdForThumbnail) }],
              thumbnailType,
              "150x150"
            )).get(parseInt(itemIdForThumbnail));
            thumbnailData && thumbnailData.state === "Completed" && (itemThumbnail = thumbnailData.imageUrl);
          }
        } catch (error) {
          console.warn("Mania Ext: Could not fetch item details:", error);
        }
    let gameName = "Unknown Experience", gameThumbnailUrl = "", actualPlaceId = savedPlaceId, universeId = null;
    if ((useRoValraGroup || savedPlaceId === "ROVALRA_GROUP") && (actualPlaceId = ROVALRA_PLACE_ID, gameName = "RoValra Group Experience"), prefetchData && prefetchData.gameInfo)
      try {
        let info = await prefetchData.gameInfo;
        info && info.data && info.data.length > 0 && (universeId = info.data[0].universeId, gameName = info.data[0].name || "Unknown Experience"), prefetchData.gameThumb && (gameThumbnailUrl = await prefetchData.gameThumb || "");
      } catch (e) {
        console.warn("Mania Ext: Prefetch game info error", e);
      }
    else
      try {
        let gameData = await callRobloxApiJson({
          subdomain: "games",
          endpoint: `/v1/games/multiget-place-details?placeIds=${actualPlaceId}`,
          method: "GET"
        });
        if (gameData && gameData.length > 0 && (gameName = gameData[0].name || "Unknown Experience", universeId = gameData[0].universeId, universeId)) {
          let thumbnailData = (await fetchThumbnails([{ id: universeId }], "GameIcon", "150x150")).get(universeId);
          thumbnailData && thumbnailData.state === "Completed" && (gameThumbnailUrl = thumbnailData.imageUrl);
        }
      } catch (error) {
        console.warn("Mania Ext: Could not fetch game details:", error);
      }
    if (!useRoValraGroup && savedPlaceId !== "ROVALRA_GROUP" && universeId && !bypassValidation) {
      let validation = await validateGameSync(universeId, actualPlaceId);
      if (!validation.valid) {
        let reason = validation.reason;
        reason === "missing_metadata" && (reason = "outdated"), createAndShowPopup(() => {
          let freshPrefetch = prefetchData ? { ...prefetchData, storage: null, gameInfo: null, gameThumb: null } : null;
          execute40MethodPurchase(itemId, robuxPrice, isGamePass, isBundle, itemDetails, freshPrefetch, !0);
        }, { view: "validation-warning", reason, placeId: actualPlaceId, universeId, gameName });
        return;
      }
    }
    ensureNotCancelled();
    let userRobux = 0;
    if (prefetchData && prefetchData.balance)
      try {
        userRobux = (await prefetchData.balance).robux || 0;
      } catch {
      }
    else
      try {
        userRobux = (await callRobloxApiJson({
          subdomain: "economy",
          endpoint: `/v1/users/${currentUserId}/currency`,
          method: "GET"
        })).robux || 0;
      } catch (error) {
        console.warn("Could not fetch user balance:", error);
      }
    ensureNotCancelled();
    let robuxAfterPurchase = userRobux - robuxPrice, isDonating = useRoValraGroup || savedPlaceId === "ROVALRA_GROUP", savingsPercentage = isGamePass ? 0.1 : 0.4;
    if (await fetchCatalogMetadata(), assetType && !isGamePass && !isBundle && assetToSubcategoryMap && classicClothingSubcategories) {
      let subcategoryId = assetToSubcategoryMap[String(assetType)];
      classicClothingSubcategories.includes(subcategoryId) && (robuxPrice < 10 ? savingsPercentage = 0 : savingsPercentage = 0.1);
    }
    let robuxSaved = Math.floor(robuxPrice * savingsPercentage), itemType = isGamePass ? "GamePass" : isBundle ? "Bundle" : "Asset";
    if (prefetchData && prefetchData.ownership ? await prefetchData.ownership : await checkItemOwnership(currentUserId, itemId, itemType)) {
      let ownedBody = document.createElement("div");
      ownedBody.innerHTML = purify.sanitize(`
            <div style="padding: 20px; text-align: center;">
                <div style="font-size: 48px; margin-bottom: 16px;">\u2713</div>
                <h3 class="text font-header-2" style="margin: 0 0 12px 0;">Already Owned</h3>
                <p class="text font-body" style="margin: 0 0 12px 0;">You already own this ${isGamePass ? "game pass" : isBundle ? "bundle" : "item"}:</p>
                <p class="text font-body" style="margin: 0; font-weight: 600;">${itemName}</p>
                <p class="text font-body" style="margin: 12px 0 0 0; opacity: 0.7;">No purchase needed!</p>
            </div>
        `);
      let { overlay, close } = createOverlay({
        title: "Already Owned",
        bodyContent: ownedBody,
        actions: [],
        maxWidth: "400px",
        showLogo: !0
      });
      return;
    }
    let singleItemHtml = `
            <div style="display: flex; gap: 12px; align-items: center; padding: 8px 4px;">
                ${itemThumbnail ? `<img src="${itemThumbnail}" alt="${itemName}" style="width: 60px; height: 60px; border-radius: 4px; flex-shrink: 0; object-fit: cover;">` : '<div style="width: 60px; height: 60px; background: #bdbebe; border-radius: 4px; flex-shrink: 0;"></div>'}
                <div style="flex: 1; min-width: 0;">
                    <div class="text font-body" style="font-size: 14px; font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-bottom: 4px;">${itemName}</div>
                    <div class="text font-body" style="font-size: 13px; display: flex; align-items: center; gap: 4px;"><span class="icon-robux-16x16"></span>${robuxPrice.toLocaleString()}</div>
                </div>
            </div>
        `, finalConfirmBody = document.createElement("div");
    finalConfirmBody.style.cssText = "padding: 0;", finalConfirmBody.innerHTML = purify.sanitize(`
            <div style="padding: 12px 0 8px; text-align: center; border-bottom: 1px solid rgb(73, 77, 90);">
                <div class="text font-body" style="font-size: 16px; font-weight: 700;">Purchase Summary</div>
                ${isDonating ? '<div class="text font-body" style="margin-top: 4px; font-size: 12px;">\u2764\uFE0F Donating to RoValra \u2764\uFE0F</div>' : ""}
            </div>
            <div style="padding: 8px 0; border-bottom: 1px solid rgb(73, 77, 90);">
                <div class="text font-body" style="font-weight: 600; margin-bottom: 6px; font-size: 13px;">PURCHASING ITEM</div>
                <div style="display: flex; flex-direction: column; gap: 4px;">
                    ${singleItemHtml}
                </div>
            </div>
            <details style="border-bottom: 1px solid rgb(73, 77, 90); padding: 8px 0;">
                <summary style="cursor: pointer; list-style: none; display: flex; align-items: center; justify-content: space-between;">
                    <span class="text font-body" style="font-weight: 600; font-size: 13px;">USING EXPERIENCE</span>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <button id="change-experience-btn" class="btn-secondary-sm text font-body" style="padding: 4px 10px; font-size: 12px;" onclick="event.stopPropagation();">
                            Change
                        </button>
                        <span style="font-size: 12px;">\u25BC</span>
                    </div>
                </summary>
                <div style="padding-top: 8px; display: flex; gap: 10px; align-items: center;">
                    ${gameThumbnailUrl ? `
                        <img src="${gameThumbnailUrl}" alt="${gameName}" style="width: 40px; height: 40px; border-radius: 4px; flex-shrink: 0;">
                    ` : `
                        <div style="width: 40px; height: 40px; background: #bdbebe; border-radius: 4px; flex-shrink: 0;"></div>
                    `}
                    <div style="flex: 1; min-width: 0;">
                        <div class="text font-body" style="font-weight: 600; font-size: 13px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${gameName}</div>
                        <div class="text font-body" style="font-size: 11px; opacity: 0.7;">Place ID: ${actualPlaceId}</div>
                        ${isDonating ? '<div class="text font-body" style="font-size: 11px; opacity: 0.7;">Donating to RoValra \u2764\uFE0F</div>' : ""}
                    </div>
                </div>
            </details>
            <div style="padding: 8px 0;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span class="text font-body" style="font-size: 13px;">Total:</span>
                    <span class="text font-body" style="font-weight: 600; display: flex; align-items: center; gap: 4px;"><span class="icon-robux-16x16"></span>${robuxPrice.toLocaleString()}</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span class="text font-body" style="font-size: 13px;">Balance:</span>
                    <span class="text font-body" style="display: flex; align-items: center; gap: 4px;"><span class="icon-robux-16x16"></span>${userRobux.toLocaleString()}</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid rgb(73, 77, 90);">
                    <span class="text font-body" style="font-size: 13px;">After:</span>
                    <span class="text font-body" style="font-weight: 600; ${robuxAfterPurchase < 0 ? "color: #d32f2f;" : ""} display: flex; align-items: center; gap: 4px;"><span class="icon-robux-16x16"></span>${robuxAfterPurchase.toLocaleString()}</span>
                </div>
                <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(0,128,0,0.05); border-radius: 4px;">
                    <span class="text font-body" style="font-weight: 600; font-size: 13px;">${isDonating ? "RoValra gets:" : "You Save:"}</span>
                    <span class="text font-body" style="font-size: 18px; font-weight: 700; display: flex; align-items: center; gap: 4px;"><span class="icon-robux-16x16"></span>${robuxSaved.toLocaleString()}</span>
                </div>
            </div>
            ${robuxAfterPurchase < 0 ? '<div style="padding: 8px; border-radius: 4px; background: rgba(211, 47, 47, 0.1); margin-bottom: 8px; border: 1px solid rgba(211, 47, 47, 0.3);"><span class="text font-body" style="color: #d32f2f; font-weight: 600; font-size: 13px;">\u26A0\uFE0F Insufficient Balance</span></div>' : ""}
        `);
    let finalConfirmBtn = document.createElement("button");
    finalConfirmBtn.textContent = "Join game to purchase", finalConfirmBtn.className = "btn-cta-md btn-min-width", finalConfirmBtn.disabled = robuxAfterPurchase < 0;
    let finalCancelBtn = document.createElement("button");
    finalCancelBtn.textContent = "Cancel", finalCancelBtn.className = "btn-secondary-md btn-min-width";
    let { overlay: finalConfirmOverlay, close: origCloseFinalConfirm } = createOverlay({
      title: "Confirm Purchase",
      bodyContent: finalConfirmBody,
      actions: [finalCancelBtn, finalConfirmBtn],
      maxWidth: "500px",
      showLogo: !0
    });
    finalConfirmOverlay.addEventListener("click", (e) => {
      e.target === finalConfirmOverlay && (e.stopPropagation(), e.stopImmediatePropagation());
    }, !0);
    let closeFinalConfirm = /* @__PURE__ */ __name(() => {
      ctx.cancelled || (ctx.cancelled = !0), origCloseFinalConfirm();
    }, "closeFinalConfirm"), changeExperienceBtn = finalConfirmBody.querySelector("#change-experience-btn");
    if (changeExperienceBtn && changeExperienceBtn.addEventListener("click", () => {
      closeFinalConfirm(), createAndShowPopup(() => {
        execute40MethodPurchase(itemId, robuxPrice, isGamePass, isBundle, itemDetails);
      });
    }), !await new Promise((resolve) => {
      let settled = !1, finish = /* @__PURE__ */ __name((val) => {
        settled || (settled = !0, resolve(val));
      }, "finish");
      finalConfirmBtn.addEventListener("click", () => {
        ctx.cancelled && (ctx.cancelled = !1), origCloseFinalConfirm(), finish(!0);
      }), finalCancelBtn.addEventListener("click", () => {
        ctx.cancelled = !0, origCloseFinalConfirm(), finish(!1);
      });
      let closeBtn = finalConfirmOverlay.querySelector(".foundation-web-dialog-close-container button");
      closeBtn && closeBtn.addEventListener("click", () => {
        ctx.cancelled = !0, origCloseFinalConfirm(), finish(!1);
      });
    }) || ctx.cancelled)
      return;
    ensureNotCancelled();
    let typePrefix = "asset";
    isGamePass ? typePrefix = "gamepass" : isBundle && (typePrefix = "bundle");
    let launchData = `${typePrefix}:${itemId}`;
    launchMultiplayerGame(useRoValraGroup || savedPlaceId === "ROVALRA_GROUP" ? actualPlaceId : savedPlaceId, launchData);
  }, "execute40MethodPurchase"), addSaveButton = /* @__PURE__ */ __name((modal) => {
    let modalWindow = modal.closest(".modal-window") || modal.closest(".simplemodal-wrap") || modal;
    if (!modalWindow) return;
    let checkElements = /* @__PURE__ */ __name(() => {
      let buyNowButton = modalWindow.querySelector(".modal-button.btn-primary-md, #confirm-btn.btn-primary-md, a#confirm-btn"), robuxPriceElement = modalWindow.querySelector(".text-robux, .text-robux-lg"), buttonContainer = modalWindow.querySelector(".modal-footer .modal-buttons, .modal-btns"), closeButton = modalWindow.querySelector(".modal-header .close, .modal-header .modal-close-btn, .modal-header button.close");
      return !buyNowButton || !robuxPriceElement || !buttonContainer || !closeButton ? null : { buyNowButton, robuxPriceElement, buttonContainer, closeButton };
    }, "checkElements"), elements = checkElements();
    if (elements)
      addButtonWithElements(elements);
    else {
      let observer = new MutationObserver(() => {
        elements = checkElements(), elements && (observer.disconnect(), addButtonWithElements(elements));
      });
      observer.observe(modalWindow, { childList: !0, subtree: !0 });
    }
    async function addButtonWithElements({ buyNowButton, robuxPriceElement, buttonContainer, closeButton }) {
      let currentUserId = getCurrentUserId(), prefetchData = {
        storage: null,
        balance: null,
        gameInfo: null,
        gameThumb: null,
        ownership: null,
        itemDetails: null,
        cartOwnership: null,
        cartThumbnails: null
      };
      currentUserId && (prefetchData.storage = new Promise((resolve) => chrome.storage.local.get(["RobuxPlaceId", "useRoValraGroup"], resolve)), prefetchData.balance = callRobloxApiJson({
        subdomain: "economy",
        endpoint: `/v1/users/${currentUserId}/currency`,
        method: "GET"
      }).catch(() => ({ robux: 0 })), prefetchData.gameInfo = prefetchData.storage.then(async (res) => {
        let savedPlaceId = res.RobuxPlaceId, useRoValraGroup = res.useRoValraGroup === !0;
        if (!savedPlaceId) return null;
        let actualPlaceId = savedPlaceId;
        (useRoValraGroup || savedPlaceId === "ROVALRA_GROUP") && (actualPlaceId = ROVALRA_PLACE_ID);
        try {
          return { data: await callRobloxApiJson({
            subdomain: "games",
            endpoint: `/v1/games/multiget-place-details?placeIds=${actualPlaceId}`,
            method: "GET"
          }), actualPlaceId, useRoValraGroup, savedPlaceId };
        } catch {
          return null;
        }
      }), prefetchData.gameThumb = prefetchData.gameInfo.then(async (info) => {
        if (!info || !info.data || !info.data.length) return null;
        let universeId = info.data[0].universeId;
        if (!universeId) return null;
        try {
          let d = (await fetchThumbnails([{ id: universeId }], "GameIcon", "150x150")).get(universeId);
          return d && d.state === "Completed" ? d.imageUrl : null;
        } catch {
          return null;
        }
      }));
      let cartItems = getCartItems(), isMultiItemPurchase = cartItems.length >= 2, isOnGamePage = /^\/([a-z]{2}(-[a-z]{2})?\/)?games\//i.test(window.location.pathname), itemId = null, isGamePassOnGamePage = !1, isMismatch = !1, capturedItemName = null;
      if (isMultiItemPurchase) {
        let batchItemsInModal = getBatchPurchaseItems(modalWindow);
        batchItemsInModal.length > 0 && (isMismatch = !validateCartMatch(batchItemsInModal, cartItems), isMismatch && console.warn("Cart mismatch detected!"));
      } else if (isOnGamePage) {
        let modalMessage = modalWindow.querySelector(".modal-message"), modalItemNameEl = modalMessage?.querySelector(".font-bold, strong"), modalItemPriceEl = modalMessage?.querySelector(".text-robux, .robux-text");
        if (modalItemNameEl && modalItemPriceEl) {
          let modalItemName = modalItemNameEl.textContent.trim(), modalItemPrice = parseInt(modalItemPriceEl.textContent.replace(/\D/g, ""), 10);
          capturedItemName = modalItemName;
          let universeId = getUniverseId();
          if (universeId) {
            let match = (await fetchGamePassesForUniverse(universeId)).find((gp) => (gp.name && gp.name.trim() === modalItemName || gp.displayName && gp.displayName.trim() === modalItemName) && gp.price === modalItemPrice);
            match && (itemId = match.id, isGamePassOnGamePage = !0);
          }
          if (!itemId) {
            let storeItems = document.querySelectorAll("#store-tab .list-item .store-card, .game-passes-list .list-item");
            for (let itemCard of storeItems) {
              let cardNameEl = itemCard.querySelector(".store-card-name, .item-card-name"), cardPriceEl = itemCard.querySelector(".store-card-price .text-robux, .item-card-price .text-robux"), cardLinkEl = itemCard.querySelector("a.store-card-link, a.item-card-link");
              if (cardNameEl && cardPriceEl && cardLinkEl) {
                let cardItemName = (cardNameEl.getAttribute("title") || cardNameEl.textContent).trim(), cardItemPrice = parseInt(cardPriceEl.textContent.replace(/\D/g, ""), 10);
                if (modalItemName === cardItemName && modalItemPrice === cardItemPrice) {
                  let match = cardLinkEl.getAttribute("href").match(/\/(?:[a-z]{2}(?:-[a-z]{2})?\/)?game-pass\/(\d+)/i);
                  if (match) {
                    itemId = match[1], isGamePassOnGamePage = !0;
                    break;
                  }
                }
              }
            }
          }
        }
      }
      let isGamePass = /^\/([a-z]{2}(-[a-z]{2})?\/)?game-pass\//i.test(window.location.pathname) || isGamePassOnGamePage, isBundle = /^\/([a-z]{2}(-[a-z]{2})?\/)?bundles\//i.test(window.location.pathname);
      if (itemId || (cartItems.length === 1 ? itemId = cartItems[0].id : isOnGamePage || (itemId = getPlaceIdFromUrl(window.location.href))), !itemId && !isMultiItemPurchase) return;
      if (currentUserId)
        if (!isMultiItemPurchase && itemId) {
          let itemType = isGamePass ? "GamePass" : isBundle ? "Bundle" : "Asset";
          prefetchData.ownership = checkItemOwnership(currentUserId, itemId, itemType), !isGamePass && !isBundle && (prefetchData.itemDetails = getItemDetails(itemId, "Asset"));
        } else isMultiItemPurchase && (prefetchData.cartOwnership = Promise.all(cartItems.map((item) => checkItemOwnership(currentUserId, item.id, "Asset"))), prefetchData.cartThumbnails = fetchThumbnails(cartItems.map((i) => ({ id: parseInt(i.id) })), "Asset", "150x150"));
      let robuxPrice = parseInt(robuxPriceElement.textContent.replace(/,/g, ""), 10);
      if (isNaN(robuxPrice)) return;
      await fetchCatalogMetadata();
      let assetType = null;
      if (!isGamePass && !isBundle && !isMultiItemPurchase && itemId)
        try {
          let details = await getItemDetails(itemId, "Asset");
          details && details.data && details.data[0] && (assetType = details.data[0].assetType);
        } catch (e) {
          console.warn("Mania Ext: Failed to fetch asset type for button text", e);
        }
      let savingsPercentage = isGamePass ? 0.1 : 0.4;
      if (assetType && !isGamePass && !isBundle && assetToSubcategoryMap && classicClothingSubcategories) {
        let subcategoryId = assetToSubcategoryMap[String(assetType)];
        classicClothingSubcategories.includes(subcategoryId) && (robuxPrice < 10 ? savingsPercentage = 0 : savingsPercentage = 0.1);
      }
      let savings = Math.floor(robuxPrice * savingsPercentage), saveButton = document.createElement("button");
      if (saveButton.textContent = `Save ${savings} Robux`, saveButton.type = "button", isGamePass ? saveButton.className = "btn-control-md btn-save-robux" : saveButton.className = "modal-button btn-control-md btn-min-width btn-save-robux", saveButton.addEventListener("click", async () => {
        if (closeButton.click(), isMismatch) {
          let errorBody = document.createElement("div");
          errorBody.innerHTML = purify.sanitize(`
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px; color: #d32f2f;">\u26A0\uFE0F</div>
                        <h3 class="text font-header-2" style="margin: 0 0 12px 0; color: #d32f2f;">Cart Mismatch Detected</h3>
                        <p class="text font-body" style="margin: 0 0 12px 0;">The items in your purchase modal don't match what's in your cart.</p>
                        <p class="text font-body" style="margin: 0;">Please refresh the page and try again. If this issue persists, please report it in the RoValra Discord server.</p>
                    </div>
                `);
          let { overlay, close } = createOverlay({
            title: "Purchase Error",
            bodyContent: errorBody,
            actions: [],
            maxWidth: "450px",
            showLogo: !0
          });
          return;
        }
        let itemDetails = null;
        if (isGamePassOnGamePage) {
          let modalImage = modalWindow.querySelector(".modal-image-container img, .modal-thumb");
          itemDetails = {
            name: capturedItemName || "Game Pass",
            thumbnail: modalImage ? modalImage.src : null
          };
        } else if (!isMultiItemPurchase && itemId)
          try {
            let nameElement = document.querySelector(".item-details-name-row h1, .item-name-container h1"), itemName = nameElement ? nameElement.textContent.trim() : "Unknown Item", itemThumbnail = null;
            try {
              let thumbnailType = "Asset";
              isGamePass ? thumbnailType = "GamePass" : isBundle && (thumbnailType = "BundleThumbnail");
              let thumbData = (await fetchThumbnails(
                [{ id: parseInt(itemId) }],
                thumbnailType,
                "150x150"
              )).get(parseInt(itemId));
              thumbData && thumbData.state === "Completed" && (itemThumbnail = thumbData.imageUrl);
            } catch (thumbError) {
              console.warn("Mania Ext: Could not fetch item thumbnail:", thumbError);
            }
            itemDetails = {
              name: itemName,
              thumbnail: itemThumbnail
            };
          } catch (error) {
            console.warn("Mania Ext: Could not extract item details from page:", error);
          }
        (await new Promise((resolve) => {
          chrome.storage.local.get("RobuxPlaceId", resolve);
        })).RobuxPlaceId ? isMultiItemPurchase ? executeCartPurchase(cartItems, prefetchData) : execute40MethodPurchase(itemId, robuxPrice, isGamePass, isBundle, itemDetails, prefetchData) : createAndShowPopup(() => {
          let freshPrefetch = prefetchData ? { ...prefetchData, storage: null, gameInfo: null, gameThumb: null } : null;
          isMultiItemPurchase ? executeCartPurchase(cartItems, freshPrefetch, !0) : execute40MethodPurchase(itemId, robuxPrice, isGamePass, isBundle, itemDetails, freshPrefetch, !0);
        });
      }), !modalWindow.querySelector(".rovalra-save-wrapper")) {
        let wrapper = document.createElement("div");
        wrapper.className = "rovalra-save-wrapper", wrapper.style.cssText = `
                margin-top: 8px;
                display: flex;
                justify-content: center;
                width: 100%;
            `, wrapper.appendChild(saveButton), (modalWindow.querySelector(".modal-footer") || buttonContainer.parentElement || modalWindow).appendChild(wrapper);
      }
    }
    __name(addButtonWithElements, "addButtonWithElements");
  }, "addSaveButton");
  function init21() {
    typeof chrome < "u" && chrome.storage && chrome.storage.local ? chrome.storage.local.get("SaveLotsRobuxEnabled", (result) => {
      result.SaveLotsRobuxEnabled === !0 && (fetchCatalogMetadata(), detectAndAddSaveButton());
    }) : console.error("Mania Ext: Chrome storage API not available.");
  }
  __name(init21, "init");

  // src/content/features/catalog/depenencies.js
  var THUMBNAIL_SIZE = "150x150";
  function findDependencies(roots) {
    let dependencies = [], idRegex = /(?:rbxassetid:\/\/|id=)(\d+)/i, ignoredProperties = ["ShirtTemplate", "PantsTemplate", "Graphic"], extractId = /* @__PURE__ */ __name((str) => {
      if (!str || typeof str != "string") return null;
      let match = str.match(idRegex);
      return match ? match[1] : null;
    }, "extractId");
    function traverse(instance) {
      if (instance) {
        if (instance.Properties)
          for (let [propName, propValue] of Object.entries(instance.Properties)) {
            if (ignoredProperties.includes(propName)) continue;
            let id = extractId(propValue);
            if (id && id !== "0") {
              let typeName = propName.replace("Id", "");
              typeName === "Texture" && (typeName = "Image"), typeName === "Mesh" && (typeName = "Mesh"), dependencies.push({ assetId: id, type: typeName, source: instance.ClassName });
            }
          }
        instance.Children && instance.Children.forEach((child) => traverse(child));
      }
    }
    return __name(traverse, "traverse"), roots.forEach((root) => traverse(root)), Array.from(new Map(dependencies.map((item) => [item.assetId, item])).values());
  }
  __name(findDependencies, "findDependencies");
  async function fetchAssetDetails(assetIds) {
    if (!assetIds || assetIds.length === 0) return /* @__PURE__ */ new Map();
    let promises = assetIds.map(async (id) => {
      try {
        let response = await callRobloxApi({
          subdomain: "economy",
          endpoint: `/v2/assets/${id}/details`,
          method: "GET"
        });
        return response.ok ? await response.json() : null;
      } catch {
        return null;
      }
    }), results = await Promise.all(promises), detailsMap = /* @__PURE__ */ new Map();
    return results.forEach((data) => {
      data && data.AssetId && detailsMap.set(data.AssetId.toString(), {
        name: data.Name,
        creatorName: data.Creator?.Name || "Unknown",
        creatorId: data.Creator?.CreatorTargetId || data.Creator?.Id,
        creatorType: data.Creator?.CreatorType || "User",
        isVerified: data.Creator?.HasVerifiedBadge || !1,
        productType: data.AssetTypeId
      });
    }), detailsMap;
  }
  __name(fetchAssetDetails, "fetchAssetDetails");
  async function mountDependencyScanner(favButton) {
    if (favButton.dataset.rovalraScanning === "true" || favButton.nextSibling?.id === "rovalra-dep-container" || document.getElementById("rovalra-dep-container")) return;
    let parent = favButton.parentNode;
    if (!parent) return;
    favButton.dataset.rovalraScanning = "true";
    let urlMatch = window.location.pathname.match(/\/(?:catalog|bundles|hidden-catalog)\/(\d+)/);
    if (!urlMatch) return;
    let mainAssetId = parseInt(urlMatch[1], 10);
    try {
      let assetData = (await checkAssetsInBatch([mainAssetId]))[0];
      if (!assetData?.isValid || !assetData?.root)
        return;
      let deps = findDependencies(assetData.root);
      if (deps.length === 0 || document.getElementById("rovalra-dep-container")) return;
      let uiContainer = document.createElement("div");
      uiContainer.id = "rovalra-dep-container", parent.insertBefore(uiContainer, favButton.nextSibling);
      let dropdown = createDropdown({ items: [], placeholder: "Scan Dependencies", onValueChange: /* @__PURE__ */ __name(() => {
      }, "onValueChange") });
      dropdown.trigger.style.width = "100%", dropdown.trigger.style.justifyContent = "space-between", dropdown.trigger.style.height = "32px", uiContainer.appendChild(dropdown.element), dropdown.trigger.querySelector("span").textContent = `Loading Info (${deps.length})...`;
      let thumbnailItems = deps.map((d) => ({ id: d.assetId })), rawIds = deps.map((d) => d.assetId), [thumbMap, detailsMap] = await Promise.all([
        fetchThumbnails(thumbnailItems, "Asset", THUMBNAIL_SIZE),
        fetchAssetDetails(rawIds)
      ]);
      dropdown.trigger.querySelector("span").textContent = "Dependencies";
      let panel = dropdown.panel, dynamicWidth = Math.min(Math.max(deps.length, 1), 6) * 138 + 24 + 30;
      panel.style.width = `${dynamicWidth}px`, panel.style.maxWidth = "90vw", panel.style.maxHeight = "600px", panel.style.overflowY = "auto", panel.innerHTML = "";
      let contentWrapper = document.createElement("div");
      contentWrapper.className = "rovalra-dep-panel-content";
      let grid = document.createElement("div");
      grid.className = "rovalra-dep-grid";
      let assets3 = getAssets();
      deps.forEach((dep) => {
        let details = detailsMap.get(dep.assetId) || { name: `Asset ${dep.assetId}`, creatorName: "Unknown", isVerified: !1 }, assetLinkUrl = `https://create.roblox.com/store/asset/${dep.assetId}`, thumbData = thumbMap.get(parseInt(dep.assetId)), creatorUrl = details.creatorType === "Group" ? `/groups/${details.creatorId}/about` : `/users/${details.creatorId}/profile`, container = document.createElement("div");
        container.className = "item-card-container";
        let mainLink = document.createElement("a");
        mainLink.className = "item-card-link", mainLink.href = assetLinkUrl, mainLink.onclick = (e) => {
          if (!e.target.closest(".creator-name"))
            return !0;
          e.preventDefault();
        };
        let linkInnerDiv = document.createElement("div");
        linkInnerDiv.className = "item-card-link";
        let thumbContainer = document.createElement("div");
        thumbContainer.className = "item-card-thumb-container";
        let thumb2d = document.createElement("span");
        thumb2d.className = "thumbnail-2d-container";
        let thumbEl = createThumbnailElement(
          thumbData,
          details.name,
          "",
          { position: "absolute", top: "0", left: "0", width: "100%", height: "100%", objectFit: "contain" }
        );
        thumb2d.appendChild(thumbEl), thumbContainer.appendChild(thumb2d), linkInnerDiv.appendChild(thumbContainer), mainLink.appendChild(linkInnerDiv);
        let caption = document.createElement("div");
        caption.className = "item-card-caption";
        let nameLink = document.createElement("div");
        nameLink.className = "item-card-name-link";
        let nameDiv = document.createElement("div");
        nameDiv.className = "item-card-name", nameDiv.title = details.name, nameDiv.textContent = details.name, nameLink.appendChild(nameDiv), caption.appendChild(nameLink);
        let secondary = document.createElement("div");
        secondary.className = "item-card-secondary-info text-secondary";
        let creatorDiv = document.createElement("div");
        creatorDiv.className = "text-overflow item-card-creator";
        let creatorText = document.createElement("span");
        creatorText.className = "item-card-creator-text";
        let badgeHtml = "";
        details.isVerified && (badgeHtml = `<img src="${assets3.verifiedBadge}" title="Verified Badge" alt="Verified Badge" class="verified-badge-container">`), creatorText.innerHTML = purify.sanitize(`By <a href="${creatorUrl}" class="creator-name text-link">${details.creatorName} ${badgeHtml}</a>`), creatorDiv.appendChild(creatorText), secondary.appendChild(creatorDiv);
        let typeDiv = document.createElement("div");
        typeDiv.className = "text-overflow item-card-type";
        let typeText = document.createElement("span");
        typeText.className = "item-card-type-text", typeText.textContent = dep.type, typeDiv.appendChild(typeText), secondary.appendChild(typeDiv), caption.appendChild(secondary), mainLink.appendChild(caption), container.appendChild(mainLink), grid.appendChild(container);
      }), contentWrapper.appendChild(grid), panel.appendChild(contentWrapper);
    } catch (error) {
      console.warn("[Rovalra Scanner] Silent failure:", error);
    }
  }
  __name(mountDependencyScanner, "mountDependencyScanner");
  function init22() {
    chrome.storage.local.get("EnableItemDependencies", (data) => {
      data.EnableItemDependencies === !0 && (startObserving(), observeElement("#favorites-button", (el2) => mountDependencyScanner(el2)));
    });
  }
  __name(init22, "init");

  // src/content/features/catalog/pricefloor.js
  function init23() {
    chrome.storage.local.get("priceFloorEnabled", (data) => {
      data.priceFloorEnabled !== !1 && observeElement(".item-price-value.icon-text-wrapper.clearfix.icon-robux-price-container", async (element) => {
        if (element.dataset.rovalraPriceFloor) return;
        element.dataset.rovalraPriceFloor = "true";
        let assetId = getPlaceIdFromUrl();
        if (assetId)
          try {
            let isBundlePage = window.location.pathname.includes("/bundles/"), details = await callRobloxApiJson({
              subdomain: "catalog",
              endpoint: `/v1/catalog/items/${assetId}/details?itemType=${isBundlePage ? "Bundle" : "Asset"}`
            });
            if (!details) return;
            let assetType = isBundlePage ? details.bundleType : details.assetType;
            if (details.taxonomy?.some((t) => t.taxonomyName === "Heads") && (assetType = 2), !assetType) return;
            let isPbr = details.isPBR || !1, isBodysuit = details.taxonomy?.some((t) => t.taxonomyName === "Bodysuit") || !1, collectibleItemType = details.itemRestrictions && details.itemRestrictions.includes("Collectible") ? 1 : 2, priceFloorData = await callRobloxApiJson({
              subdomain: "itemconfiguration",
              endpoint: `/v1/items/price-floor?collectibleItemType=${collectibleItemType}&creationType=1&isPbr=${isPbr}&isBodysuit=${isBodysuit}&${isBundlePage ? "bundleType" : "assetType"}=${assetType}`
            });
            if (priceFloorData && typeof priceFloorData.priceFloor == "number") {
              let assets3 = getAssets(), floor = priceFloorData.priceFloor, currentPrice = details.lowestPrice, icon = document.createElement("div");
              icon.className = "rovalra-price-floor-icon", Object.assign(icon.style, {
                width: "16px",
                height: "16px",
                marginLeft: "5px",
                verticalAlign: "text-bottom",
                cursor: "help",
                display: "inline-block",
                backgroundColor: "var(--rovalra-main-text-color)",
                webkitMask: `url("${assets3.priceFloorIcon}") no-repeat center / contain`,
                mask: `url("${assets3.priceFloorIcon}") no-repeat center / contain`
              });
              let tooltipContent = `Price Floor: <span class="icon-robux-16x16"></span>${floor.toLocaleString()}`;
              if (typeof currentPrice == "number" && !isNaN(currentPrice)) {
                let diff = currentPrice - floor, status = diff > 0 ? "above" : diff < 0 ? "below" : "at";
                tooltipContent += `<br>This item is ${status} the price floor${diff !== 0 ? ` by <span class="icon-robux-16x16"></span>${Math.abs(diff).toLocaleString()}` : ""}.`;
              }
              tooltipContent += '<br><br><span class="text-secondary" style="font-size: 12px;">The price floor is a dynamically updating minimum price an item can be sold for.</span>', addTooltip(icon, tooltipContent, { position: "top" }), element.appendChild(icon);
            }
          } catch {
          }
      });
    });
  }
  __name(init23, "init");

  // src/content/features/games/about/botDetector.js
  var MAX_SERVERS_TO_CHECK = 50, BOT_PERCENTAGE_THRESHOLD = 10, SIMILARITY_THRESHOLD = 5;
  function getPlaceIdFromUrl2(url) {
    let standardMatch = url.match(/\/games\/(\d+)/);
    if (standardMatch && standardMatch[1]) return standardMatch[1];
    let numericMatch = url.match(/\/games\/([0-9]+)/);
    if (numericMatch && numericMatch[1]) return numericMatch[1];
    let queryMatch = url.match(/[?&]placeId=(\d+)/i);
    if (queryMatch && queryMatch[1]) return queryMatch[1];
    let anyNumberMatch = url.match(/[^0-9](\d{8,})[^0-9]/);
    return anyNumberMatch && anyNumberMatch[1] ? anyNumberMatch[1] : null;
  }
  __name(getPlaceIdFromUrl2, "getPlaceIdFromUrl");
  var BotDetector = class {
    static {
      __name(this, "BotDetector");
    }
    constructor() {
      this.totalPlayersProcessed = 0, this.totalBotsFound = 0, this.requestIntercepted = !1, this.initialScanComplete = !1, window.location.href.includes("/games/") && getPlaceIdFromUrl2(window.location.href) && this.initialize(), this.updateBotStats();
    }
    async updateBotStats() {
      let descWrapper = document.getElementById("btr-description-wrapper"), gameDescContainer = document.querySelector(".game-description-container"), targetElement = descWrapper || gameDescContainer;
      if (!targetElement || !getPlaceIdFromUrl2(window.location.href)) return;
      let isLightTheme = document.body.classList.contains("light-theme"), tooltipTextColor = "var(--rovalra-secondary-text-color)", statsContainer = document.querySelector(".bot-stats-container");
      statsContainer || (statsContainer = document.createElement("div"), statsContainer.className = "bot-stats-container", statsContainer.style.cssText = `
                display: flex;
                font-size: 14px;
                align-items: center;
                width: 100%;
                box-sizing: border-box;
                clear: both;
            `, targetElement.insertBefore(statsContainer, targetElement.firstChild));
      let botPercentage = this.totalPlayersProcessed > 0 ? this.totalBotsFound / this.totalPlayersProcessed * 100 : 0, gameNameElement = document.querySelector(".game-name"), gameName = gameNameElement ? gameNameElement.textContent.trim().split(`
`)[0] : "This game", tooltipText = `Bots are accounts running automated scripts to farm items. A single user can sometimes run 50+ bots.

Keep in mind that this is not a fault of the game developers. This information can be inaccurate if an experience is mainly played by new Roblox accounts.`;
      if (botPercentage > 20) {
        statsContainer.innerHTML = purify.sanitize(`
                <div style="display: flex; align-items: center; gap: 4px; color: ${tooltipTextColor};">
                    <span style="font-weight: 500;"><span style="color: var(--rovalra-main-text-color)">${gameName}</span> has a lot of bots</span>
                    <i class="icon-moreinfo"></i>
                </div>
            `);
        let infoIcon = statsContainer.querySelector(".icon-moreinfo");
        addTooltip(infoIcon, tooltipText, { position: "top" });
      } else if (botPercentage > BOT_PERCENTAGE_THRESHOLD) {
        statsContainer.innerHTML = purify.sanitize(`
                <div style="display: flex; align-items: center; gap: 4px; color: ${tooltipTextColor};">
                    <span style="font-weight: 500;"><span style="color: var(--rovalra-main-text-color);">${gameName}</span> has some bots but mostly real players</span>
                    <i class="icon-moreinfo"></i>
                </div>
            `);
        let infoIcon = statsContainer.querySelector(".icon-moreinfo");
        addTooltip(infoIcon, tooltipText, { position: "top" });
      } else
        statsContainer.innerHTML = "";
    }
    async initialize() {
      let placeId = getPlaceIdFromUrl2(window.location.href);
      placeId && await this.fetchServerData(placeId);
    }
    async fetchServerData(placeId) {
      if (!this.initialScanComplete)
        try {
          if (this.requestIntercepted) return;
          let response = await callRobloxApi({
            subdomain: "games",
            endpoint: `/v1/games/${placeId}/servers/Public?limit=50`,
            method: "GET"
          });
          if (!response.ok) return;
          let data = await response.json();
          if (data && data.data && Array.isArray(data.data)) {
            this.requestIntercepted = !0;
            let servers = data.data.slice(0, MAX_SERVERS_TO_CHECK);
            this.scanServers(placeId, servers);
          }
        } catch {
        }
    }
    refreshServerData() {
      let placeId = getPlaceIdFromUrl2(window.location.href);
      return placeId ? (this.requestIntercepted = !1, this.fetchServerData(placeId), !0) : !1;
    }
    async calculateImageHash(imageUrl) {
      try {
        let img = new Image();
        return img.crossOrigin = "Anonymous", new Promise((resolve) => {
          img.onload = () => {
            try {
              let canvas = document.createElement("canvas");
              canvas.width = 8, canvas.height = 8;
              let ctx = canvas.getContext("2d");
              ctx.drawImage(img, 0, 0, 8, 8);
              let data = ctx.getImageData(0, 0, 8, 8).data, hash = "", avg = 0;
              for (let i = 0; i < data.length; i += 4)
                avg += (data[i] + data[i + 1] + data[i + 2]) / 3;
              avg = avg / (data.length / 4);
              for (let i = 0; i < data.length; i += 4) {
                let pixel = (data[i] + data[i + 1] + data[i + 2]) / 3;
                hash += pixel > avg ? "1" : "0";
              }
              resolve(hash);
            } catch {
              resolve(null);
            }
          }, img.onerror = () => resolve(null), img.src = imageUrl;
        });
      } catch {
        return null;
      }
    }
    calculateHashDistance(hash1, hash2) {
      let distance = 0;
      for (let i = 0; i < hash1.length; i++)
        hash1[i] !== hash2[i] && distance++;
      return distance;
    }
    async getThumbnails(playerTokens) {
      try {
        if (playerTokens.length === 0) return [];
        let results = [], batchSize = 50;
        for (let i = 0; i < playerTokens.length; i += batchSize) {
          let requestData = playerTokens.slice(i, i + batchSize).map((token) => ({
            requestId: token.slice(0, 10),
            token,
            type: "AvatarHeadshot",
            size: "150x150",
            format: "Png",
            isCircular: !1
          }));
          try {
            let response = await callRobloxApi({
              subdomain: "thumbnails",
              endpoint: "/v1/batch",
              method: "POST",
              body: requestData
            });
            if (response.ok) {
              let data = await response.json();
              data && data.data && results.push(...data.data);
            } else response.status === 429 && await new Promise((resolve) => setTimeout(resolve, 1e3));
          } catch {
          }
        }
        return results.filter((item) => item.state === "Completed").map((item) => item.imageUrl);
      } catch {
        return [];
      }
    }
    async scanServers(placeId, servers) {
      try {
        if (!servers || !Array.isArray(servers) || servers.length === 0) return;
        let allPlayerTokens = [], MAX_THUMBNAILS_PER_SERVER = 5;
        servers.forEach((server) => {
          let serverTokens = (server.playerTokens || []).slice(0, MAX_THUMBNAILS_PER_SERVER);
          allPlayerTokens.push(...serverTokens);
        });
        let allImageUrls = await this.getThumbnails(allPlayerTokens);
        if (!allImageUrls.length) return;
        if (allImageUrls.length < 200) {
          this.requestIntercepted = !1;
          return;
        }
        let validHashes = (await Promise.all(
          allImageUrls.map((url) => this.calculateImageHash(url))
        )).filter((hash) => hash !== null), similarGroups = /* @__PURE__ */ new Map(), COMPARISON_GROUP_SIZE = 10;
        for (let groupStart = 0; groupStart < validHashes.length; groupStart += COMPARISON_GROUP_SIZE) {
          let groupEnd = Math.min(groupStart + COMPARISON_GROUP_SIZE, validHashes.length), currentGroup = validHashes.slice(groupStart, groupEnd);
          for (let i = 0; i < currentGroup.length; i++)
            for (let j2 = i + 1; j2 < currentGroup.length; j2++)
              this.calculateHashDistance(currentGroup[i], currentGroup[j2]) <= SIMILARITY_THRESHOLD && (similarGroups.has(currentGroup[i]) || similarGroups.set(currentGroup[i], /* @__PURE__ */ new Set([currentGroup[i]])), similarGroups.get(currentGroup[i]).add(currentGroup[j2]));
        }
        let totalBots = Array.from(similarGroups.values()).filter((group) => group.size >= 2).reduce((total, group) => total + group.size, 0);
        this.totalPlayersProcessed = validHashes.length, this.totalBotsFound = totalBots, this.updateBotStats(), this.initialScanComplete = !0, setTimeout(() => {
          this.requestIntercepted = !1;
        }, 1e4);
      } catch {
        this.requestIntercepted = !1;
      }
    }
  };
  window.BotDetector = BotDetector;
  function init24() {
    chrome.storage.local.get({ botdataEnabled: !1 }, function(settings) {
      settings.botdataEnabled && window.location.href.includes("/games/") && getPlaceIdFromUrl2(window.location.href) && (window.botDetector = new BotDetector(), observeElement && typeof observeElement == "function" && observeElement(
        "#btr-description-wrapper, .game-description-container",
        () => {
          window.botDetector && window.botDetector.updateBotStats();
        }
      ));
    });
  }
  __name(init24, "init");

  // src/content/core/review/review.js
  var REVIEW_URL = "https://chromewebstore.google.com/detail/rovalra-roblox-improved/njcickgebhnpgmoodjdgohkclfplejli/reviews", STATUS_KEY = "rovalra_review_popup_status", STATS_KEY = "rovalra_review_stats", SOURCE_WEIGHTS = {
    region_filters: 10,
    quickplay: 5,
    outfits: 5,
    totalspent: 5,
    antibots: 5,
    default: 2
  }, MIN_DAYS_INSTALLED = 0, COOLDOWN_DAYS = 7, SCORE_THRESHOLD = 150;
  function createButton2(text2, className, onClick2) {
    let btn = document.createElement("button");
    return btn.textContent = text2, btn.className = className, onClick2 && btn.addEventListener("click", onClick2), btn;
  }
  __name(createButton2, "createButton");
  function showReviewPopup(source = "unknown") {
    observeElement("body", () => {
      chrome.storage.local.get([STATUS_KEY, STATS_KEY, "forceReviewPopup"], (result) => {
        let forceShow = result.forceReviewPopup === !0;
        if (!forceShow && result[STATUS_KEY] === "dont_show") return;
        let now = Date.now(), stats = result[STATS_KEY] || {
          firstSeen: now,
          lastDismissed: 0,
          interactionScore: 0,
          sources: [],
          dismissCount: 0
        };
        stats.firstSeen || (stats.firstSeen = now), stats.lastDismissed || (stats.lastDismissed = 0), stats.interactionScore || (stats.interactionScore = 0), stats.sources || (stats.sources = []), typeof stats.dismissCount != "number" && (stats.dismissCount = 0);
        let weight = SOURCE_WEIGHTS[source] || SOURCE_WEIGHTS.default;
        if (stats.interactionScore += weight, stats.sources.includes(source) || stats.sources.push(source), chrome.storage.local.set({ [STATS_KEY]: stats }), !forceShow) {
          if ((now - stats.firstSeen) / (1e3 * 60 * 60 * 24) < MIN_DAYS_INSTALLED || stats.interactionScore < SCORE_THRESHOLD) return;
          let currentCooldown = COOLDOWN_DAYS + stats.dismissCount;
          if (stats.lastDismissed > 0 && (now - stats.lastDismissed) / (1e3 * 60 * 60 * 24) < currentCooldown) return;
        }
        setTimeout(() => {
          if (document.querySelector(".rovalra-global-overlay")) {
            let obsRequest;
            obsRequest = observeElement(".rovalra-global-overlay", () => {
            }, { onRemove: /* @__PURE__ */ __name(() => {
              obsRequest && (obsRequest.active = !1), setTimeout(() => showReviewPopup(source), 100);
            }, "onOverlayRemoved") });
            return;
          }
          if (document.querySelector(".rovalra-review-popup-marker")) return;
          let bodyContent = document.createElement("div");
          bodyContent.className = "rovalra-review-popup-marker", bodyContent.style.display = "flex", bodyContent.style.flexDirection = "column", bodyContent.style.gap = "10px";
          let text2 = document.createElement("p");
          text2.textContent = `It looks like you've been getting value from RoValra!
 Would you mind leaving a review?
 It helps keep RoValra free for everyone without paywalls.`, text2.style.fontSize = "16px", text2.style.lineHeight = "1.5", text2.style.whiteSpace = "pre-line", bodyContent.appendChild(text2);
          let actionTaken = !1, reviewBtn = createButton2("Leave a Review", "btn-primary-md", () => {
            actionTaken = !0, window.open(REVIEW_URL, "_blank"), chrome.storage.local.set({ [STATUS_KEY]: "dont_show" }), close();
          }), notNowBtn = createButton2("Not right now", "btn-control-md", () => {
            actionTaken = !0, stats.lastDismissed = Date.now(), stats.dismissCount = (stats.dismissCount || 0) + 1, chrome.storage.local.set({ [STATS_KEY]: stats }), close();
          }), actions = [];
          if (stats.dismissCount > 0) {
            let dontShowBtn = createButton2("Do not show again", "btn-control-md", () => {
              actionTaken = !0, chrome.storage.local.set({ [STATUS_KEY]: "dont_show" }), close();
            });
            actions.push(dontShowBtn);
          }
          actions.push(notNowBtn, reviewBtn);
          let { close } = createOverlay({
            title: "Rate RoValra",
            bodyContent,
            actions,
            showLogo: !0,
            preventBackdropClose: !0,
            onClose: /* @__PURE__ */ __name(() => {
              actionTaken || (stats.lastDismissed = Date.now(), stats.dismissCount = (stats.dismissCount || 0) + 1, chrome.storage.local.set({ [STATS_KEY]: stats }));
            }, "onClose")
          });
        }, 2e3);
      });
    });
  }
  __name(showReviewPopup, "showReviewPopup");

  // src/content/core/regionFinder/ClosestServer.js
  var REGIONS3 = {}, serverIpMap3 = {}, FINDER_CONFIG = {
    logScores: !0,
    maxServersPerRegion: 10,
    checkGameActivity: !0,
    maxManualScanPages: 3
  }, dataPromise = new Promise((resolve, reject) => {
    chrome.storage.local.get(["rovalraDatacenters"], (result) => {
      if (REGIONS3 = {}, serverIpMap3 = {}, result.rovalraDatacenters && Array.isArray(result.rovalraDatacenters)) {
        for (let entry of result.rovalraDatacenters)
          if (entry.location && entry.location_id) {
            let loc = entry.location, countryCode = loc.country, state3 = loc.region, city = loc.city, regionCode = countryCode;
            if (countryCode === "US" && state3 && city) {
              let stateCode = getStateCodeFromRegion(state3), cityCode = city.replace(/\s+/g, "").toUpperCase();
              regionCode = `US-${stateCode}-${cityCode}`;
            } else countryCode === "US" && state3 ? regionCode = `US-${getStateCodeFromRegion(state3)}` : city && (regionCode = `${countryCode}-${city.replace(/\s+/g, "").toUpperCase()}`);
            if (REGIONS3[regionCode] = {
              id: regionCode,
              city: loc.city,
              country: loc.country,
              region: loc.region,
              latitude: parseFloat(loc.latLong[0]),
              longitude: parseFloat(loc.latLong[1]),
              loadbalancing: entry.loadbalancing,
              inactive: entry.inactive
            }, entry.dataCenterIds)
              for (let id of entry.dataCenterIds)
                serverIpMap3[id] = regionCode;
          }
      }
      resolve();
    });
  });
  function getRegionName(regionId) {
    if (regionId === "AUTO") return "Automatic";
    let region = REGIONS3[regionId];
    if (region) {
      let parts = [];
      region.city && parts.push(region.city), region.region && parts.push(region.region);
      let country = region.country;
      return country === "US" && (country = "USA"), country && parts.push(country), parts.join(", ");
    }
    return String(regionId);
  }
  __name(getRegionName, "getRegionName");
  function getDistance(lat1, lon1, lat2, lon2) {
    let dLat = deg2rad(lat2 - lat1), dLon = deg2rad(lon2 - lon1), a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    return 6371 * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
  }
  __name(getDistance, "getDistance");
  function deg2rad(deg) {
    return deg * (Math.PI / 180);
  }
  __name(deg2rad, "deg2rad");
  function getRegionDistance(code1, code2) {
    let r1 = REGIONS3[code1], r2 = REGIONS3[code2];
    return !r1 || !r2 ? 1 / 0 : getDistance(r1.latitude, r1.longitude, r2.latitude, r2.longitude);
  }
  __name(getRegionDistance, "getRegionDistance");
  async function findClosestServerViaApi(placeId, originRegionId, userRequestedStop2) {
    if (!REGIONS3[originRegionId]) return null;
    let regionsWithDistance = Object.values(REGIONS3).filter((r) => r.id !== originRegionId).map((region) => ({
      region,
      distance: getDistance(REGIONS3[originRegionId].latitude, REGIONS3[originRegionId].longitude, region.latitude, region.longitude)
    }));
    regionsWithDistance.sort((a, b2) => a.distance - b2.distance);
    let regionsToCheck = regionsWithDistance.slice(0, 10);
    for (let { region } of regionsToCheck) {
      if (userRequestedStop2) return null;
      let url = `/v1/servers/region?place_id=${placeId}`;
      region.country && (url += `&country=${encodeURIComponent(region.country)}`), region.city && (url += `&city=${encodeURIComponent(region.city)}`), url += "&cursor=0";
      try {
        let response = await callRobloxApi({ isRovalraApi: !0, endpoint: url });
        if (response.ok) {
          let data = await response.json();
          if (data.servers && data.servers.length > 0)
            for (let server of data.servers) {
              if (userRequestedStop2) return null;
              try {
                let joinRes = await callRobloxApi({
                  subdomain: "gamejoin",
                  endpoint: "/v1/join-game-instance",
                  method: "POST",
                  body: { placeId: parseInt(placeId, 10), gameId: server.server_id, gameJoinAttemptId: crypto.randomUUID() }
                });
                if (joinRes.ok && (await joinRes.json()).joinScript)
                  return {
                    server: {
                      id: server.server_id,
                      playing: server.playing,
                      maxPlayers: server.max_players || server.maxPlayers
                    },
                    regionCode: region.id
                  };
              } catch {
              }
            }
        }
      } catch (e) {
        console.warn("Fallback API search failed for region", region.id, e);
      }
    }
    return null;
  }
  __name(findClosestServerViaApi, "findClosestServerViaApi");
  async function fetchServerRegion(server, placeId) {
    try {
      let res = await callRobloxApi({
        subdomain: "gamejoin",
        endpoint: "/v1/join-game-instance",
        method: "POST",
        body: { placeId: parseInt(placeId, 10), gameId: server.id, gameJoinAttemptId: crypto.randomUUID() }
      });
      if (!res.ok) return null;
      let info = await res.json();
      if (!info.joinScript) return null;
      let dataCenterId = info.joinScript.DataCenterId;
      if (dataCenterId && serverIpMap3[dataCenterId])
        return serverIpMap3[dataCenterId];
    } catch {
    }
    return null;
  }
  __name(fetchServerRegion, "fetchServerRegion");
  async function findServerViaRovalraApi(placeId, universeId, preferredRegionId, failedRegionNames, joinedServerIds2, userRequestedStopCheck) {
    try {
      if (FINDER_CONFIG.checkGameActivity && universeId && !await checkGameActivity(universeId))
        return { joined: !1 };
      let rankedRegions = await getRankedRegions(placeId, preferredRegionId);
      if (rankedRegions.length === 0) return { joined: !1 };
      let apiCandidate = null, apiSucceededAtLeastOnce = !1;
      for (let { region } of rankedRegions) {
        if (userRequestedStopCheck && userRequestedStopCheck()) return { status: "STOPPED" };
        let servers = await fetchServersForRegion(placeId, region);
        if (servers && servers.length > 0) {
          apiSucceededAtLeastOnce = !0, apiCandidate = {
            servers,
            region,
            distance: getRegionDistance(region.id, rankedRegions[0].region.id)
          };
          break;
        } else
          failedRegionNames.add(getRegionName(region.id));
      }
      let manualCandidate = null, bestPossibleRegion = rankedRegions[0].region;
      if (!apiCandidate || apiCandidate.region.id !== bestPossibleRegion.id) {
        let beatDistance = apiCandidate ? getRegionDistance(apiCandidate.region.id, bestPossibleRegion.id) : 1 / 0;
        manualCandidate = await findBestManualServer(
          placeId,
          rankedRegions,
          beatDistance,
          joinedServerIds2,
          userRequestedStopCheck
        );
      }
      let finalCandidate = apiCandidate;
      if (manualCandidate && (!apiCandidate || manualCandidate.distance < apiCandidate.distance) && (finalCandidate = manualCandidate), finalCandidate) {
        let serversToJoin = finalCandidate.servers || [finalCandidate.server];
        if (await attemptJoinServers(placeId, serversToJoin, joinedServerIds2, userRequestedStopCheck))
          return { status: "JOINED" };
      }
      return apiSucceededAtLeastOnce ? { status: "NO_SERVERS" } : { status: "API_ERROR" };
    } catch (error) {
      return console.error("Rovalra Search Error", error), { status: "API_ERROR" };
    }
  }
  __name(findServerViaRovalraApi, "findServerViaRovalraApi");
  async function checkGameActivity(universeId) {
    try {
      let response = await callRobloxApi({ subdomain: "games", endpoint: `/v1/games?universeIds=${universeId}` });
      if (response.ok) {
        let data = await response.json();
        if (!data.data || data.data.length === 0 || data.data[0].playing === 0)
          return !1;
      }
    } catch {
    }
    return !0;
  }
  __name(checkGameActivity, "checkGameActivity");
  async function getRankedRegions(placeId, preferredRegionId) {
    let ranked = [];
    if (preferredRegionId)
      REGIONS3[preferredRegionId] && (ranked = [{ region: REGIONS3[preferredRegionId], score: 0, distance: 0 }]);
    else {
      let locationData = await getUserLocation(placeId);
      if (!locationData) return [];
      let { userLat, userLon } = locationData;
      ranked = Object.values(REGIONS3).map((region) => {
        let distance = getDistance(userLat, userLon, region.latitude, region.longitude), score = Math.floor(distance / 10) + 1;
        return { region, score, distance };
      }), ranked.sort((a, b2) => a.score - b2.score);
    }
    return FINDER_CONFIG.logScores && (console.log(`[RoValra] Region Scores for Place ${placeId}:`), ranked.forEach((r) => {
      console.log(` - ${getRegionName(r.region.id)}: Score ${r.score} (${Math.round(r.distance)} km)`);
    })), ranked;
  }
  __name(getRankedRegions, "getRankedRegions");
  async function fetchServersForRegion(placeId, region) {
    let url = `/v1/servers/region?place_id=${placeId}`;
    region.country && (url += `&country=${encodeURIComponent(region.country)}`), region.city && (url += `&city=${encodeURIComponent(region.city)}`), url += "&cursor=0";
    try {
      let response = await callRobloxApi({ isRovalraApi: !0, endpoint: url });
      return response.ok ? (await response.json()).servers || [] : null;
    } catch {
      return null;
    }
  }
  __name(fetchServersForRegion, "fetchServersForRegion");
  async function findBestManualServer(placeId, rankedRegions, beatDistance, joinedServerIds2, stopCheck) {
    let cursor = null, regionDistanceMap = {};
    rankedRegions.forEach((r) => {
      regionDistanceMap[r.region.id] = r.distance;
    });
    for (let i = 0; i < FINDER_CONFIG.maxManualScanPages; i++) {
      if (stopCheck && stopCheck()) return null;
      let url = `/v1/games/${placeId}/servers/Public?excludeFullGames=true&limit=100${cursor ? `&cursor=${encodeURIComponent(cursor)}` : ""}`;
      try {
        let response = await callRobloxApi({ subdomain: "games", endpoint: url });
        if (!response.ok) break;
        let data = await response.json(), servers = data.data || [];
        if (servers.length === 0) break;
        let chunkSize = 5;
        for (let j2 = 0; j2 < servers.length; j2 += chunkSize) {
          if (stopCheck && stopCheck()) return null;
          let chunk = servers.slice(j2, j2 + chunkSize);
          await Promise.all(chunk.map(async (server) => {
            if (joinedServerIds2.has(server.id)) return;
            let regionId = await fetchServerRegion(server, placeId);
            regionId && regionDistanceMap[regionId] !== void 0 && (server._tempDistance = regionDistanceMap[regionId], server._tempRegionId = regionId);
          }));
        }
        let bestInPage = servers.filter((s) => s._tempDistance !== void 0).sort((a, b2) => a._tempDistance - b2._tempDistance)[0];
        if (bestInPage && bestInPage._tempDistance < beatDistance)
          return { server: bestInPage, region: REGIONS3[bestInPage._tempRegionId], distance: bestInPage._tempDistance, source: "MANUAL" };
        if (cursor = data.nextPageCursor, !cursor) break;
      } catch {
        break;
      }
    }
    return null;
  }
  __name(findBestManualServer, "findBestManualServer");
  async function attemptJoinServers(placeId, servers, joinedServerIds2, stopCheck) {
    let attempts = 0;
    for (let server of servers) {
      if (attempts >= FINDER_CONFIG.maxServersPerRegion) break;
      let serverId = server.server_id || server.id;
      if (!joinedServerIds2.has(serverId)) {
        if (stopCheck && stopCheck()) return !1;
        attempts++;
        try {
          let res = await callRobloxApi({
            subdomain: "gamejoin",
            endpoint: "/v1/join-game-instance",
            method: "POST",
            body: { placeId: parseInt(placeId, 10), gameId: serverId, gameJoinAttemptId: crypto.randomUUID() }
          });
          if (res.ok && (await res.json()).joinScript)
            return joinedServerIds2.add(serverId), hideLoadingOverlay(!0), launchGame(placeId, serverId), showReviewPopup("region_filters"), !0;
        } catch {
        }
      }
    }
    return !1;
  }
  __name(attemptJoinServers, "attemptJoinServers");

  // src/content/core/preferredregion.js
  var PREFERRED_REGION_STORAGE_KEY = "robloxPreferredRegion", MAX_SERVER_PAGES = 1 / 0, userRequestedStop = !1, isCurrentlyFetchingData = !1, serverLocations = {}, joinedServerIds = /* @__PURE__ */ new Set();
  async function fetchServerDetailsWrapper(server, placeId) {
    if (serverLocations[server.id] || userRequestedStop) return;
    let regionCode = await fetchServerRegion(server, placeId);
    userRequestedStop || regionCode && (serverLocations[server.id] = { c: regionCode });
  }
  __name(fetchServerDetailsWrapper, "fetchServerDetailsWrapper");
  async function performJoinAction(placeId, universeId, preferredRegionCode = null, onCancel = null) {
    if (!isCurrentlyFetchingData) {
      userRequestedStop = !1, isCurrentlyFetchingData = !0, serverLocations = {}, showLoadingOverlay(() => {
        userRequestedStop = !0, hideLoadingOverlay(!0), onCancel && onCancel();
      }, null, !0);
      try {
        let joined = !1, failedRegionNames = /* @__PURE__ */ new Set(), sortedRegionCodes = [], bestServerFoundSoFar = null, bestServerRegionCode = null, bestServerTier = 1 / 0, bestRecycledServer = null, bestRecycledRegionCode = null, bestRecycledTier = 1 / 0, totalUniqueServersSeen = 0;
        await dataPromise, updateLoadingOverlayText("Detecting your location...");
        let locationData = await getUserLocation(placeId), allRegionsByDistance = [], REGIONS6 = REGIONS3;
        if (locationData) {
          let { userLat, userLon } = locationData, regionsWithDistance = Object.keys(REGIONS6).map((regionCode) => {
            let region = REGIONS6[regionCode], distance = getDistance(userLat, userLon, region.latitude, region.longitude);
            return { regionCode, distance };
          });
          regionsWithDistance.sort((a, b2) => a.distance - b2.distance), allRegionsByDistance = regionsWithDistance.map((r) => r.regionCode);
        } else
          allRegionsByDistance = Object.keys(REGIONS6);
        if (preferredRegionCode) {
          let filtered = allRegionsByDistance.filter((r) => r !== preferredRegionCode);
          sortedRegionCodes = [preferredRegionCode, ...filtered];
        } else
          sortedRegionCodes = allRegionsByDistance;
        let shortTargetName = (preferredRegionCode ? getRegionName(preferredRegionCode) : "closest region").split(",")[0];
        if (preferredRegionCode && REGIONS6[preferredRegionCode]?.inactive) {
          showLoadingOverlayResult(purify.sanitize(`${shortTargetName} is no longer used as a server location by Roblox.`), { text: "Close", onClick: /* @__PURE__ */ __name(() => hideLoadingOverlay(!0), "onClick") }), isCurrentlyFetchingData = !1;
          return;
        }
        let runManualScan = !0, manualScanReason = `Region API unavailable. Scanning for ${shortTargetName}...`;
        if (!userRequestedStop) {
          updateLoadingOverlayText(purify.sanitize(`Searching in ${shortTargetName}...`));
          let rovalraResult = await findServerViaRovalraApi(
            placeId,
            universeId,
            preferredRegionCode,
            failedRegionNames,
            joinedServerIds,
            () => userRequestedStop
          );
          rovalraResult.status === "JOINED" ? (joined = !0, runManualScan = !1) : rovalraResult.status === "NO_SERVERS" && (runManualScan = !0, manualScanReason = `No servers found in ${shortTargetName} via API. Scanning locally...`);
        }
        if (runManualScan && !joined && !userRequestedStop) {
          let effectiveMaxPages = MAX_SERVER_PAGES;
          preferredRegionCode && REGIONS6[preferredRegionCode]?.loadbalancing && (effectiveMaxPages = 1, manualScanReason = `${shortTargetName} is used for load balancing and is likely only active under heavy load. Scanning...`), updateLoadingOverlayText(purify.sanitize(manualScanReason));
          let nextCursor = null, pageCount = 0;
          for (; pageCount < effectiveMaxPages && !userRequestedStop && !joined; ) {
            pageCount++;
            try {
              let response = await callRobloxApi({
                subdomain: "games",
                endpoint: `/v1/games/${placeId}/servers/Public?excludeFullGames=true&limit=100${nextCursor ? `&cursor=${encodeURIComponent(nextCursor)}` : ""}`
              });
              if (!response.ok) {
                await new Promise((r) => setTimeout(r, 1e3));
                continue;
              }
              let pageData = await response.json(), serversOnPage = pageData.data || [];
              if (serversOnPage.length === 0 && !pageData.nextPageCursor) break;
              if (serversOnPage.length > 0) {
                await Promise.all(serversOnPage.map((s) => fetchServerDetailsWrapper(s, placeId)));
                let improvedThisRound = !1;
                for (let server of serversOnPage) {
                  let regionCode = serverLocations[server.id]?.c;
                  if (regionCode && server.playing < server.maxPlayers) {
                    totalUniqueServersSeen++;
                    let thisServerTier = sortedRegionCodes.indexOf(regionCode);
                    thisServerTier === -1 && (thisServerTier = 9999), joinedServerIds.has(server.id) ? thisServerTier < bestRecycledTier && (bestRecycledServer = server, bestRecycledRegionCode = regionCode, bestRecycledTier = thisServerTier) : thisServerTier < bestServerTier && (bestServerFoundSoFar = server, bestServerRegionCode = regionCode, bestServerTier = thisServerTier, improvedThisRound = !0);
                  }
                }
                if (improvedThisRound) {
                  let bestName = bestServerRegionCode;
                  try {
                    bestName = getRegionName(bestServerRegionCode);
                  } catch {
                  }
                  bestServerTier === 0 ? updateLoadingOverlayText(purify.sanitize(`Found ${bestName}! Joining...`)) : updateLoadingOverlayText(purify.sanitize(`Found: ${bestName}. Continuing search for ${shortTargetName}...`));
                }
                if (bestServerTier === 0) {
                  hideLoadingOverlay(!0), joinedServerIds.add(bestServerFoundSoFar.id), launchGame(placeId, bestServerFoundSoFar.id), showReviewPopup("region_filters"), joined = !0;
                  break;
                }
                if (!preferredRegionCode && bestServerTier <= 2 && pageCount > 5) {
                  hideLoadingOverlay(!0), joinedServerIds.add(bestServerFoundSoFar.id), launchGame(placeId, bestServerFoundSoFar.id), showReviewPopup("region_filters"), joined = !0;
                  break;
                }
              }
              if (!pageData.nextPageCursor) break;
              nextCursor = pageData.nextPageCursor;
            } catch (e) {
              console.error("Error scanning page:", e);
            }
          }
        }
        if (!userRequestedStop && !joined) {
          if (!bestServerFoundSoFar && bestRecycledServer && (totalUniqueServersSeen < 40 || !bestServerFoundSoFar) && (bestServerFoundSoFar = bestRecycledServer, bestServerRegionCode = bestRecycledRegionCode), preferredRegionCode && !userRequestedStop) {
            updateLoadingOverlayText(purify.sanitize(`Searching for closest region to ${shortTargetName}...`));
            let apiFallback = await findClosestServerViaApi(placeId, preferredRegionCode, userRequestedStop);
            if (apiFallback) {
              let useApi = !1;
              if (!bestServerFoundSoFar)
                useApi = !0;
              else {
                let localDist = getRegionDistance(preferredRegionCode, bestServerRegionCode);
                getRegionDistance(preferredRegionCode, apiFallback.regionCode) < localDist && (useApi = !0);
              }
              useApi && (bestServerFoundSoFar = apiFallback.server, bestServerRegionCode = apiFallback.regionCode);
            }
          }
          if (totalUniqueServersSeen === 0 && !bestServerFoundSoFar)
            runManualScan ? (hideLoadingOverlay(!0), launchGame(placeId), showReviewPopup("region_filters")) : showLoadingOverlayResult(purify.sanitize(`No servers found in ${shortTargetName}.`), { text: "Close", onClick: /* @__PURE__ */ __name(() => hideLoadingOverlay(!0), "onClick") });
          else if (bestServerFoundSoFar)
            if (!preferredRegionCode)
              hideLoadingOverlay(!0), joinedServerIds.add(bestServerFoundSoFar.id), launchGame(placeId, bestServerFoundSoFar.id), showReviewPopup("region_filters");
            else {
              let foundRegionName = bestServerRegionCode;
              try {
                foundRegionName = getRegionName(bestServerRegionCode);
              } catch {
              }
              let message = `No ${shortTargetName} servers running.`;
              REGIONS6[preferredRegionCode]?.loadbalancing && (message = `${shortTargetName} is used for load balancing and is likely only active under heavy load.`), showLoadingOverlayResult(
                purify.sanitize(message),
                {
                  text: purify.sanitize(`Join ${foundRegionName}`),
                  onClick: /* @__PURE__ */ __name(() => {
                    hideLoadingOverlay(!0), joinedServerIds.add(bestServerFoundSoFar.id), launchGame(placeId, bestServerFoundSoFar.id), showReviewPopup("region_filters");
                  }, "onClick")
                }
              );
            }
          else
            showLoadingOverlayResult("No suitable servers found.", { text: "Close", onClick: /* @__PURE__ */ __name(() => hideLoadingOverlay(!0), "onClick") });
        }
      } catch (error) {
        showLoadingOverlayResult(error.message || "Could not find any servers.");
      } finally {
        isCurrentlyFetchingData = !1;
      }
    }
  }
  __name(performJoinAction, "performJoinAction");
  async function getSavedPreferredRegion() {
    await dataPromise;
    let region = (await chrome.storage.local.get(PREFERRED_REGION_STORAGE_KEY))[PREFERRED_REGION_STORAGE_KEY];
    if (region && region !== "AUTO" && !REGIONS3[region]) {
      try {
        await chrome.storage.local.set({ [PREFERRED_REGION_STORAGE_KEY]: "AUTO" });
      } catch (e) {
        console.error("RoValra: Failed to reset invalid preferred region.", e);
      }
      return "AUTO";
    }
    return region || "AUTO";
  }
  __name(getSavedPreferredRegion, "getSavedPreferredRegion");

  // src/content/features/games/quickplay.js
  var PROCESSED_MARKER_CLASS = "rovalra-quickplay-processed", GLOBAL_CONTAINER_ID = "rovalra-private-servers-global-container", State = {
    currentUserId: null,
    activePlaceId: null,
    activeGameCardLink: null,
    privateServerStatus: /* @__PURE__ */ new Map(),
    privateServerList: /* @__PURE__ */ new Map(),
    privateServerDetails: /* @__PURE__ */ new Map(),
    thumbnails: /* @__PURE__ */ new Map(),
    privateServersContainer: null,
    dropdownPanel: null,
    hideOverlayTimer: null,
    isLoadingPrivateServers: !1,
    currentNextPageCursor: null,
    regions: {},
    serverIpMap: {},
    cleanupTimers: /* @__PURE__ */ new WeakMap()
  }, Icons = {
    globe: /* @__PURE__ */ __name(() => createSvgPath("M19.3 16.9c.4-.7.7-1.5.7-2.4 0-2.5-2-4.5-4.5-4.5S11 12 11 14.5s2 4.5 4.5 4.5c.9 0 1.7-.3 2.4-.7l3.2 3.2 1.4-1.4zm-3.8.1c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5M12 20v2C6.48 22 2 17.52 2 12S6.48 2 12 2c4.84 0 8.87 3.44 9.8 8h-2.07c-.64-2.46-2.4-4.47-4.73-5.41V5c0 1.1-.9 2-2 2h-2v2c0 .55-.45 1-1 1H8v2h2v3H9l-4.79-4.79C4.08 10.79 4 11.38 4 12c0 4.41 3.59 8 8 8"), "globe"),
    privateServer: /* @__PURE__ */ __name(() => createSvgPath("M20 13H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1M7 19c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2M20 3H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1M7 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2"), "privateServer"),
    copy: /* @__PURE__ */ __name(() => createSvgPath("M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z", 20), "copy"),
    generate: /* @__PURE__ */ __name(() => createSvgPath("M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8", 20, "scale(-1, 1)", "center"), "generate"),
    configure: /* @__PURE__ */ __name(() => createSvgPath("M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6"), "configure")
  };
  function createSvgPath(d, size = 22, transform = "", transformOrigin = "") {
    let svg2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (svg2.setAttribute("width", size), svg2.setAttribute("height", size), svg2.setAttribute("viewBox", "0 0 24 24"), svg2.setAttribute("fill", "white"), transform) {
      let g2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g2.setAttribute("transform", transform), transformOrigin && g2.setAttribute("transform-origin", transformOrigin);
      let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", d), g2.appendChild(path), svg2.appendChild(g2);
    } else
      svg2.innerHTML = `<path d="${d}"></path>`;
    return svg2;
  }
  __name(createSvgPath, "createSvgPath");
  function getCurrentUserId2() {
    let userDataTag = document.querySelector('meta[name="user-data"]');
    return userDataTag?.dataset?.userid ? parseInt(userDataTag.dataset.userid, 10) : null;
  }
  __name(getCurrentUserId2, "getCurrentUserId");
  function getGameIdsFromLink(href) {
    try {
      let urlObj = new URL(href, window.location.origin), params = urlObj.searchParams, placeId = params.get("PlaceId");
      if (!placeId) {
        let match = urlObj.pathname.match(/^(?:\/[a-z]{2}(?:-[a-z]{2})?)?\/games\/(\d+)/);
        match && (placeId = match[1]);
      }
      return { placeId, universeId: params.get("universeId") };
    } catch {
      return { placeId: null, universeId: null };
    }
  }
  __name(getGameIdsFromLink, "getGameIdsFromLink");
  function showTemporaryTooltip(parent, text2, duration = 1400) {
    let temp = document.createElement("div");
    temp.className = "rovalra-ps-tooltip", Object.assign(temp.style, {
      position: "absolute",
      zIndex: "10006",
      pointerEvents: "none",
      opacity: "0",
      transition: "opacity 0.12s ease"
    }), temp.innerHTML = text2, document.body.appendChild(temp);
    let rect = parent.getBoundingClientRect();
    temp.style.left = `${rect.left + window.scrollX + rect.width / 2}px`, temp.style.top = `${rect.top + window.scrollY - 8}px`, temp.style.transform = "translate(-50%, -100%)", requestAnimationFrame(() => temp.style.opacity = "1"), setTimeout(() => {
      temp.style.opacity = "0", setTimeout(() => temp.remove(), 150);
    }, duration);
  }
  __name(showTemporaryTooltip, "showTemporaryTooltip");
  function initializeData() {
    chrome.storage.local.get(["cachedRegions", "rovalraDatacenters"], (result) => {
      result.cachedRegions && (State.regions = result.cachedRegions), result.rovalraDatacenters && result.rovalraDatacenters.forEach((entry) => {
        entry.location && entry.dataCenterIds && entry.dataCenterIds.forEach((id) => State.serverIpMap[id] = entry.location);
      });
    });
  }
  __name(initializeData, "initializeData");
  async function getVipServerDetails(vipServerId) {
    if (State.privateServerDetails.has(vipServerId)) return State.privateServerDetails.get(vipServerId);
    try {
      let res = await callRobloxApi({ subdomain: "games", endpoint: `/v1/vip-servers/${vipServerId}` }), data = res.ok ? await res.json() : null;
      return State.privateServerDetails.set(vipServerId, data), data;
    } catch {
      return State.privateServerDetails.set(vipServerId, null), null;
    }
  }
  __name(getVipServerDetails, "getVipServerDetails");
  async function isVipServerActive(vipServerId) {
    if (State.privateServerStatus.has(vipServerId)) return State.privateServerStatus.get(vipServerId);
    try {
      let res = await callRobloxApi({ subdomain: "games", endpoint: `/v1/vip-servers/${vipServerId}` });
      if (!res.ok)
        return State.privateServerStatus.set(vipServerId, !1), !1;
      let data = await res.json(), isExpired = data.subscription?.expired === !0, isActive = data.active === !0 && !isExpired;
      return State.privateServerStatus.set(vipServerId, isActive), isActive;
    } catch {
      return State.privateServerStatus.set(vipServerId, !1), !1;
    }
  }
  __name(isVipServerActive, "isVipServerActive");
  async function getThumbnails(userIds) {
    let idsToFetch = userIds.filter((id) => !State.thumbnails.has(id));
    if (idsToFetch.length > 0) {
      let items = idsToFetch.map((id) => ({ id }));
      try {
        (await fetchThumbnails(items, "AvatarHeadshot", "150x150", !0)).forEach((thumbData, userId) => {
          thumbData.state === "Completed" && State.thumbnails.set(userId, thumbData.imageUrl);
        });
      } catch (e) {
        console.error("Quick Play: Thumb fetch failed", e);
      }
    }
    let finalMap = {};
    return userIds.forEach((id) => {
      State.thumbnails.has(id) && (finalMap[id] = State.thumbnails.get(id));
    }), finalMap;
  }
  __name(getThumbnails, "getThumbnails");
  function createGlobalPrivateServerContainer() {
    if (document.getElementById(GLOBAL_CONTAINER_ID)) return;
    let { element: dropdownPanel } = createDropdownContent(document.body, [], null, () => {
    }, () => {
    });
    dropdownPanel.id = GLOBAL_CONTAINER_ID, Object.assign(dropdownPanel.style, { width: "320px", minWidth: "0px", maxHeight: "400px" }), dropdownPanel.setAttribute("data-state", "closed"), document.body.appendChild(dropdownPanel), State.dropdownPanel = dropdownPanel, State.privateServersContainer = dropdownPanel.querySelector(".flex-dropdown-menu"), State.privateServersContainer && (State.privateServersContainer.className = "rovalra-ps-list-container", State.privateServersContainer.addEventListener("scroll", (e) => {
      if (State.isLoadingPrivateServers || !State.currentNextPageCursor || !State.activePlaceId) return;
      let { scrollTop, scrollHeight, clientHeight } = e.target;
      scrollHeight - scrollTop - clientHeight < 50 && fetchAndDisplayPrivateServers(State.activePlaceId, !0, State.currentNextPageCursor);
    })), dropdownPanel.addEventListener("mouseenter", () => {
      if (clearTimeout(State.hideOverlayTimer), State.activeGameCardLink) {
        let timerId = State.cleanupTimers.get(State.activeGameCardLink);
        timerId && clearTimeout(timerId), State.activeGameCardLink.classList.add("quick-play-hover-active");
      }
    }), dropdownPanel.addEventListener("mouseleave", () => {
      State.hideOverlayTimer = setTimeout(hidePrivateServersOverlay, 200), State.activeGameCardLink && scheduleCardCleanup(State.activeGameCardLink);
    });
  }
  __name(createGlobalPrivateServerContainer, "createGlobalPrivateServerContainer");
  async function fetchAndDisplayPrivateServers(placeId, loadMore = !1, nextPageCursor = null) {
    if (State.isLoadingPrivateServers) return;
    State.isLoadingPrivateServers = !0;
    let isDark = document.body.classList.contains("dark-theme");
    try {
      if (!loadMore && (State.privateServersContainer.innerHTML = purify.sanitize('<p style="color: var(--rovalra-secondary-text-color); text-align: center; padding: 10px 0;">Loading...</p>'), State.privateServerList.has(placeId))) {
        let cached = State.privateServerList.get(placeId), thumbs2 = await getThumbnails(cached.servers.map((s) => s.owner.id));
        renderPrivateServers(placeId, cached.servers, cached.nextPageCursor, thumbs2, !1), State.isLoadingPrivateServers = !1;
        return;
      }
      let res, retryDelay = 1e3;
      for (; ; ) {
        if (State.activePlaceId !== placeId || !State.dropdownPanel.classList.contains("visible")) {
          State.isLoadingPrivateServers = !1;
          return;
        }
        if (res = await callRobloxApi({
          subdomain: "games",
          endpoint: `/v1/games/${placeId}/private-servers?limit=100&sortOrder=Desc${nextPageCursor ? `&cursor=${nextPageCursor}` : ""}`
        }), res.status === 429) {
          loadMore || (State.privateServersContainer.innerHTML = purify.sanitize('<p style="color: var(--rovalra-secondary-text-color); text-align: center; padding: 10px 0;">Rate limited. Retrying...</p>')), await new Promise((resolve) => setTimeout(resolve, retryDelay)), retryDelay = Math.min(retryDelay * 2, 8e3);
          continue;
        }
        break;
      }
      if (!res.ok) throw new Error("Failed to fetch");
      let data = await res.json(), serversToDisplay = data.data;
      State.currentUserId && (serversToDisplay = (await Promise.all(data.data.map(async (s) => s.owner.id === State.currentUserId ? await isVipServerActive(s.vipServerId) ? s : null : s))).filter((s) => s !== null));
      let thumbs = await getThumbnails(serversToDisplay.map((s) => s.owner.id));
      if (loadMore) {
        let cached = State.privateServerList.get(placeId) || { servers: [], nextPageCursor: null };
        cached.servers.push(...serversToDisplay), cached.nextPageCursor = data.nextPageCursor, renderPrivateServers(placeId, serversToDisplay, data.nextPageCursor, thumbs, !0);
      } else
        State.privateServerList.set(placeId, { servers: serversToDisplay, nextPageCursor: data.nextPageCursor }), renderPrivateServers(placeId, serversToDisplay, data.nextPageCursor, thumbs, !1);
    } catch {
      State.activePlaceId === placeId && (State.privateServersContainer.innerHTML = purify.sanitize('<p style="text-align: center;">Could not load servers.</p>'));
    } finally {
      State.isLoadingPrivateServers = !1;
    }
  }
  __name(fetchAndDisplayPrivateServers, "fetchAndDisplayPrivateServers");
  function renderPrivateServers(placeId, servers, nextPageCursor, thumbnails, append) {
    let isDark = document.body.classList.contains("dark-theme");
    if (append || (State.privateServersContainer.innerHTML = ""), State.currentNextPageCursor = nextPageCursor, !servers.length && !append) {
      let msg = document.createElement("p");
      msg.textContent = "No active private servers found.", Object.assign(msg.style, { color: "var(--rovalra-secondary-text-color)", textAlign: "center", padding: "10px 0" }), State.privateServersContainer.appendChild(msg);
      return;
    }
    let fragment = document.createDocumentFragment();
    servers.forEach((server) => {
      let el2 = document.createElement("div");
      el2.className = "private-server-item";
      let thumbUrl = thumbnails[server.owner.id];
      el2.innerHTML = safeHtml`
            <a href="https://www.roblox.com/users/${server.owner.id}/profile" target="_blank" class="private-server-owner-thumb-link">
                <img class="private-server-owner-thumb" src="${thumbUrl || ""}">
            </a>
            <div class="private-server-info">
                <span class="private-server-name" title="${server.name}">${server.name}</span>
                <span class="private-server-players">${server.players.length} / ${server.maxPlayers}</span>
            </div>
        `;
      let thumbLink = el2.querySelector(".private-server-owner-thumb-link");
      if (thumbLink && thumbLink.addEventListener("click", (e) => e.stopPropagation()), server.owner.id === State.currentUserId) {
        let actions = document.createElement("div");
        actions.className = "private-server-owner-actions";
        let createActionBtn = /* @__PURE__ */ __name((icon, tooltip, onClick2, initDisabled = !1) => {
          let btn = createButton("", "secondary");
          return btn.classList.add("private-server-action-btn"), btn.append(icon()), addTooltip(btn, tooltip, { position: "top" }), btn.disabled = initDisabled, btn.onclick = (e) => {
            e.preventDefault(), e.stopPropagation(), onClick2(btn);
          }, btn;
        }, "createActionBtn");
        actions.append(
          createActionBtn(Icons.configure, "Configure", () => window.open(`https://www.roblox.com/private-server/configure/${server.vipServerId}`, "_blank")),
          createActionBtn(Icons.copy, "Copy Link", async (btn) => {
            btn.disabled = !0;
            let details = await getVipServerDetails(server.vipServerId);
            details?.link ? (await navigator.clipboard.writeText(details.link), showTemporaryTooltip(btn, "Copied!")) : showTemporaryTooltip(btn, "Error!"), setTimeout(() => btn.disabled = !1, 1500);
          }, !0),
          createActionBtn(Icons.generate, "Generate New Link", async (btn) => {
            let oldContent = btn.innerHTML;
            btn.innerHTML = "...", btn.disabled = !0, (await callRobloxApi({ subdomain: "games", endpoint: `/v1/vip-servers/${server.vipServerId}`, method: "PATCH", body: { newJoinCode: !0 } })).ok && State.privateServerDetails.delete(server.vipServerId), setTimeout(() => {
              btn.innerHTML = oldContent, btn.disabled = !1;
            }, 1500);
          })
        ), getVipServerDetails(server.vipServerId).then((d) => {
          let copyBtn = actions.querySelector("button:nth-child(2)");
          d?.link && copyBtn && (copyBtn.disabled = !1);
        }), el2.appendChild(actions);
      }
      let joinBtn = document.createElement("button");
      joinBtn.className = "private-server-join-btn", joinBtn.innerHTML = purify.sanitize('<span class="icon-common-play"></span>'), joinBtn.onclick = (e) => {
        e.preventDefault(), e.stopPropagation(), launchPrivateGame(placeId, server.accessCode, server.vipServerId), showReviewPopup("quickplay"), hidePrivateServersOverlay();
      }, el2.appendChild(joinBtn), fragment.appendChild(el2);
    }), State.privateServersContainer.appendChild(fragment);
  }
  __name(renderPrivateServers, "renderPrivateServers");
  function showPrivateServerOverlay(gameLink, placeId) {
    if (State.activeGameCardLink === gameLink) {
      hidePrivateServersOverlay();
      return;
    }
    State.activeGameCardLink && State.activeGameCardLink.classList.remove("quick-play-hover-active"), State.activeGameCardLink = gameLink, State.activePlaceId = placeId, gameLink.classList.add("quick-play-hover-active");
    let dropdown = State.dropdownPanel;
    if (!dropdown) return;
    let rect = gameLink.getBoundingClientRect(), width = 320;
    dropdown.style.width = `${width}px`;
    let left = rect.left + window.scrollX + rect.width / 2 - width / 2;
    left = Math.max(10, Math.min(left, document.documentElement.clientWidth - width - 10));
    let top = rect.bottom + window.scrollY + 8;
    dropdown.style.top = `${top}px`, dropdown.style.left = `${left}px`, dropdown.classList.add("visible");
    try {
      dropdown.setAttribute("data-state", "open");
    } catch {
    }
    fetchAndDisplayPrivateServers(placeId);
  }
  __name(showPrivateServerOverlay, "showPrivateServerOverlay");
  function hidePrivateServersOverlay() {
    if (!(State.dropdownPanel && State.dropdownPanel.matches(":hover")) && !(!State.dropdownPanel || !State.dropdownPanel.classList.contains("visible"))) {
      State.activeGameCardLink && State.activeGameCardLink.classList.remove("quick-play-hover-active"), State.dropdownPanel.classList.remove("visible");
      try {
        State.dropdownPanel.setAttribute("data-state", "closed");
      } catch {
      }
      State.activeGameCardLink = null, State.activePlaceId = null, State.currentNextPageCursor = null;
    }
  }
  __name(hidePrivateServersOverlay, "hidePrivateServersOverlay");
  function forceCleanOtherCards(exceptCard) {
    document.querySelectorAll(".game-card-link.quick-play-hover-active").forEach((card) => {
      if (card !== exceptCard) {
        if (State.activeGameCardLink === card && State.dropdownPanel?.matches(":hover"))
          return;
        performCardCleanup(card);
      }
    });
  }
  __name(forceCleanOtherCards, "forceCleanOtherCards");
  function performCardCleanup(gameLink) {
    gameLink.classList.remove("quick-play-hover-active"), gameLink.matches(":hover") || (gameLink.querySelector(".hover-background")?.remove(), gameLink.querySelector(".play-button-overlay")?.remove(), gameLink.classList.remove("game-tile-styles"), gameLink.querySelectorAll(".quick-play-original-stats").forEach((el2) => el2.classList.remove("quick-play-original-stats")));
  }
  __name(performCardCleanup, "performCardCleanup");
  function scheduleCardCleanup(gameLink) {
    let existing = State.cleanupTimers.get(gameLink);
    existing && clearTimeout(existing);
    let timerId = setTimeout(() => {
      gameLink.matches(":hover") || State.activeGameCardLink === gameLink && State.dropdownPanel?.matches(":hover") || (State.activeGameCardLink === gameLink && hidePrivateServersOverlay(), performCardCleanup(gameLink));
    }, 100);
    State.cleanupTimers.set(gameLink, timerId);
  }
  __name(scheduleCardCleanup, "scheduleCardCleanup");
  async function setupHoverCard(gameLink, settings) {
    forceCleanOtherCards(gameLink);
    let existing = State.cleanupTimers.get(gameLink);
    if (existing && clearTimeout(existing), gameLink.querySelector(".play-button-overlay")) {
      gameLink.classList.add("quick-play-hover-active");
      return;
    }
    gameLink.classList.add("game-tile-styles");
    let isSpecialLayout = gameLink.closest(".featured-game-container, .featured-grid-item-container");
    if (!isSpecialLayout) {
      let hoverBg = document.createElement("div");
      hoverBg.className = "hover-background", gameLink.appendChild(hoverBg);
    }
    let overlay = document.createElement("div");
    overlay.className = "play-button-overlay";
    let wrapper = document.createElement("div");
    wrapper.className = "play-buttons-wrapper";
    let { placeId, universeId } = getGameIdsFromLink(gameLink.href), handlePreferredJoin = /* @__PURE__ */ __name(async (e) => {
      if (e.preventDefault(), e.stopPropagation(), hidePrivateServersOverlay(), !!placeId)
        try {
          let savedRegion = await getSavedPreferredRegion();
          await performJoinAction(placeId, universeId, savedRegion === "AUTO" ? null : savedRegion);
        } catch {
        }
    }, "handlePreferredJoin"), handleNormalJoin = /* @__PURE__ */ __name((e) => {
      e.preventDefault(), e.stopPropagation(), hidePrivateServersOverlay(), placeId && (launchGame(placeId), showReviewPopup("quickplay"));
    }, "handleNormalJoin"), playBtn = document.createElement("button");
    if (playBtn.className = "play-game-button", playBtn.innerHTML = purify.sanitize('<span class="icon-common-play"></span>'), settings.PreferredRegionEnabled && settings.playbuttonpreferredregionenabled ? (playBtn.onclick = handlePreferredJoin, settings.robloxPreferredRegion === "AUTO" ? addTooltip(playBtn, "Join Closest Server") : addRegionTooltip(playBtn)) : playBtn.onclick = handleNormalJoin, wrapper.appendChild(playBtn), settings.PreferredRegionEnabled && !settings.playbuttonpreferredregionenabled) {
      let regionBtn = document.createElement("button");
      regionBtn.className = "server-browser-button", regionBtn.appendChild(Icons.globe()), regionBtn.onclick = handlePreferredJoin, settings.robloxPreferredRegion === "AUTO" ? addTooltip(regionBtn, "Join Closest Server") : addRegionTooltip(regionBtn), wrapper.appendChild(regionBtn);
    }
    if (settings.privateservers) {
      let psBtn = document.createElement("button");
      psBtn.className = "private-servers-button", psBtn.append(Icons.privateServer()), addTooltip(psBtn, "Private Servers"), psBtn.onclick = (e) => {
        e.preventDefault(), e.stopPropagation(), placeId && showPrivateServerOverlay(gameLink, placeId);
      }, wrapper.appendChild(psBtn), gameLink.addEventListener("mouseenter", () => {
        State.dropdownPanel?.classList.contains("visible") && State.activeGameCardLink === gameLink && clearTimeout(State.hideOverlayTimer);
      }), gameLink.addEventListener("mouseleave", () => {
        State.activeGameCardLink === gameLink && (State.hideOverlayTimer = setTimeout(hidePrivateServersOverlay, 200));
      });
    }
    overlay.appendChild(wrapper), gameLink.appendChild(overlay), isSpecialLayout || gameLink.querySelectorAll(".game-card-info:has(.icon-votes-gray), .game-card-info:has(.icon-playing-counts-gray), .game-card-friend-info").forEach((el2) => el2.classList.add("quick-play-original-stats")), requestAnimationFrame(() => gameLink.classList.add("quick-play-hover-active"));
  }
  __name(setupHoverCard, "setupHoverCard");
  async function addRegionTooltip(button) {
    let regionCode = (await new Promise((r) => chrome.storage.local.get("robloxPreferredRegion", (res) => r(res)))).robloxPreferredRegion, text2 = regionCode && State.regions[regionCode] ? `Join Preferred Region<br><b>${getFullRegionName(regionCode)}</b>` : "Select Preferred Region";
    addTooltip(button, text2);
  }
  __name(addRegionTooltip, "addRegionTooltip");
  function initializeQuickPlay() {
    window.hasRunQuickPlayScript || (window.hasRunQuickPlayScript = !0, window.EMULATE_API_FAILURE = !0, State.currentUserId = getCurrentUserId2(), initializeData(), createGlobalPrivateServerContainer(), chrome.storage.local.get({
      PreferredRegionEnabled: !0,
      privateservers: !0,
      playbuttonpreferredregionenabled: !0,
      robloxPreferredRegion: "AUTO"
    }, (settings) => {
      observeElement('a.game-card-link[href*="/games/"]', /* @__PURE__ */ __name((gameLink) => {
        gameLink.closest('[data-testid="event-experience-link"]') || gameLink.classList.contains(PROCESSED_MARKER_CLASS) || (gameLink.classList.add(PROCESSED_MARKER_CLASS), gameLink.addEventListener("mouseenter", () => setupHoverCard(gameLink, settings)), gameLink.addEventListener("mouseleave", () => scheduleCardCleanup(gameLink)), gameLink.addEventListener("focus", () => setupHoverCard(gameLink, settings)), gameLink.addEventListener("blur", () => scheduleCardCleanup(gameLink)));
      }, "onCardFound"), { multiple: !0 });
    }), window.addEventListener("beforeunload", () => {
      State.dropdownPanel?.remove(), document.getElementById("rovalra-global-quickplay-tooltip")?.remove(), window.hasRunQuickPlayScript = !1;
    }, { once: !0 }));
  }
  __name(initializeQuickPlay, "initializeQuickPlay");
  function init25() {
    chrome.storage.local.get({ QuickPlayEnable: !0 }, (settings) => {
      settings.QuickPlayEnable && (document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", initializeQuickPlay) : initializeQuickPlay());
    });
  }
  __name(init25, "init");

  // src/content/core/games/servers/serverids.js
  var extractorScriptInjected = !1;
  function injectExtractorScript() {
    if (extractorScriptInjected) return;
    let script = document.createElement("script");
    script.src = chrome.runtime.getURL("public/Assets/data/serverid_extractor.js"), (document.head || document.documentElement).appendChild(script), extractorScriptInjected = !0;
  }
  __name(injectExtractorScript, "injectExtractorScript");
  async function extractServerIdFromFiber(server) {
    return server ? (injectExtractorScript(), new Promise((resolve) => {
      let extractionId = `rovalra_extract_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      server.setAttribute("data-rovalra-extraction-id", extractionId);
      let listener = /* @__PURE__ */ __name((event) => {
        event.detail && event.detail.extractionId === extractionId && (window.removeEventListener("rovalra-serverid-extracted", listener), server.removeAttribute("data-rovalra-extraction-id"), resolve(event.detail.serverId || null));
      }, "listener");
      window.addEventListener("rovalra-serverid-extracted", listener), window.dispatchEvent(new CustomEvent("rovalra-extract-serverid-request", {
        detail: { extractionId }
      })), setTimeout(() => {
        window.removeEventListener("rovalra-serverid-extracted", listener), server.removeAttribute("data-rovalra-extraction-id"), resolve(null);
      }, 1e3);
    })) : null;
  }
  __name(extractServerIdFromFiber, "extractServerIdFromFiber");
  async function processServerElement(serverItem, retries = 5) {
    try {
      let serverId = await extractServerIdFromFiber(serverItem);
      if (serverId && serverId.length > 0) {
        if (serverItem.getAttribute("data-rovalra-serverid") !== serverId) {
          serverItem.setAttribute("data-rovalra-serverid", serverId);
          let event = new CustomEvent("rovalra-serverid-set", {
            detail: { serverId },
            bubbles: !0
          });
          serverItem.dispatchEvent(event);
        }
      } else if (serverItem.classList.contains("rbx-private-game-server-item") && !serverItem.hasAttribute("data-private-server-id") && retries > 0) {
        setTimeout(() => processServerElement(serverItem, retries - 1), 1e3);
        return;
      }
      serverItem.classList.add("rovalra-checked");
    } catch (e) {
      console.error("[RoValra ServerIDs] Error processing server:", e);
    }
  }
  __name(processServerElement, "processServerElement");
  function watchServerElement(serverItem) {
    let observer = new MutationObserver((mutations) => {
      mutations.some((mutation) => {
        if (mutation.type === "childList") {
          let target = mutation.target;
          if (target.classList?.contains("player-thumbnails-container") || target.closest(".player-thumbnails-container"))
            return !0;
        }
        return !1;
      }) && (serverItem.classList.remove("rovalra-checked"), processServerElement(serverItem));
    });
    observer.observe(serverItem, {
      childList: !0,
      subtree: !0
    }), serverItem._rovalraServerObserver = observer;
  }
  __name(watchServerElement, "watchServerElement");
  function initServerIdExtraction() {
    injectExtractorScript(), [
      ".rbx-public-game-server-item",
      ".rbx-friends-game-server-item",
      ".rbx-private-game-server-item"
    ].forEach((selector) => {
      observeElement(selector, (serverElement) => {
        processServerElement(serverElement), watchServerElement(serverElement);
      }, { multiple: !0 });
    });
  }
  __name(initServerIdExtraction, "initServerIdExtraction");

  // src/content/core/games/servers/serverstats.js
  var versionDataCache = null, statsBarObserverAttached = !1;
  async function fetchLatestPlaceVersion(placeId) {
    if (!placeId) return null;
    try {
      let response = await callRobloxApi({
        subdomain: "develop",
        endpoint: "/v1/assets/latest-versions",
        method: "POST",
        body: {
          assetIds: [parseInt(placeId, 10)],
          versionStatus: "Published"
        }
      });
      if (!response.ok)
        throw new Error(`Roblox API request failed with status: ${response.status}`);
      let data = await response.json();
      if (data.results && data.results.length > 0) {
        let result = data.results[0];
        if (result.status === "Success" && result.versionNumber)
          return result.versionNumber;
      }
      return null;
    } catch (error) {
      return console.error("RoValra Server Stats: Failed to fetch latest place version from Roblox.", error), null;
    }
  }
  __name(fetchLatestPlaceVersion, "fetchLatestPlaceVersion");
  async function fetchServerStats(placeId) {
    if (!placeId) return null;
    try {
      let response = await callRobloxApi({
        subdomain: "apis",
        endpoint: `/v1/servers/counts?place_id=${placeId}`,
        method: "GET",
        isRovalraApi: !0
      });
      if (!response.ok)
        throw new Error(`API request failed with status: ${response.status}`);
      let data = await response.json();
      if (data.status !== "success" || !data.counts)
        throw new Error("API returned an error or invalid data.");
      data.counts.regions && typeof data.counts.total_servers != "number" && (data.counts.total_servers = Object.values(data.counts.regions).reduce((acc, val) => acc + (Number(val) || 0), 0));
      let robloxVersion = await fetchLatestPlaceVersion(placeId);
      return robloxVersion && (data.counts.newest_place_version = robloxVersion), data.counts;
    } catch (error) {
      return console.error("RoValra Server Stats: Failed to fetch server statistics.", error), null;
    }
  }
  __name(fetchServerStats, "fetchServerStats");
  function detectTheme2() {
    return document.body.classList.contains("dark-theme") ? "dark" : "light";
  }
  __name(detectTheme2, "detectTheme");
  function createStatItem(icon, label, value, theme) {
    return `
        <div class="rovalra-stat-item">
            <div class="stat-icon ${theme}">${icon}</div>
            <div class="stat-text">
                <span class="stat-value ${theme}">${value.toLocaleString()}</span>
                <span class="stat-label ${theme}">${label}</span>
            </div>
        </div>`;
  }
  __name(createStatItem, "createStatItem");
  function applyVersionAttributes(element) {
    if (!versionDataCache) return;
    let serverItemContainer = element || document.getElementById("rbx-public-game-server-item-container");
    serverItemContainer && !serverItemContainer.hasAttribute("data-newest-version") && (versionDataCache.newest_place_version && (serverItemContainer.dataset.newestVersion = versionDataCache.newest_place_version), versionDataCache.oldest_place_version && (serverItemContainer.dataset.oldestVersion = versionDataCache.oldest_place_version));
  }
  __name(applyVersionAttributes, "applyVersionAttributes");
  async function createStatsBarUI(serverListContainer) {
    if (serverListContainer.dataset.statsBarInitialized) return;
    serverListContainer.dataset.statsBarInitialized = "true";
    let settings;
    try {
      settings = await new Promise((resolve, reject) => {
        chrome.storage.local.get(["TotalServersEnabled", "GameVersionEnabled", "OldestVersionEnabled"], (result) => {
          if (chrome.runtime.lastError) return reject(chrome.runtime.lastError);
          resolve(result);
        });
      });
    } catch (error) {
      console.error("RoValra Server Stats: Failed to fetch settings.", error);
      return;
    }
    if (settings.TotalServersEnabled !== !0)
      return;
    let header = serverListContainer.querySelector(".container-header");
    if (!header) return;
    serverListContainer.querySelector(".rovalra-stats-container")?.remove();
    let counts = versionDataCache, theme = detectTheme2(), hasRegions = counts.regions && Object.keys(counts.regions).length > 0, hasActiveStats = counts.total_servers > 0 && hasRegions;
    if (!hasActiveStats && !counts.newest_place_version)
      return;
    let statsContainer = document.createElement("div");
    if (statsContainer.className = "rovalra-stats-container", statsContainer.style.cssText = "display: flex; gap: 0; margin-bottom: 9px; margin-left: 9px; gap: 4.5px; align-items: center;", hasActiveStats) {
      let totalServersBar = document.createElement("div");
      totalServersBar.className = `rovalra-region-stats-bar ${theme}`;
      let totalIcon = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20 13H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1M7 19c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2M20 3H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1M7 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2" fill="currentColor"></path></svg>';
      totalServersBar.innerHTML = purify.sanitize(createStatItem(totalIcon, "Total Servers", counts.total_servers, theme)), addTooltip(totalServersBar, "Total servers RoValra is tracking under this experience", { position: "top" }), statsContainer.appendChild(totalServersBar);
    }
    if (settings.GameVersionEnabled === !0 && counts.newest_place_version) {
      let versionBar = document.createElement("div");
      versionBar.className = `rovalra-region-stats-bar ${theme}`;
      let versionIcon = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21 10.12h-6.78l2.74-2.82c-2.73-2.7-7.15-2.8-9.88-.1-2.73 2.71-2.73 7.08 0 9.79s7.15 2.71 9.88 0C18.32 15.65 19 14.08 19 12.1h2c0 1.98-.88 4.55-2.64 6.29-3.51 3.48-9.21 3.48-12.72 0-3.5-3.47-3.53-9.11-.02-12.58s9.14-3.47 12.65 0L21 3zM12.5 8v4.25l3.5 2.08-.72 1.21L11 13V8z" fill="currentColor"></path></svg>';
      versionBar.innerHTML = purify.sanitize(createStatItem(versionIcon, "Version", `v${counts.newest_place_version}`, theme)), addTooltip(versionBar, "The current version published.", { position: "top" }), statsContainer.appendChild(versionBar);
    }
    if (settings.OldestVersionEnabled === !0 && counts.oldest_place_version && hasActiveStats) {
      let oldestVersionBar = document.createElement("div");
      oldestVersionBar.className = `rovalra-region-stats-bar ${theme}`;
      let oldestVersionIcon = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: scaleX(-1);"><path d="M21 10.12h-6.78l2.74-2.82c-2.73-2.7-7.15-2.8-9.88-.1-2.73 2.71-2.73 7.08 0 9.79s7.15 2.71 9.88 0C18.32 15.65 19 14.08 19 12.1h2c0 1.98-.88 4.55-2.64 6.29-3.51 3.48-9.21 3.48-12.72 0-3.5-3.47-3.53-9.11-.02-12.58s9.14-3.47 12.65 0L21 3zM12.5 8v4.25l3.5 2.08-.72 1.21L11 13V8z" fill="currentColor"></path></svg>';
      oldestVersionBar.innerHTML = purify.sanitize(createStatItem(oldestVersionIcon, "Oldest", `v${counts.oldest_place_version}`, theme)), addTooltip(oldestVersionBar, "The oldest version a server is currently running.", { position: "top" }), statsContainer.appendChild(oldestVersionBar);
    }
    if (serverListContainer.closest("#roseal-running-game-instances-container")) {
      let controls = document.getElementById("rovalra-main-controls"), options = serverListContainer.querySelector(".server-list-options");
      controls && serverListContainer.contains(controls) ? controls.insertAdjacentElement("afterend", statsContainer) : options ? options.insertAdjacentElement("afterend", statsContainer) : serverListContainer.appendChild(statsContainer);
    } else
      header.insertAdjacentElement("afterend", statsContainer);
  }
  __name(createStatsBarUI, "createStatsBarUI");
  async function initGlobalStatsBar() {
    if (statsBarObserverAttached)
      return;
    let placeId = window.location.pathname.match(/\/games\/(\d+)\//)?.[1];
    if (placeId) {
      statsBarObserverAttached = !0, startObserving(), observeElement("#rbx-public-game-server-item-container", (element) => {
        applyVersionAttributes(element);
      }), observeElement("#rbx-public-running-games", (element) => {
        versionDataCache && createStatsBarUI(element);
      });
      try {
        let data = await fetchServerStats(placeId);
        if (data) {
          versionDataCache = data, applyVersionAttributes();
          let serverListContainer = document.getElementById("rbx-public-running-games");
          serverListContainer && createStatsBarUI(serverListContainer);
        }
      } catch (error) {
        console.error("RoValra Server Stats: Failed to initialize stats bar.", error);
      }
    }
  }
  __name(initGlobalStatsBar, "initGlobalStatsBar");

  // src/content/core/games/servers/filters/regionfilters.js
  var DEFAULT_PLACE_ID = window.ROVALRA_PLACE_ID, GLOBE_DRAG_THRESHOLD = 6, GLOBE_PANEL_ID = "rovalra-globe-panel", GLOBE_CONTAINER_ID = "rovalra-globe-container", GLOBE_TOOLTIP_ID = "rovalra-globe-tooltip", EASTER_EGG_TRIGGER_ID = "rovalra-easter-egg-trigger", HEADER_TITLE_ID = "rovalra-header-title", EVT_REGIONS_UPDATED = "rovalraRegionsUpdated", EVT_GLOBE_UPDATE_DATA = "rovalraGlobe_UpdateData", EVT_GLOBE_EASTER_EGG = "rovalraGlobeEasterEgg", EVT_GLOBE_EASTER_EGG_OFF = "rovalraGlobeEasterEggOff", EVT_INIT_GLOBE = "initRovalraGlobe", EVT_REGION_SELECTED = "rovalraRegionSelected", EVT_UPTIME_SELECTED = "rovalraUptimeSelected", EVT_CLEAR_FILTERS = "rovalraClearFilters", EVT_REGION_SERVERS_LOADED = "rovalraRegionServersLoaded", EVT_REQUEST_REGION_SERVERS = "rovalraRequestRegionServers", EVT_GLOBE_HOVER = "rovalraGlobeHover", US_STATE_NAME_TO_CODE = {
    ALABAMA: "AL",
    ALASKA: "AK",
    ARIZONA: "AZ",
    ARKANSAS: "AR",
    CALIFORNIA: "CA",
    COLORADO: "CO",
    CONNECTICUT: "CT",
    DELAWARE: "DE",
    FLORIDA: "FL",
    GEORGIA: "GA",
    HAWAII: "HI",
    IDAHO: "ID",
    ILLINOIS: "IL",
    INDIANA: "IN",
    IOWA: "IA",
    KANSAS: "KS",
    KENTUCKY: "KY",
    LOUISIANA: "LA",
    MAINE: "ME",
    MARYLAND: "MD",
    MASSACHUSETTS: "MA",
    MICHIGAN: "MI",
    MINNESOTA: "MN",
    MISSISSIPPI: "MS",
    MISSOURI: "MO",
    MONTANA: "MT",
    NEBRASKA: "NE",
    NEVADA: "NV",
    "NEW HAMPSHIRE": "NH",
    "NEW JERSEY": "NJ",
    "NEW MEXICO": "NM",
    "NEW YORK": "NY",
    "NORTH CAROLINA": "NC",
    "NORTH DAKOTA": "ND",
    OHIO: "OH",
    OKLAHOMA: "OK",
    OREGON: "OR",
    PENNSYLVANIA: "PA",
    "RHODE ISLAND": "RI",
    "SOUTH CAROLINA": "SC",
    "SOUTH DAKOTA": "SD",
    TENNESSEE: "TN",
    TEXAS: "TX",
    UTAH: "UT",
    VERMONT: "VT",
    VIRGINIA: "VA",
    WASHINGTON: "WA",
    "WEST VIRGINIA": "WV",
    WISCONSIN: "WI",
    WYOMING: "WY",
    "DISTRICT OF COLUMBIA": "DC"
  }, State2 = {
    regions: {},
    dataCenterCounts: {},
    serverIpMap: {},
    regionServersCache: {},
    activeServerCounts: {},
    flags: {},
    apiCounts: null,
    allLocalServerIds: /* @__PURE__ */ new Set(),
    localServersByRegion: {},
    isGlobeOpen: !1,
    easterEggActive: !1,
    isScanning: !1,
    scanCursor: null,
    scanCompleted: !1,
    globe: {
      assetsLoaded: !1,
      initDispatched: !1,
      pointerDown: !1,
      pointerDragged: !1,
      startX: 0,
      startY: 0,
      lastDragTime: 0,
      scriptPromise: null,
      resourcesPreloaded: !1
    },
    injected: !1,
    listenersAttached: !1,
    storageListenerAttached: !1
  };
  function normalizeKey(s) {
    return String(s || "").toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/\s+/g, "");
  }
  __name(normalizeKey, "normalizeKey");
  function detectTheme3() {
    try {
      let body = document.body;
      return body && (body.classList.contains("dark-theme") || body.classList.contains("rbx-dark-theme")) ? "dark" : "light";
    } catch {
      return "light";
    }
  }
  __name(detectTheme3, "detectTheme");
  function injectScript(src) {
    return new Promise((resolve, reject) => {
      let s = document.createElement("script");
      s.src = src, s.onload = () => {
        s.remove(), resolve();
      }, s.onerror = () => {
        s.remove(), reject(new Error(`Failed to load ${src}`));
      }, (document.head || document.documentElement).appendChild(s);
    });
  }
  __name(injectScript, "injectScript");
  function getPlaceIdFromUrl3() {
    try {
      let url = window.location.href, qp = new URLSearchParams(window.location.search), qpId = qp.get("placeId") || qp.get("place_id") || qp.get("placeid");
      if (qpId && /^\d+$/.test(qpId)) return qpId;
      let match = url.match(/\/games\/([0-9]+)/i) || url.match(/\/(\d{5,})\b/);
      if (match) return match[1];
    } catch {
    }
    return DEFAULT_PLACE_ID;
  }
  __name(getPlaceIdFromUrl3, "getPlaceIdFromUrl");
  async function cacheFlag(countryCode) {
    let code = countryCode.toLowerCase();
    if (!State2.flags[code])
      try {
        let blob = await (await fetch(`https://flagcdn.com/w40/${code}.png`)).blob();
        State2.flags[code] = URL.createObjectURL(blob);
      } catch {
        console.warn("RoValra: Failed to cache flag for", code);
      }
  }
  __name(cacheFlag, "cacheFlag");
  function closeGlobalPanels() {
    let globe = document.getElementById(GLOBE_PANEL_ID);
    globe && globe.classList.remove("show");
    let tooltip = document.getElementById(GLOBE_TOOLTIP_ID);
    tooltip && (tooltip.style.display = "none", tooltip.innerHTML = ""), document.querySelectorAll(".rovalra-side-panel.show").forEach((p) => p.classList.remove("show")), document.querySelectorAll(".filter-dropdown-container button.active").forEach((b2) => b2.classList.remove("active")), State2.isGlobeOpen = !1, State2.isScanning = !1;
  }
  __name(closeGlobalPanels, "closeGlobalPanels");
  function getInternalStateCode(stateName) {
    if (!stateName) return "";
    let upper = stateName.toUpperCase().trim();
    if (US_STATE_NAME_TO_CODE[upper]) return US_STATE_NAME_TO_CODE[upper];
    if (typeof getStateCodeFromRegion == "function") {
      let res = getStateCodeFromRegion(stateName);
      if (res) return res;
    }
    return "";
  }
  __name(getInternalStateCode, "getInternalStateCode");
  function resolveApiRegionCode(internalCode) {
    if (!internalCode) return internalCode;
    let detailed = State2.apiCounts?.counts?.detailed_regions;
    if (detailed) {
      let internalNorm = normalizeKey(internalCode);
      for (let [apiCode, entry] of Object.entries(detailed)) {
        let parts = apiCode.split("-"), country = parts[0], stateCode = "";
        if (country === "US" && parts.length > 1) {
          let stateName = parts.slice(1).join("-");
          stateCode = getInternalStateCode(stateName);
        }
        if (entry.cities)
          for (let city of Object.keys(entry.cities)) {
            let candidate;
            if (country === "US" && stateCode ? candidate = `US-${stateCode}-${city.replace(/\s+/g, "")}` : candidate = `${country}-${city.replace(/\s+/g, "")}`, normalizeKey(candidate) === internalNorm) return internalCode;
          }
        if (normalizeKey(apiCode) === internalNorm) return apiCode;
      }
    }
    let countryPrefix = internalCode.split("-")[0];
    return State2.apiCounts?.counts?.regions?.[countryPrefix] ? countryPrefix : internalCode;
  }
  __name(resolveApiRegionCode, "resolveApiRegionCode");
  function buildServerCountsMap(apiJson) {
    let out = {};
    if (!apiJson?.counts) return out;
    let { detailed_regions, regions } = apiJson.counts;
    return detailed_regions ? (Object.entries(detailed_regions).forEach(([apiCode, entry]) => {
      let parts = apiCode.split("-"), country = parts[0], stateCode = "";
      if (country === "US" && parts.length > 1) {
        let stateName = parts.slice(1).join("-");
        stateCode = getInternalStateCode(stateName);
      }
      entry.cities ? Object.entries(entry.cities).forEach(([city, count]) => {
        let key = generateRegionKey(country, city, stateCode ? parts.slice(1).join("-") : null);
        out[key] = count;
      }) : typeof entry.total_servers == "number" && (out[apiCode] = entry.total_servers);
    }), out) : (regions && Object.entries(regions).forEach(([apiCode, total]) => {
      let matched = !1;
      Object.values(State2.regions).forEach((continent) => {
        Object.keys(continent).forEach((regionKey) => {
          (regionKey === apiCode || regionKey.startsWith(`${apiCode.split("-")[0]}-`)) && (out[regionKey] === void 0 && (out[regionKey] = total), matched = !0);
        });
      }), matched || (out[apiCode] = total);
    }), out);
  }
  __name(buildServerCountsMap, "buildServerCountsMap");
  function generateRegionKey(country, city, regionName) {
    return country === "US" && regionName ? `US-${getInternalStateCode(regionName)}-${city.replace(/\s+/g, "")}` : `${country}-${city.replace(/\s+/g, "")}`;
  }
  __name(generateRegionKey, "generateRegionKey");
  function processStorageDatacenters(apiData) {
    if (!Array.isArray(apiData)) return;
    let newRegions = {}, newCounts = {}, newIpMap = {};
    apiData.forEach((dc) => {
      if (!dc.location || !dc.location.country || !dc.location.city) return;
      Array.isArray(dc.dataCenterIds) && dc.dataCenterIds.forEach((id) => newIpMap[id] = dc);
      let loc = dc.location, regionKey = generateRegionKey(loc.country, loc.city, loc.region), count = Array.isArray(dc.dataCenterIds) ? dc.dataCenterIds.length : 0;
      newCounts[regionKey] = (newCounts[regionKey] || 0) + count;
      let continent = loc.continent || "Other";
      newRegions[continent] || (newRegions[continent] = {}), newRegions[continent][regionKey] || (newRegions[continent][regionKey] = {
        city: loc.city,
        country: loc.country_name || loc.country,
        coords: {
          lat: parseFloat(loc.latLong[0]),
          lon: parseFloat(loc.latLong[1])
        }
      });
    }), State2.regions = newRegions, State2.dataCenterCounts = newCounts, State2.serverIpMap = newIpMap, document.dispatchEvent(new CustomEvent(EVT_REGIONS_UPDATED));
  }
  __name(processStorageDatacenters, "processStorageDatacenters");
  async function fetchCounts() {
    try {
      let pid = getPlaceIdFromUrl3(), json = await callRobloxApiJson({ endpoint: `/v1/servers/counts?place_id=${encodeURIComponent(pid)}`, isRovalraApi: !0 });
      State2.apiCounts = json, State2.activeServerCounts = buildServerCountsMap(json);
    } catch {
      State2.apiCounts = { counts: {} }, State2.activeServerCounts = {};
    } finally {
      document.dispatchEvent(new CustomEvent(EVT_REGIONS_UPDATED)), document.dispatchEvent(new CustomEvent(EVT_GLOBE_UPDATE_DATA, { detail: { serverCounts: State2.activeServerCounts } }));
    }
  }
  __name(fetchCounts, "fetchCounts");
  async function fetchServers(regionCode, cursor) {
    try {
      let pid = getPlaceIdFromUrl3(), city, country = regionCode.split("-")[0];
      for (let continent of Object.values(State2.regions))
        if (continent[regionCode]) {
          city = continent[regionCode].city;
          break;
        }
      if (!city && State2.apiCounts?.counts?.detailed_regions) {
        let detailed = State2.apiCounts.counts.detailed_regions;
        for (let [apiCode, entry] of Object.entries(detailed)) {
          if (entry.cities) {
            let parts = apiCode.split("-"), ctry = parts[0], stateName = null;
            ctry === "US" && parts.length > 1 && (stateName = parts.slice(1).join("-"));
            for (let cityName of Object.keys(entry.cities))
              if (generateRegionKey(ctry, cityName, stateName) === regionCode) {
                city = cityName;
                break;
              }
          }
          if (city) break;
        }
        if (!city && detailed[regionCode]?.cities) {
          let cities = Object.keys(detailed[regionCode].cities);
          cities.length > 0 && (city = cities[0]);
        }
      }
      let qs;
      return city ? qs = new URLSearchParams({
        place_id: pid,
        country,
        city: city.toLowerCase()
      }) : qs = new URLSearchParams({ place_id: pid, region: regionCode }), cursor && qs.set("cursor", cursor), await callRobloxApiJson({ endpoint: `/v1/servers/region?${qs.toString()}`, isRovalraApi: !0 });
    } catch {
      return { servers: [], next_cursor: null };
    }
  }
  __name(fetchServers, "fetchServers");
  function createGlobePanel(container) {
    let theme = detectTheme3(), assets3 = getAssets(), panel = document.createElement("div");
    panel.id = GLOBE_PANEL_ID, panel.className = theme, panel.innerHTML = `<div class="rovalra-globe-header ${theme}"><img src="${assets3.rovalraIcon}" class="rovalra-header-logo" title="RoValra" id="${EASTER_EGG_TRIGGER_ID}" alt="Logo"><div id="${HEADER_TITLE_ID}" style="font-weight:bold;">RoValra Region Selector</div></div><div id="${GLOBE_CONTAINER_ID}"></div>`, container.appendChild(panel);
    let globeContainer = panel.querySelector(`#${GLOBE_CONTAINER_ID}`);
    globeContainer && globeContainer.addEventListener("mouseleave", () => {
      let tooltip = document.getElementById(GLOBE_TOOLTIP_ID);
      tooltip && (tooltip.style.display = "none");
    });
    let clickCount = 0, logo = panel.querySelector(`#${EASTER_EGG_TRIGGER_ID}`), title = panel.querySelector(`#${HEADER_TITLE_ID}`);
    logo.addEventListener("click", (e) => {
      e.stopPropagation(), clickCount++, clickCount === 10 && (clickCount = 0, State2.easterEggActive = !State2.easterEggActive, State2.easterEggActive ? (document.dispatchEvent(new CustomEvent(EVT_GLOBE_EASTER_EGG, { detail: { iconUrl: assets3.rovalraIcon } })), title && (title.textContent = "Gilberts In Your Area")) : (document.dispatchEvent(new CustomEvent(EVT_GLOBE_EASTER_EGG_OFF)), title && (title.textContent = "RoValra Region Selector")));
    }), setupGlobePointerEvents();
  }
  __name(createGlobePanel, "createGlobePanel");
  function setupGlobePointerEvents() {
    let container = document.getElementById(GLOBE_CONTAINER_ID);
    if (!container) return;
    let onMove = /* @__PURE__ */ __name((e) => {
      State2.globe.pointerDown && !State2.globe.pointerDragged && (Math.abs(e.clientX - State2.globe.startX) > GLOBE_DRAG_THRESHOLD || Math.abs(e.clientY - State2.globe.startY) > GLOBE_DRAG_THRESHOLD) && (State2.globe.pointerDragged = !0);
    }, "onMove"), onUp = /* @__PURE__ */ __name((e) => {
      State2.globe.pointerDragged && (State2.globe.lastDragTime = Date.now()), State2.globe.pointerDown = !1, State2.globe.pointerDragged = !1;
      try {
        container.releasePointerCapture(e.pointerId);
      } catch {
      }
      document.removeEventListener("pointermove", onMove), document.removeEventListener("pointerup", onUp);
    }, "onUp");
    container.addEventListener("pointerdown", (e) => {
      try {
        container.setPointerCapture(e.pointerId);
      } catch {
      }
      State2.globe.pointerDown = !0, State2.globe.pointerDragged = !1, State2.globe.startX = e.clientX, State2.globe.startY = e.clientY, document.addEventListener("pointermove", onMove), document.addEventListener("pointerup", onUp);
    }), container.addEventListener("click", (e) => e.stopPropagation());
  }
  __name(setupGlobePointerEvents, "setupGlobePointerEvents");
  async function preloadGlobeResources() {
    if (State2.globe.resourcesPreloaded) return;
    State2.globe.resourcesPreloaded = !0;
    let assets3 = getAssets();
    !State2.globe.scriptPromise && !State2.globe.assetsLoaded && (State2.globe.scriptPromise = injectScript(assets3.globeInitializer).then(() => {
      State2.globe.assetsLoaded = !0;
    }).catch(() => {
    }));
  }
  __name(preloadGlobeResources, "preloadGlobeResources");
  async function ensureGlobeInitialized(theme) {
    if (State2.globe.initDispatched) return;
    preloadGlobeResources();
    let assets3 = getAssets();
    if (State2.globe.scriptPromise) await State2.globe.scriptPromise;
    else if (!State2.globe.assetsLoaded)
      try {
        await injectScript(assets3.globeInitializer), State2.globe.assetsLoaded = !0;
      } catch {
        return;
      }
    let mapUrl = theme === "dark" ? assets3.mapDark : assets3.mapLight;
    State2.activeServerCounts = buildServerCountsMap(State2.apiCounts || {}), document.dispatchEvent(new CustomEvent(EVT_INIT_GLOBE, { detail: { REGIONS: State2.regions, mapUrl, countriesData: null, theme, serverCounts: State2.activeServerCounts, dataCenterCounts: State2.dataCenterCounts } })), State2.globe.initDispatched = !0;
  }
  __name(ensureGlobeInitialized, "ensureGlobeInitialized");
  function populateRegionSidePanel(container, theme) {
    container.innerHTML = "";
    let useApi = State2.apiCounts?.counts?.detailed_regions, groups = {};
    if (useApi) {
      let detailed = State2.apiCounts.counts.detailed_regions;
      for (let [code, entry] of Object.entries(detailed)) {
        let parts = code.split("-"), groupName = parts[0], subLabel = code, stateName = null;
        if (groupName === "US" && parts.length > 1) {
          let rawState = parts.slice(1).join(" ");
          stateName = parts.slice(1).join("-"), subLabel = rawState.toLowerCase().replace(/\b\w/g, (s) => s.toUpperCase());
        }
        if (groups[groupName] || (groups[groupName] = []), entry.cities)
          for (let [cityName, count] of Object.entries(entry.cities)) {
            let regionKey = generateRegionKey(groupName, cityName, stateName);
            groups[groupName].push({ code: regionKey, label: cityName, subLabel, count });
          }
        else
          groups[groupName].push({ code, label: code, subLabel, count: entry.total_servers || 0 });
      }
    } else
      for (let [continent, regions] of Object.entries(State2.regions)) {
        groups[continent] || (groups[continent] = []);
        for (let [key, data] of Object.entries(regions))
          groups[continent].push({ code: key, label: data.city, subLabel: data.country, count: State2.dataCenterCounts[key] || 0 });
      }
    for (let [groupName, items] of Object.entries(groups)) {
      if (items.length === 0) continue;
      let header = document.createElement("div");
      header.className = `rovalra-filter-group-header ${theme}`, header.textContent = groupName, container.appendChild(header), items.forEach((item) => {
        let row = document.createElement("a");
        row.className = `rovalra-side-panel-item ${theme}`, row.dataset.regionCode = item.code, row.innerHTML = purify.sanitize(`<div><strong>${item.label}</strong><span class="country"> ${item.subLabel}</span></div><div class="rovalra-region-count ${theme}">${item.count}</div>`), addTooltip(row, `Filter by ${item.label} (${item.count} servers)`, { position: "left" }), row.addEventListener("click", (e) => {
          e.stopPropagation(), document.dispatchEvent(new CustomEvent(EVT_REGION_SELECTED, { detail: { regionCode: item.code } }));
        }), container.appendChild(row);
      });
    }
  }
  __name(populateRegionSidePanel, "populateRegionSidePanel");
  function createRegionDropdownWidget(container) {
    let theme = detectTheme3(), wrapper = document.createElement("div");
    wrapper.id = "rovalra-region-filter-dropdown-wrapper", wrapper.className = "filter-dropdown-container rovalra-filter-widget";
    let btn = createButton("Region", "secondary");
    btn.classList.add("filter-button-alignment"), btn.innerHTML = '<span>Region</span><svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M19.3 16.9c.4-.7.7-1.5.7-2.4 0-2.5-2-4.5-4.5-4.5S11 12 11 14.5s2 4.5 4.5 4.5c.9 0 1.7-.3 2.4-.7l3.2 3.2 1.4-1.4zm-3.8.1c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5M12 20v2C6.48 22 2 17.52 2 12S6.48 2 12 2c4.84 0 8.87 3.44 9.8 8h-2.07c-.64-2.46-2.4-4.47-4.73-5.41V5c0 1.1-.9 2-2 2h-2v2c0 .55-.45 1-1 1H8v2h2v3H9l-4.79-4.79C4.08 10.79 4 11.38 4 12c0 4.41 3.59 8 8 8"></path></svg>', addTooltip(btn, "Filter servers by region", { position: "top" }), wrapper.appendChild(btn);
    let sidePanel = document.createElement("div");
    sidePanel.className = `rovalra-side-panel ${theme}`, sidePanel.innerHTML = `<div class="rovalra-side-panel-list ${theme}"></div>`;
    let listContainer = sidePanel.querySelector(".rovalra-side-panel-list");
    createGlobePanel(wrapper), wrapper.appendChild(sidePanel);
    let onButtonClick = /* @__PURE__ */ __name((e) => {
      e.stopPropagation();
      let globe = document.getElementById(GLOBE_PANEL_ID);
      btn.classList.contains("active") ? closeGlobalPanels() : (closeGlobalPanels(), btn.classList.add("active"), startIndependentServerScan(), State2.isGlobeOpen = !0, globe && globe.classList.add("show"), ensureGlobeInitialized(theme).catch(() => {
      }));
    }, "onButtonClick");
    btn.addEventListener("mouseenter", () => preloadGlobeResources()), setTimeout(() => preloadGlobeResources(), 2e3), btn.addEventListener("click", onButtonClick);
    let updateList = /* @__PURE__ */ __name(() => populateRegionSidePanel(listContainer, theme), "updateList");
    document.addEventListener(EVT_REGIONS_UPDATED, updateList), updateList(), window.addEventListener("click", (ev) => {
      !wrapper.contains(ev.target) && Date.now() - State2.globe.lastDragTime > 500 && closeGlobalPanels();
    }), container.appendChild(wrapper);
  }
  __name(createRegionDropdownWidget, "createRegionDropdownWidget");
  async function getAndCacheServerRegion(server, placeId) {
    if (!document.querySelector(`[data-gameid="${server.id}"]`)?.dataset.rovalraRegion)
      try {
        let res = await callRobloxApiJson({
          subdomain: "gamejoin",
          endpoint: "/v1/join-game-instance",
          method: "POST",
          body: { placeId: parseInt(placeId, 10), gameId: server.id, gameJoinAttemptId: crypto.randomUUID() }
        });
        if (!res.joinScript?.DataCenterId) return;
        let dataCenterId = res.joinScript.DataCenterId, dcInfo = State2.serverIpMap[dataCenterId];
        if (dcInfo?.location) {
          let loc = dcInfo.location, regionKey = generateRegionKey(loc.country, loc.city, loc.region);
          if (State2.localServersByRegion[regionKey] || (State2.localServersByRegion[regionKey] = []), !State2.localServersByRegion[regionKey].some((s) => s.id === server.id)) {
            State2.localServersByRegion[regionKey].push(server);
            let currentGlobalCount = State2.activeServerCounts[regionKey] || 0, localCount = State2.localServersByRegion[regionKey].length;
            localCount > currentGlobalCount && (State2.activeServerCounts[regionKey] = localCount, document.dispatchEvent(new CustomEvent(EVT_GLOBE_UPDATE_DATA, { detail: { serverCounts: State2.activeServerCounts } })));
          }
        }
      } catch {
      }
  }
  __name(getAndCacheServerRegion, "getAndCacheServerRegion");
  async function startIndependentServerScan() {
    if (State2.isScanning || State2.scanCompleted) return;
    State2.isScanning = !0, State2.scanCursor === null && (State2.localServersByRegion = {}, State2.allLocalServerIds.clear());
    let placeId = getPlaceIdFromUrl3(), pageCount = 0;
    for (; pageCount++ < 1 / 0 && State2.isScanning; )
      try {
        let response = await callRobloxApiJson({ subdomain: "games", endpoint: `/v1/games/${placeId}/servers/Public?excludeFullGames=true&limit=100${State2.scanCursor ? `&cursor=${encodeURIComponent(State2.scanCursor)}` : ""}` }), serversOnPage = response.data || [];
        if (serversOnPage.length > 0)
          for (let i = 0; i < serversOnPage.length && State2.isScanning; i += 10) {
            let batch = serversOnPage.slice(i, i + 10);
            await Promise.all(batch.map((s) => getAndCacheServerRegion(s, placeId))), i + 10 < serversOnPage.length && await new Promise((resolve) => setTimeout(resolve, 100));
          }
        if (!response.nextPageCursor) {
          State2.scanCompleted = !0, State2.scanCursor = null;
          break;
        }
        State2.scanCursor = response.nextPageCursor;
      } catch {
        break;
      }
    for (let region in State2.localServersByRegion)
      for (let server of State2.localServersByRegion[region])
        State2.allLocalServerIds.add(server.id);
    State2.isScanning = !1;
  }
  __name(startIndependentServerScan, "startIndependentServerScan");
  function handleGlobeHover(e) {
    let tooltip = document.getElementById(GLOBE_TOOLTIP_ID);
    if (!tooltip) return;
    let panel = document.getElementById(GLOBE_PANEL_ID);
    if (!panel || !panel.classList.contains("show") || !e.detail?.active || !e.detail.regionCode) {
      tooltip.style.display = "none";
      return;
    }
    let { regionCode, city, x: x2, y: y2 } = e.detail, countryCode = regionCode.split("-")[0].toLowerCase(), serverCount = State2.activeServerCounts[regionCode] || 0, dcCount = State2.dataCenterCounts[regionCode] || 0, flagSrc = State2.flags[countryCode];
    flagSrc || (flagSrc = `https://flagcdn.com/w40/${countryCode}.png`, cacheFlag(countryCode)), tooltip.innerHTML = `<div style="display: flex; align-items: center; justify-content: center; gap: 6px; margin-bottom: 2px;"><img src="${flagSrc}" style="width: 20px; height: 13px; border-radius: 2px;"><span style="font-weight: 600; font-size: 12px; color: #eee;">${city}</span></div><div style="display: flex; flex-direction: column; align-items: center; gap: 0px; font-size: 11px; color: #ccc; border-top: 1px solid rgba(255,255,255,0.15); padding-top: 3px; width: 100%;"><span>Servers: <b style="color:#fff;">${serverCount.toLocaleString()}</b></span>${dcCount > 0 ? `<span>Datacenters: <b style="color:#fff;">${dcCount.toLocaleString()}</b></span>` : ""}</div>`, tooltip.style.left = `${x2}px`, tooltip.style.top = `${y2}px`, tooltip.style.display = "flex";
  }
  __name(handleGlobeHover, "handleGlobeHover");
  function onOtherFilterSelected() {
    closeGlobalPanels();
  }
  __name(onOtherFilterSelected, "onOtherFilterSelected");
  async function onRegionSelected(event) {
    let code = event.detail?.regionCode;
    if (!code) return;
    showReviewPopup("region_filters"), closeGlobalPanels(), delete State2.regionServersCache[code];
    let apiRegion = resolveApiRegionCode(code), item = document.querySelector(`.rovalra-side-panel-item[data-region-code="${code}"]`);
    item && item.classList.add("loading");
    try {
      let res = await fetchServers(apiRegion), apiServers = res.servers || [], locallyFoundServers = State2.localServersByRegion[code] || [], localServerIds = new Set(locallyFoundServers.map((s) => s.id)), filteredApiServers = apiServers.filter((apiServer) => !localServerIds.has(apiServer.server_id)), combinedServers = [...locallyFoundServers, ...filteredApiServers], initialDisplayServers = combinedServers.slice(0, 8), remainingServers = combinedServers.slice(8);
      State2.regionServersCache[code] = {
        allServers: combinedServers,
        apiNextCursor: res.next_cursor
      }, document.dispatchEvent(new CustomEvent(EVT_REGION_SERVERS_LOADED, {
        detail: {
          regionCode: code,
          servers: initialDisplayServers,
          next_cursor: remainingServers.length > 0 || res.next_cursor ? "HAS_MORE" : null
        }
      }));
    } catch {
      let locallyFoundServers = State2.localServersByRegion[code] || [];
      document.dispatchEvent(new CustomEvent(EVT_REGION_SERVERS_LOADED, {
        detail: {
          regionCode: code,
          servers: locallyFoundServers,
          next_cursor: null
        }
      }));
    } finally {
      item && item.classList.remove("loading");
    }
  }
  __name(onRegionSelected, "onRegionSelected");
  async function onRequestMoreRegionServers(event) {
    let { regionCode } = event.detail || {};
    if (!regionCode || regionCode === "newest" || regionCode === "oldest") return;
    let apiRegion = resolveApiRegionCode(regionCode), item = document.querySelector(`.rovalra-side-panel-item[data-region-code="${regionCode}"]`);
    item && item.classList.add("loading");
    try {
      let cachedData = State2.regionServersCache[regionCode], serverListContainer = document.querySelector("#rbx-public-game-server-item-container"), currentlyDisplayedCount = serverListContainer ? serverListContainer.children.length : 0;
      if (cachedData && currentlyDisplayedCount < cachedData.allServers.length) {
        let nextServers = cachedData.allServers.slice(currentlyDisplayedCount, currentlyDisplayedCount + 8), hasMoreAfterThis = currentlyDisplayedCount + 8 < cachedData.allServers.length || !!cachedData.apiNextCursor;
        document.dispatchEvent(new CustomEvent(EVT_REGION_SERVERS_LOADED, { detail: { regionCode, servers: nextServers, next_cursor: hasMoreAfterThis ? "HAS_MORE" : null, append: !0 } }));
      } else if (cachedData && cachedData.apiNextCursor) {
        let res = await fetchServers(apiRegion, cachedData.apiNextCursor), filteredApiServers = (res.servers || []).filter((apiServer) => !State2.allLocalServerIds.has(apiServer.server_id));
        cachedData.allServers.push(...filteredApiServers), cachedData.apiNextCursor = res.next_cursor, document.dispatchEvent(new CustomEvent(EVT_REGION_SERVERS_LOADED, { detail: { regionCode, servers: filteredApiServers, next_cursor: res.next_cursor, append: !0 } }));
      }
    } catch {
      document.dispatchEvent(new CustomEvent(EVT_REGION_SERVERS_LOADED, { detail: { regionCode, servers: [], next_cursor: null, append: !0 } }));
    } finally {
      item && item.classList.remove("loading");
    }
  }
  __name(onRequestMoreRegionServers, "onRequestMoreRegionServers");
  function attachGlobalListeners() {
    State2.listenersAttached || (document.addEventListener(EVT_UPTIME_SELECTED, onOtherFilterSelected), document.addEventListener(EVT_CLEAR_FILTERS, onOtherFilterSelected), document.addEventListener(EVT_REGION_SELECTED, onRegionSelected), document.addEventListener(EVT_REQUEST_REGION_SERVERS, onRequestMoreRegionServers), State2.listenersAttached = !0);
  }
  __name(attachGlobalListeners, "attachGlobalListeners");
  function onStorageChanged(changes, area) {
    area === "local" && changes.rovalraDatacenters && processStorageDatacenters(changes.rovalraDatacenters.newValue);
  }
  __name(onStorageChanged, "onStorageChanged");
  async function initializeData2() {
    let { rovalraDatacenters } = await chrome.storage.local.get("rovalraDatacenters");
    processStorageDatacenters(rovalraDatacenters), await fetchCounts(), !State2.storageListenerAttached && chrome.storage.onChanged && (chrome.storage.onChanged.addListener(onStorageChanged), State2.storageListenerAttached = !0);
  }
  __name(initializeData2, "initializeData");
  function setupUI() {
    if (!document.getElementById(GLOBE_TOOLTIP_ID)) {
      let tooltip = document.createElement("div");
      tooltip.id = GLOBE_TOOLTIP_ID, document.body.appendChild(tooltip), document.addEventListener(EVT_GLOBE_HOVER, handleGlobeHover);
    }
    let mainControls = document.getElementById("rovalra-main-controls");
    mainControls && !mainControls.querySelector("#rovalra-region-filter-dropdown-wrapper") && createRegionDropdownWidget(mainControls);
  }
  __name(setupUI, "setupUI");
  async function initRegionFilters() {
    if (!State2.injected) {
      State2.injected = !0;
      try {
        startObserving();
      } catch (e) {
        console.error("RoValra: Failed to start observing.", e);
      }
      setupUI(), attachGlobalListeners(), await initializeData2();
    }
  }
  __name(initRegionFilters, "initRegionFilters");

  // src/content/core/games/servers/filters/uptimefilters.js
  var isInitialized2 = !1, currentDropdownInstance = null, currentCursor = null, LABELS = {
    newest: "Newest Servers",
    oldest: "Oldest Servers"
  };
  function getPlaceIdFromUrl4() {
    try {
      let match = window.location.href.match(/\/games\/(\d+)/);
      return match ? match[1] : null;
    } catch {
      return null;
    }
  }
  __name(getPlaceIdFromUrl4, "getPlaceIdFromUrl");
  async function fetchUptimeServers(value, cursor = null) {
    let placeId = getPlaceIdFromUrl4();
    if (!placeId)
      return console.error("RoValra UptimeFilters: Could not determine Place ID."), null;
    let limit = 10, endpoint = value === "oldest" ? `/v1/servers/oldest?place_id=${placeId}&limit=${limit}` : `/v1/servers/newest?place_id=${placeId}&limit=${limit}`;
    cursor && (endpoint += `&cursor=${encodeURIComponent(cursor)}`);
    try {
      return await callRobloxApiJson({
        endpoint,
        isRovalraApi: !0
      });
    } catch (error) {
      return console.error(`RoValra UptimeFilters: Failed to fetch ${value} servers.`, error), null;
    }
  }
  __name(fetchUptimeServers, "fetchUptimeServers");
  async function onFilterChange(value) {
    if (!value) return;
    if (currentCursor = null, currentDropdownInstance && LABELS[value]) {
      let trigger = currentDropdownInstance.element.querySelector(".rovalra-dropdown-trigger .content-emphasis");
      trigger && (trigger.textContent = LABELS[value]);
    }
    if (document.dispatchEvent(new CustomEvent("rovalraUptimeSelected")), !document.body.classList.contains("rovalra-filter-active")) {
      document.body.classList.add("rovalra-filter-active");
      let clearButton = document.getElementById("rovalra-clear-filter-btn");
      clearButton && (clearButton.style.display = "flex");
    }
    let response = await fetchUptimeServers(value, null), servers = response?.servers || [];
    currentCursor = response?.next_cursor || null, document.dispatchEvent(new CustomEvent("rovalraRegionServersLoaded", {
      detail: {
        regionCode: value,
        servers,
        next_cursor: currentCursor
      }
    }));
  }
  __name(onFilterChange, "onFilterChange");
  function createUptimeDropdown(container) {
    let dropdown = createDropdown({
      items: [
        { value: "newest", label: "Newest Servers" },
        { value: "oldest", label: "Oldest Servers" }
      ],
      initialValue: null,
      onValueChange: onFilterChange,
      showFlags: !1
    });
    dropdown.element.classList.add("rovalra-uptime-dropdown-container", "rovalra-filter-widget"), dropdown.element.style.minWidth = "160px";
    let trigger = dropdown.element.querySelector(".rovalra-dropdown-trigger .content-emphasis");
    trigger && (trigger.textContent = "Server Uptime");
    let triggerBtn = dropdown.trigger || dropdown.element.querySelector(".rovalra-dropdown-trigger");
    triggerBtn && addTooltip(triggerBtn, "Filter servers by uptime (newest/oldest)", { position: "top" }), container.prepend(dropdown.element), currentDropdownInstance = dropdown;
  }
  __name(createUptimeDropdown, "createUptimeDropdown");
  function initUptimeFilters() {
    if (isInitialized2) return;
    isInitialized2 = !0, document.addEventListener("rovalraRequestRegionServers", async (ev) => {
      let { regionCode } = ev.detail || {};
      if (regionCode !== "newest" && regionCode !== "oldest") return;
      if (!currentCursor) {
        document.dispatchEvent(new CustomEvent("rovalraRegionServersLoaded", {
          detail: { regionCode, servers: [], next_cursor: null, append: !0 }
        }));
        return;
      }
      let response = await fetchUptimeServers(regionCode, currentCursor), servers = response?.servers || [];
      currentCursor = response?.next_cursor || null, document.dispatchEvent(new CustomEvent("rovalraRegionServersLoaded", {
        detail: {
          regionCode,
          servers,
          next_cursor: currentCursor,
          append: !0
        }
      }));
    }), document.addEventListener("rovalraRegionSelected", () => {
      if (currentDropdownInstance) {
        currentDropdownInstance.setValue && currentDropdownInstance.setValue(null, !0), currentCursor = null;
        let trigger = currentDropdownInstance.element.querySelector(".rovalra-dropdown-trigger .content-emphasis");
        trigger && (trigger.textContent = "Server Uptime");
      }
    }), document.addEventListener("rovalraClearFilters", () => {
      if (currentDropdownInstance) {
        currentDropdownInstance.setValue && currentDropdownInstance.setValue(null, !0), currentCursor = null;
        let trigger = currentDropdownInstance.element.querySelector(".rovalra-dropdown-trigger .content-emphasis");
        trigger && (trigger.textContent = "Server Uptime");
      }
    });
    let container = document.getElementById("rovalra-main-controls");
    container && !container.querySelector(".rovalra-uptime-dropdown-container") && createUptimeDropdown(container);
  }
  __name(initUptimeFilters, "initUptimeFilters");

  // src/content/core/games/servers/filters/versionfilters.js
  var isInitialized3 = !1, currentCursor2 = null, currentDropdownInstance2 = null, inputInstance = null, STYLES = `
    .rovalra-version-list {
        flex: 1;
        overflow-y: auto;
        min-height: 0; 
        
        display: flex;
        flex-direction: column;
        gap: 2px;
        margin-top: 8px;
        padding-top: 4px;
        padding-right: 4px; 
        border-top: 1px solid var(--divider-color);
        
        max-height: 250px; 
    }

    .rovalra-version-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        color: var(--text-default); 
        transition: background-color 0.1s;
        flex-shrink: 0; 
    }

    .rovalra-version-item:hover {
        background-color: var(--color-state-hover);
    }

    .rovalra-version-item:active {
        background-color: var(--color-state-press);
    }
    
    .rovalra-version-item span {
        font-weight: 600;
    }
`;
  function getPlaceIdFromUrl5() {
    try {
      let match = window.location.href.match(/\/games\/(\d+)/);
      return match ? match[1] : null;
    } catch {
      return null;
    }
  }
  __name(getPlaceIdFromUrl5, "getPlaceIdFromUrl");
  async function fetchVersionCounts() {
    try {
      let placeId = getPlaceIdFromUrl5();
      return placeId ? (await callRobloxApiJson({
        endpoint: `/v1/servers/counts?place_id=${placeId}`,
        isRovalraApi: !0
      }))?.counts?.place_versions || [] : [];
    } catch (e) {
      return console.warn("RoValra: Failed to fetch version counts", e), [];
    }
  }
  __name(fetchVersionCounts, "fetchVersionCounts");
  async function fetchServersForVersion(version, cursor = null) {
    let placeId = getPlaceIdFromUrl5();
    if (!placeId) return null;
    let endpoint = `/v1/servers/versions?place_id=${placeId}&place_version=${version}&limit=10`;
    cursor && (endpoint += `&cursor=${encodeURIComponent(cursor)}`);
    try {
      return await callRobloxApiJson({
        endpoint,
        isRovalraApi: !0
      });
    } catch (error) {
      return console.error(`RoValra: Failed to fetch version ${version}.`, error), null;
    }
  }
  __name(fetchServersForVersion, "fetchServersForVersion");
  function closeDropdown() {
    currentDropdownInstance2 && currentDropdownInstance2.panel && (currentDropdownInstance2.panel.classList.remove("show"), currentDropdownInstance2.trigger.setAttribute("data-state", "closed"), currentDropdownInstance2.panel.setAttribute("data-state", "closed"));
  }
  __name(closeDropdown, "closeDropdown");
  async function executeSearch(version) {
    if (!version) return;
    if (closeDropdown(), currentCursor2 = null, currentDropdownInstance2) {
      let span = currentDropdownInstance2.trigger.querySelector(".content-emphasis");
      span && (span.textContent = `v${version}`), currentDropdownInstance2.trigger.removeAttribute("data-placeholder");
    }
    if (document.dispatchEvent(new CustomEvent("rovalraVersionSelected", { detail: { version } })), !document.body.classList.contains("rovalra-filter-active")) {
      document.body.classList.add("rovalra-filter-active");
      let clearButton = document.getElementById("rovalra-clear-filter-btn");
      clearButton && (clearButton.style.display = "flex");
    }
    let response = await fetchServersForVersion(version, null), servers = response?.servers || [];
    currentCursor2 = response?.next_cursor || null, document.dispatchEvent(new CustomEvent("rovalraRegionServersLoaded", {
      detail: {
        regionCode: `version-${version}`,
        servers,
        next_cursor: currentCursor2
      }
    }));
  }
  __name(executeSearch, "executeSearch");
  function resetFilter() {
    if (currentCursor2 = null, inputInstance && (inputInstance.input.value = "", inputInstance.input.dispatchEvent(new Event("input"))), currentDropdownInstance2) {
      let span = currentDropdownInstance2.trigger.querySelector(".content-emphasis");
      span && (span.textContent = "Version"), currentDropdownInstance2.trigger.setAttribute("data-placeholder", "true");
    }
  }
  __name(resetFilter, "resetFilter");
  async function createVersionWidget(container) {
    if (!document.getElementById("rovalra-version-filter-styles")) {
      let s = document.createElement("style");
      s.id = "rovalra-version-filter-styles", s.textContent = STYLES, document.head.appendChild(s);
    }
    let dropdown = createDropdown({
      items: [],
      initialValue: null,
      placeholder: "Version",
      onValueChange: /* @__PURE__ */ __name(() => {
      }, "onValueChange"),
      showFlags: !1
    });
    if (dropdown.trigger && addTooltip(dropdown.trigger, "Filter servers by game version", { position: "top" }), dropdown.element.classList.add("rovalra-version-filter-widget", "rovalra-filter-widget"), dropdown.element.style.minWidth = "130px", dropdown.panel) {
      dropdown.panel.style.display = "flex", dropdown.panel.style.flexDirection = "column", dropdown.panel.style.overflow = "hidden", inputInstance = createStyledInput({
        id: "rovalra-version-search",
        label: "Enter Version",
        placeholder: " "
      }), inputInstance.container.style.width = "100%", inputInstance.container.style.flexShrink = "0", inputInstance.input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          let val = inputInstance.input.value.trim();
          val && executeSearch(val);
        }
      }), dropdown.panel.appendChild(inputInstance.container);
      let versions = await fetchVersionCounts();
      if (versions.length > 0) {
        versions.sort((a, b2) => Number(b2) - Number(a));
        let listContainer = document.createElement("div");
        listContainer.className = "rovalra-version-list", versions.forEach((v2) => {
          let item = document.createElement("div");
          item.className = "rovalra-version-item", item.innerHTML = purify.sanitize(`<span>${v2}</span>`), item.addEventListener("click", (e) => {
            e.stopPropagation(), inputInstance.input.value = v2, inputInstance.input.dispatchEvent(new Event("input")), executeSearch(v2);
          }), listContainer.appendChild(item);
        }), dropdown.panel.appendChild(listContainer);
      }
    }
    container.prepend(dropdown.element), currentDropdownInstance2 = dropdown;
  }
  __name(createVersionWidget, "createVersionWidget");
  function initVersionFilters() {
    if (isInitialized3) return;
    isInitialized3 = !0, document.addEventListener("rovalraRequestRegionServers", async (ev) => {
      let { regionCode } = ev.detail || {};
      if (!regionCode || !regionCode.startsWith("version-")) return;
      let version = regionCode.replace("version-", "");
      if (!currentCursor2) {
        document.dispatchEvent(new CustomEvent("rovalraRegionServersLoaded", {
          detail: { regionCode, servers: [], next_cursor: null, append: !0 }
        }));
        return;
      }
      let response = await fetchServersForVersion(version, currentCursor2), servers = response?.servers || [];
      currentCursor2 = response?.next_cursor || null, document.dispatchEvent(new CustomEvent("rovalraRegionServersLoaded", {
        detail: { regionCode, servers, next_cursor: currentCursor2, append: !0 }
      }));
    });
    let resetHandler = /* @__PURE__ */ __name(() => {
      closeDropdown(), resetFilter();
    }, "resetHandler");
    document.addEventListener("rovalraRegionSelected", resetHandler), document.addEventListener("rovalraUptimeSelected", resetHandler), document.addEventListener("rovalraClearFilters", resetHandler), observeElement("#rovalra-main-controls", (container) => {
      container.querySelector(".rovalra-version-filter-widget") || createVersionWidget(container);
    }, { multiple: !1 });
  }
  __name(initVersionFilters, "initVersionFilters");

  // src/content/core/games/servers/serverdetails.js
  var CLASSES = {
    CONTAINER: "rovalra-details-container",
    INFO_ROW: "text-info",
    Region: "rovalra-region-info",
    Uptime: "rovalra-uptime-info",
    Performance: "rovalra-performance-info",
    Version: "rovalra-version-info",
    Full: "rovalra-server-full-info",
    Private: "rovalra-private-server-info",
    Purchase: "rovalra-purchase-game-info",
    Inactive: "rovalra-inactive-place-info"
  }, ORDERS = {
    Performance: 1,
    Uptime: 2,
    Version: 3,
    Region: 4,
    Purchase: 5,
    Status: 6
  }, STYLES2 = {
    container: "display: flex; flex-direction: column; align-items: flex-start; gap: 2px; margin-top: 4px; min-height: 88px;",
    containerFriends: "display: flex; flex-direction: column; align-items: flex-start; gap: 4px; margin-bottom: 8px; width: 100%; min-height: 88px;",
    row: "display: flex; align-items: center; gap: 6px; font-size: 14px; font-weight: 400;",
    icon: "display: flex; align-items: center; flex-shrink: 0; height: 20px;",
    text: "line-height: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: 0; max-width: 100%; flex: 1;"
  }, ICONS = {
    performanceHigh: '<svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="m16 6 2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke="currentColor" fill="currentColor" stroke-width="0.01"/></svg>',
    performanceLow: '<svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="m16 18 2.29-2.29-4.88-4.88-4 4L2 7.41 3.41 6l6 6 4-4 6.3 6.29L22 12v6z" stroke="currentColor" fill="currentColor" stroke-width="0.01"/></svg>',
    uptime: '<svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="m22 5.7-4.6-3.9-1.3 1.5 4.6 3.9zM7.9 3.4 6.6 1.9 2 5.7l1.3 1.5zM12.5 8H11v6l4.7 2.9.8-1.2-4-2.4zM12 4c-5 0-9 4-9 9s4 9 9 9 9-4 9-9-4-9-9-9m0 16c-3.9 0-7-3.1-7-7s3.1-7 7-7 7 3.1 7 7-3.1 7-7 7" fill="currentColor"/></svg>',
    version: '<svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M21 10.12h-6.78l2.74-2.82c-2.73-2.7-7.15-2.8-9.88-.1-2.73 2.71-2.73 7.08 0 9.79s7.15 2.71 9.88 0C18.32 15.65 19 14.08 19 12.1h2c0 1.98-.88 4.55-2.64 6.29-3.51 3.48-9.21 3.48-12.72 0-3.5-3.47-3.53-9.11-.02-12.58s9.14-3.47 12.65 0L21 3zM12.5 8v4.25l3.5 2.08-.72 1.21L11 13V8z" stroke="currentColor" fill="currentColor" stroke-width="0.01"/></svg>',
    regionDefault: '<svg width="20" height="20" viewBox="0 0 24 24"><path d="M11 8.17 6.49 3.66C8.07 2.61 9.96 2 12 2c5.52 0 10 4.48 10 10 0 2.04-.61 3.93-1.66 5.51l-1.46-1.46C19.59 14.87 20 13.48 20 12c0-3.35-2.07-6.22-5-7.41V5c0 1.1-.9 2-2 2h-2zm10.19 13.02-1.41 1.41-2.27-2.27C15.93 21.39 14.04 22 12 22 6.48 22 2 17.52 2 12c0-2.04.61-3.93 1.66-5.51L1.39 4.22 2.8 2.81zM11 18c-1.1 0-2-.9-2-2v-1l-4.79-4.79C4.08 10.79 4 11.38 4 12c0 4.08 3.05 7.44 7 7.93z" stroke="currentColor" fill="currentColor" stroke-width="0.01"/></svg>',
    full: '<svg width="20" height="20" viewBox="0 0 24 24"><path d="M11 8.17 6.49 3.66C8.07 2.61 9.96 2 12 2c5.52 0 10 4.48 10 10 0 2.04-.61 3.93-1.66 5.51l-1.46-1.46C19.59 14.87 20 13.48 20 12c0-3.35-2.07-6.22-5-7.41V5c0 1.1-.9 2-2 2h-2zm10.19 13.02-1.41 1.41-2.27-2.27C15.93 21.39 14.04 22 12 22 6.48 22 2 17.52 2 12c0-2.04.61-3.93 1.66-5.51L1.39 4.22 2.8 2.81zM11 18c-1.1 0-2-.9-2-2v-1l-4.79-4.79C4.08 10.79 4 11.38 4 12c0 4.08 3.05 7.44 7 7.93z" stroke="currentColor" fill="currentColor" stroke-width="0.01"/></svg>',
    private: '<svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2m-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2m3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1z" stroke="currentColor" fill="currentColor" stroke-width="0.01"/></svg>',
    purchase: '<svg width="20" height="20" viewBox="0 0 24 24"><path d="M11 8.17 6.49 3.66C8.07 2.61 9.96 2 12 2c5.52 0 10 4.48 10 10 0 2.04-.61 3.93-1.66 5.51l-1.46-1.46C19.59 14.87 20 13.48 20 12c0-3.35-2.07-6.22-5-7.41V5c0 1.1-.9 2-2 2h-2zm10.19 13.02-1.41 1.41-2.27-2.27C15.93 21.39 14.04 22 12 22 6.48 22 2 17.52 2 12c0-2.04.61-3.93 1.66-5.51L1.39 4.22 2.8 2.81zM11 18c-1.1 0-2-.9-2-2v-1l-4.79-4.79C4.08 10.79 4 11.38 4 12c0 4.08 3.05 7.44 7 7.93z" stroke="currentColor" fill="currentColor" stroke-width="0.01"/></svg>',
    inactive: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V12M12 16H12.01M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z"/> stroke="currentColor" fill="currentColor" stroke-width="0.01"/></svg>'
  }, rovalraDatacentersCache = null, isShareLinkEnabled = !0, isServerUptimeEnabled = !0, isServerRegionEnabled = !0, isPlaceVersionEnabled = !0, isFullServerIDEnabled = !0, isFullServerIndicatorsEnabled = !0, isServerPerformanceEnabled = !0, isMiscIndicatorsEnabled = !0, isDatacenterAndIdEnabled = !0, isServerListModificationsEnabled = !0, serverVersionsCache = {}, cacheReadyPromise = new Promise((resolve) => {
    if (typeof chrome > "u" || !chrome.storage?.local) return resolve();
    chrome.storage.local.get([
      "rovalraDatacenters",
      "ServerlistmodificationsEnabled",
      "enableShareLink",
      "EnableServerUptime",
      "EnableServerRegion",
      "EnablePlaceVersion",
      "EnableFullServerID",
      "EnableFullServerIndicators",
      "EnableServerPerformance",
      "EnableMiscIndicators",
      "EnableDatacenterandId"
    ], (res) => {
      res?.rovalraDatacenters && (rovalraDatacentersCache = res.rovalraDatacenters), res?.ServerlistmodificationsEnabled !== void 0 && (isServerListModificationsEnabled = res.ServerlistmodificationsEnabled), res?.enableShareLink !== void 0 && (isShareLinkEnabled = res.enableShareLink), res?.EnableServerUptime !== void 0 && (isServerUptimeEnabled = res.EnableServerUptime), res?.EnableServerRegion !== void 0 && (isServerRegionEnabled = res.EnableServerRegion), res?.EnablePlaceVersion !== void 0 && (isPlaceVersionEnabled = res.EnablePlaceVersion), res?.EnableFullServerID !== void 0 && (isFullServerIDEnabled = res.EnableFullServerID), res?.EnableFullServerIndicators !== void 0 && (isFullServerIndicatorsEnabled = res.EnableFullServerIndicators), res?.EnableServerPerformance !== void 0 && (isServerPerformanceEnabled = res.EnableServerPerformance), res?.EnableMiscIndicators !== void 0 && (isMiscIndicatorsEnabled = res.EnableMiscIndicators), res?.EnableDatacenterandId !== void 0 && (isDatacenterAndIdEnabled = res.EnableDatacenterandId), resolve();
    }), chrome.storage.onChanged?.addListener((changes, area) => {
      area === "local" && (changes.rovalraDatacenters && (rovalraDatacentersCache = changes.rovalraDatacenters.newValue), changes.ServerlistmodificationsEnabled && (isServerListModificationsEnabled = changes.ServerlistmodificationsEnabled.newValue, isServerListModificationsEnabled || document.querySelectorAll(".rovalra-details-container, .rovalra-server-extra-details, .rovalra-copy-join-link").forEach((el2) => el2.remove())), changes.enableShareLink && (isShareLinkEnabled = changes.enableShareLink.newValue), changes.EnableServerUptime && (isServerUptimeEnabled = changes.EnableServerUptime.newValue), changes.EnableServerRegion && (isServerRegionEnabled = changes.EnableServerRegion.newValue), changes.EnablePlaceVersion && (isPlaceVersionEnabled = changes.EnablePlaceVersion.newValue), changes.EnableFullServerID && (isFullServerIDEnabled = changes.EnableFullServerID.newValue), changes.EnableFullServerIndicators && (isFullServerIndicatorsEnabled = changes.EnableFullServerIndicators.newValue), changes.EnableServerPerformance && (isServerPerformanceEnabled = changes.EnableServerPerformance.newValue), changes.EnableMiscIndicators && (isMiscIndicatorsEnabled = changes.EnableMiscIndicators.newValue), changes.EnableDatacenterandId && (isDatacenterAndIdEnabled = changes.EnableDatacenterandId.newValue, document.querySelectorAll("[data-rovalra-serverid]").forEach((server) => {
        displayIpAndDcId(server);
      })));
    });
  });
  function createUUID() {
    return crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      let r = Math.random() * 16 | 0;
      return (c === "x" ? r : r & 3 | 8).toString(16);
    });
  }
  __name(createUUID, "createUUID");
  function getLocationFromDataCenterId(id) {
    if (!rovalraDatacentersCache || !id) return null;
    let numId = Number(id);
    return isNaN(numId) ? null : rovalraDatacentersCache.find(
      (entry) => Array.isArray(entry.dataCenterIds) && entry.dataCenterIds.includes(numId) || entry.dataCenterId === numId
    ) || null;
  }
  __name(getLocationFromDataCenterId, "getLocationFromDataCenterId");
  function getFullLocationName(data) {
    if (!data || typeof data != "object") return "Unknown Region";
    let loc = data.location || data, { city, region } = loc, parts = [city, region && region !== city ? region : null];
    return [...new Set(parts.filter(Boolean))].join(", ") || "Unknown Region";
  }
  __name(getFullLocationName, "getFullLocationName");
  function formatUptimeString(seconds) {
    if (seconds < 60) return null;
    let days = Math.floor(seconds / 86400), hours = Math.floor(seconds % 86400 / 3600), minutes = Math.floor(seconds % 3600 / 60), parts = [];
    return days > 0 && parts.push(`${days}d`), hours > 0 && parts.push(`${hours}h`), minutes > 0 && parts.push(`${minutes}m~`), parts.join(" ") || "0m~";
  }
  __name(formatUptimeString, "formatUptimeString");
  function normalizeText(s) {
    return s ? s.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().trim() : "";
  }
  __name(normalizeText, "normalizeText");
  function extractCountryCode(regionName) {
    if (!regionName || !rovalraDatacentersCache?.length) return null;
    let parts = regionName.split(",").map((p) => p.trim());
    for (let part of parts) {
      let id = Number(part);
      if (!isNaN(id)) {
        let loc = getLocationFromDataCenterId(id);
        if (loc?.location?.country) return loc.location.country.toLowerCase();
      }
    }
    let targetParts = parts.map(normalizeText);
    for (let entry of rovalraDatacentersCache) {
      let loc = entry.location || entry;
      if (!loc.country) continue;
      let city = normalizeText(loc.city), region = normalizeText(loc.region);
      if (targetParts.includes(city) || targetParts.includes(region))
        return loc.country.toLowerCase();
    }
    return null;
  }
  __name(extractCountryCode, "extractCountryCode");
  function removeCountryFromRegion(regionName) {
    if (!regionName || !rovalraDatacentersCache) return regionName;
    let parts = regionName.split(",").map((p) => p.trim());
    if (parts.length <= 1) return regionName;
    let countrySet = new Set(rovalraDatacentersCache.flatMap((entry) => {
      let loc = entry.location || entry;
      return [loc.country, loc.country_name].filter(Boolean).map(normalizeText);
    }));
    return parts.filter((part) => {
      let norm = normalizeText(part);
      return !countrySet.has(norm) && !/^[A-Za-z]{2}$/.test(part);
    }).join(", ") || regionName;
  }
  __name(removeCountryFromRegion, "removeCountryFromRegion");
  function getOrCreateDetailsContainer(server) {
    if (!isServerListModificationsEnabled)
      return server.querySelector(`.${CLASSES.CONTAINER}`);
    let container = server.querySelector(`.${CLASSES.CONTAINER}`);
    if (container) return container;
    container = document.createElement("div"), container.className = CLASSES.CONTAINER;
    let isFriends = server.classList.contains("rbx-friends-game-server-item");
    server.classList.contains("rbx-private-game-server-item") ? container.style.cssText = "display: flex; flex-direction: column; align-items: flex-start; gap: 2px; margin-top: 4px; width: 100%;" : container.style.cssText = isFriends ? STYLES2.containerFriends : STYLES2.container;
    let statusNode = server.querySelector(".text-info.rbx-game-status");
    if (statusNode && statusNode.parentNode)
      statusNode.parentNode.insertBefore(container, statusNode.nextSibling);
    else {
      let detailsParent = server.querySelector(".rbx-game-server-details, .rbx-friends-game-server-details");
      detailsParent ? detailsParent.prepend(container) : server.appendChild(container);
    }
    return container;
  }
  __name(getOrCreateDetailsContainer, "getOrCreateDetailsContainer");
  function createInfoElement(className, svg2, text2) {
    let element = document.createElement("div");
    element.className = `${className} ${CLASSES.INFO_ROW}`, element.style.cssText = STYLES2.row, element.style.color = "var(--rovalra-main-text-color)";
    let iconSpan = document.createElement("span");
    iconSpan.className = "rovalra-icon-wrapper", iconSpan.style.cssText = STYLES2.icon, iconSpan.innerHTML = svg2;
    let textSpan = document.createElement("span");
    return textSpan.style.cssText = STYLES2.text, textSpan.textContent = text2, element.appendChild(iconSpan), element.appendChild(textSpan), element;
  }
  __name(createInfoElement, "createInfoElement");
  function updateInfoElement(container, type, iconHTML, text2, isVisible = !0) {
    if (!container) return;
    let className = CLASSES[type], element = container.querySelector(`.${className}`);
    if (!isVisible) {
      element && (element.style.display = "none");
      return;
    }
    if (!element) {
      element = createInfoElement(className, iconHTML, text2);
      let orderIndex = ORDERS[type] || ORDERS.Status;
      element.style.order = orderIndex, container.appendChild(element);
    }
    let iconWrapper = element.querySelector(".rovalra-icon-wrapper"), textWrapper = element.querySelector("span:not(.rovalra-icon-wrapper)");
    return iconWrapper && (iconWrapper.innerHTML = iconHTML), textWrapper && (textWrapper.textContent = text2), element.style.display = "flex", element;
  }
  __name(updateInfoElement, "updateInfoElement");
  function clearExclusiveStatuses(container) {
    [CLASSES.Uptime, CLASSES.Version, CLASSES.Region, CLASSES.Full, CLASSES.Private, CLASSES.Purchase, CLASSES.Inactive].forEach((cls) => container.querySelector(`.${cls}`)?.remove());
  }
  __name(clearExclusiveStatuses, "clearExclusiveStatuses");
  function injectStyles2() {
    if (document.getElementById("rovalra-dynamic-styles")) return;
    let style = document.createElement("style");
    style.id = "rovalra-dynamic-styles", style.textContent = `
        .server-id-text span.show-on-hover {
            background-color: rgb(33, 33, 33);
            color: transparent;
            border-radius: 0px;
            padding: 0 4px;
            transition: background-color 0.2s ease, color 0.2s ease;
            cursor: default;
        }
        .server-id-text:hover span.show-on-hover {
            background-color: transparent;
            color: inherit;
        }
    `, document.head.appendChild(style);
  }
  __name(injectStyles2, "injectStyles");
  function enableAvatarLinks(server) {
    server.querySelectorAll(".avatar-card-link").forEach((link) => {
      link.dataset.rovalraHooked || (link.addEventListener("click", (e) => e.stopPropagation()), link.dataset.rovalraHooked = "true");
    });
  }
  __name(enableAvatarLinks, "enableAvatarLinks");
  function displayPerformance(server, fps, serverLocations2 = {}) {
    if (!isServerPerformanceEnabled || !isServerListModificationsEnabled) {
      let container2 = getOrCreateDetailsContainer(server);
      updateInfoElement(container2, "Performance", "", "", !1);
      return;
    }
    if (serverLocations2[server.dataset.rovalraServerid] === "private") return;
    let container = getOrCreateDetailsContainer(server), text2 = "Server Performance Unknown", icon = ICONS.performanceHigh, visible = !1;
    if (fps === "fetching")
      text2 = "Server Performance Loading...", visible = !0;
    else if (typeof fps == "number") {
      let percent = Math.min(100, Math.round(fps / 60 * 100));
      text2 = `Server Performance ${percent}%`, icon = percent < 50 ? ICONS.performanceLow : ICONS.performanceHigh, visible = !0;
    }
    updateInfoElement(container, "Performance", icon, text2, visible);
  }
  __name(displayPerformance, "displayPerformance");
  function displayUptime(server, uptime, serverLocations2 = {}) {
    if (!isServerUptimeEnabled || !isServerListModificationsEnabled) {
      let container2 = getOrCreateDetailsContainer(server);
      updateInfoElement(container2, "Uptime", "", "", !1);
      return;
    }
    if (serverLocations2[server.dataset.rovalraServerid] === "private") return;
    let container = getOrCreateDetailsContainer(server), text2 = "Unknown", visible = !1;
    if (uptime === "fetching")
      text2 = "Loading...", visible = !0;
    else if (typeof uptime == "number") {
      let fmt = formatUptimeString(uptime);
      fmt && (text2 = fmt, visible = !0);
    }
    updateInfoElement(container, "Uptime", ICONS.uptime, text2, visible);
  }
  __name(displayUptime, "displayUptime");
  function displayPlaceVersion(server, version, serverLocations2 = {}) {
    if (!isPlaceVersionEnabled || !isServerListModificationsEnabled) {
      let container2 = getOrCreateDetailsContainer(server);
      updateInfoElement(container2, "Version", "", "", !1);
      return;
    }
    if (serverLocations2[server.dataset.rovalraServerid] === "private") return;
    let container = getOrCreateDetailsContainer(server), text2 = "Version Unknown", visible = !1;
    if (version && version !== "Unknown") {
      text2 = `Version ${version}`;
      let containerList = document.getElementById("rbx-public-game-server-item-container");
      containerList && (String(version) === containerList.dataset.newestVersion ? text2 += " (Latest)" : String(version) === containerList.dataset.oldestVersion && (text2 += " (Oldest)")), visible = !0;
    }
    updateInfoElement(container, "Version", ICONS.version, text2, visible);
  }
  __name(displayPlaceVersion, "displayPlaceVersion");
  function displayRegion(server, regionName, serverLocations2 = {}) {
    if (!isServerRegionEnabled || !isServerListModificationsEnabled) {
      let container2 = getOrCreateDetailsContainer(server);
      updateInfoElement(container2, "Region", "", "", !1);
      return;
    }
    let container = getOrCreateDetailsContainer(server);
    regionName && regionName !== "Unknown Region" && (container.querySelector(`.${CLASSES.Full}`)?.remove(), container.querySelector(`.${CLASSES.Private}`)?.remove());
    let text2 = "Unknown", icon = ICONS.regionDefault, visible = !1;
    if (regionName && regionName !== "Unknown Region" && regionName !== "N/A" && regionName !== "Unknown") {
      let countryCode = extractCountryCode(regionName);
      text2 = removeCountryFromRegion(regionName), text2 === "Unknown" || text2 === "N/A" || !text2 ? visible = !1 : (countryCode && (icon = `<img src="https://flagcdn.com/w40/${countryCode}.png" srcset="https://flagcdn.com/w80/${countryCode}.png 2x" width="20" height="14" alt="${countryCode}" style="display: block;">`), visible = !0);
    }
    updateInfoElement(container, "Region", icon, text2, visible);
  }
  __name(displayRegion, "displayRegion");
  function displayIpAndDcId(server) {
    let extraDiv = server.querySelector(".rovalra-server-extra-details");
    if (!isFullServerIDEnabled || !isDatacenterAndIdEnabled || !isServerListModificationsEnabled) {
      extraDiv && extraDiv.remove();
      return;
    }
    let idDiv = server.querySelector(".server-id-text");
    if (!idDiv) return;
    extraDiv || (extraDiv = document.createElement("div"), idDiv.after(extraDiv)), extraDiv.className = "rovalra-server-extra-details text-info xsmall";
    let ip = server.dataset.rovalraIp, dcId = server.dataset.rovalraDcId;
    if (extraDiv.style.cssText = "font-size: 9px; margin-top: 2px; display: flex; justify-content: space-between; min-height: 12px; padding: 0 8px; box-sizing: border-box;", extraDiv.innerHTML = "", isDatacenterAndIdEnabled) {
      let ipSpan = document.createElement("span");
      ipSpan.textContent = ip || "---", extraDiv.appendChild(ipSpan);
      let dcIdSpan = document.createElement("span");
      dcIdSpan.textContent = dcId || "---", extraDiv.appendChild(dcIdSpan);
    }
  }
  __name(displayIpAndDcId, "displayIpAndDcId");
  function displayServerFullStatus(server) {
    if (!isFullServerIndicatorsEnabled || !isServerListModificationsEnabled) {
      let container2 = getOrCreateDetailsContainer(server);
      updateInfoElement(container2, "Full", "", "", !1);
      return;
    }
    let container = getOrCreateDetailsContainer(server);
    container.querySelector(`.${CLASSES.Region}`)?.remove(), updateInfoElement(container, "Full", ICONS.full, "Server is Full", !0);
  }
  __name(displayServerFullStatus, "displayServerFullStatus");
  function displayPrivateServerStatus(server) {
    if (!isMiscIndicatorsEnabled || !isServerListModificationsEnabled) {
      let container2 = getOrCreateDetailsContainer(server);
      updateInfoElement(container2, "Private", "", "", !1);
      return;
    }
    let container = getOrCreateDetailsContainer(server);
    clearExclusiveStatuses(container), updateInfoElement(container, "Private", ICONS.private, "Playing in a private server", !0);
  }
  __name(displayPrivateServerStatus, "displayPrivateServerStatus");
  function displayPurchaseGameStatus(server) {
    if (!isMiscIndicatorsEnabled || !isServerListModificationsEnabled) {
      let container2 = getOrCreateDetailsContainer(server);
      updateInfoElement(container2, "Purchase", "", "", !1);
      return;
    }
    let container = getOrCreateDetailsContainer(server);
    clearExclusiveStatuses(container), updateInfoElement(container, "Purchase", ICONS.purchase, "Buy game to see regions.", !0);
  }
  __name(displayPurchaseGameStatus, "displayPurchaseGameStatus");
  function displayInactivePlaceStatus(server) {
    server && server.remove();
  }
  __name(displayInactivePlaceStatus, "displayInactivePlaceStatus");
  async function fetchServerUptime2(placeId, serverIds, serverLocations2, serverUptimes) {
    let validIds = serverIds.filter((id) => id && id !== "null");
    if (validIds.length)
      try {
        let response = await callRobloxApi({
          subdomain: "apis",
          endpoint: `/v1/servers/details?place_id=${placeId}&server_ids=${validIds.join(",")}`,
          method: "GET",
          isRovalraApi: !0
        });
        if (!response.ok) throw new Error("API Error");
        let data = await response.json();
        if (data.status !== "success" || !data.servers) throw new Error("Invalid API Data");
        let now = /* @__PURE__ */ new Date(), foundIds = /* @__PURE__ */ new Set();
        data.servers.forEach((info) => {
          let { server_id, first_seen, place_version, city, region, country, ip_address, datacenter_id } = info;
          if (!server_id) return;
          foundIds.add(server_id), place_version && (serverVersionsCache[server_id] = place_version);
          let versionToDisplay = place_version || serverVersionsCache[server_id], uptime = "N/A";
          if (first_seen) {
            let date = new Date(first_seen.endsWith("Z") ? first_seen : first_seen + "Z");
            isNaN(date) || (uptime = Math.max(0, (now - date) / 1e3));
          }
          serverUptimes[server_id] = uptime;
          let regionStr = null, locParts = [city, region && region !== city ? region : null, country].filter((p) => p && p !== "Unknown");
          locParts.length && (regionStr = [...new Set(locParts)].join(", "), serverLocations2[server_id] = regionStr), document.querySelectorAll(`[data-rovalra-serverid="${server_id}"]`).forEach((serverEl) => {
            ip_address != null && (serverEl.dataset.rovalraIp = ip_address), datacenter_id != null && (serverEl.dataset.rovalraDcId = datacenter_id), displayPlaceVersion(serverEl, versionToDisplay, serverLocations2), displayUptime(serverEl, uptime, serverLocations2), regionStr && displayRegion(serverEl, regionStr, serverLocations2), displayIpAndDcId(serverEl);
          });
        }), validIds.filter((id) => !foundIds.has(id)).forEach((id) => {
          serverUptimes[id] = "N/A", document.querySelectorAll(`[data-rovalra-serverid="${id}"]`).forEach((el2) => {
            displayUptime(el2, "N/A", serverLocations2), serverLocations2[id] || displayServerFullStatus(el2);
          });
        });
      } catch {
        validIds.forEach((id) => {
          serverUptimes[id] = "N/A", document.querySelectorAll(`[data-rovalra-serverid="${id}"]`).forEach((el2) => {
            displayUptime(el2, "N/A", serverLocations2);
          });
        });
      }
  }
  __name(fetchServerUptime2, "fetchServerUptime");
  async function fetchAndDisplayRegion(server, serverId, serverIpMap4, serverLocations2, options = {}) {
    let placeId = server.dataset.placeid || window.location.href.match(/\/games\/(\d+)\//)?.[1];
    if (!placeId) {
      serverLocations2[serverId] || displayServerFullStatus(server);
      return;
    }
    try {
      let endpoint = options.isPrivate ? "/v1/join-private-game" : "/v1/join-game-instance", body = options.isPrivate ? { placeId: parseInt(placeId), accessCode: options.accessCode, gameJoinAttemptId: createUUID() } : { placeId: parseInt(placeId), gameId: serverId, gameJoinAttemptId: createUUID() }, response = await callRobloxApi({
        subdomain: "gamejoin",
        endpoint,
        method: "POST",
        body
      });
      if (server.dataset.rovalraServerid !== serverId) return;
      if (response.ok) {
        let info = await response.json(), joinBtn = server.querySelector(".game-server-join-btn");
        if (info.joinScript) {
          let joinScript = info.joinScript, changed = !1;
          if (joinScript.DataCenterId != null && !server.dataset.rovalraDcId && (server.dataset.rovalraDcId = joinScript.DataCenterId, changed = !0), !server.dataset.rovalraIp) {
            let ip = null;
            joinScript.UdmuxEndpoints && joinScript.UdmuxEndpoints.length > 0 && joinScript.UdmuxEndpoints[0].Address ? ip = joinScript.UdmuxEndpoints[0].Address : joinScript.MachineAddress && (ip = joinScript.MachineAddress), ip && (server.dataset.rovalraIp = ip, changed = !0);
          }
          changed && displayIpAndDcId(server);
        }
        if (info.status === 12) {
          if (info.message?.includes("private instance")) {
            serverLocations2[serverId] || (serverLocations2[serverId] = "private", displayPrivateServerStatus(server));
            return;
          }
          if (info.message?.toLowerCase().includes("purchase access")) {
            serverLocations2[serverId] || (serverLocations2[serverId] = "purchase", displayPurchaseGameStatus(server));
            return;
          }
        }
        if (info.status === 5) {
          serverLocations2[serverId] || (serverLocations2[serverId] = "inactive", displayInactivePlaceStatus(server));
          return;
        }
        if (info.status === 22) {
          isFullServerIndicatorsEnabled && (joinBtn && (joinBtn.textContent = info.queuePosition > 0 ? `Join (${info.queuePosition} In Queue)` : "Server Full", joinBtn.classList.replace("btn-primary-md", "btn-secondary-md")), serverLocations2[serverId] || displayServerFullStatus(server));
          return;
        }
        if (info.joinScript?.PlaceVersion && (serverVersionsCache[serverId] || (serverVersionsCache[serverId] = info.joinScript.PlaceVersion, displayPlaceVersion(server, info.joinScript.PlaceVersion, serverLocations2))), !serverLocations2[serverId] || serverLocations2[serverId] === "Unknown Region" || serverLocations2[serverId] === "Unknown") {
          let dcId = info.joinScript?.DataCenterId, locInfo = dcId && serverIpMap4?.[dcId] ? serverIpMap4[dcId] : null;
          if (!locInfo && dcId && (await cacheReadyPromise, locInfo = getLocationFromDataCenterId(dcId)), locInfo) {
            let fullName = getFullLocationName(locInfo);
            serverLocations2[serverId] = fullName, displayRegion(server, fullName, serverLocations2);
          }
        }
      }
    } catch {
      serverLocations2[serverId] || displayServerFullStatus(server);
    }
  }
  __name(fetchAndDisplayRegion, "fetchAndDisplayRegion");
  function isExcludedButton(node) {
    return !node || !node.classList ? !1 : node.classList.contains("rovalra-copy-join-link") || node.classList.contains("rovalra-vip-invite-link") || node.getAttribute("data-bind") === "game-context-menu";
  }
  __name(isExcludedButton, "isExcludedButton");
  function cleanupServerUI(server) {
    let toRemove = [".server-performance"];
    server.querySelectorAll(toRemove.join(",")).forEach((el2) => {
      isExcludedButton(el2) || el2.remove();
    }), server.querySelectorAll(".text-info.rbx-game-status").forEach((el2) => {
      el2.textContent = el2.textContent.replace(/^\s*(Region:|Ping:|Server is full).*$/gim, "").trim();
    });
  }
  __name(cleanupServerUI, "cleanupServerUI");
  var cleanupObserverInitialized = !1;
  function attachCleanupObserver(server) {
    cleanupObserverInitialized || (cleanupObserverInitialized = !0, observeElement(".share-button, .server-performance", (node) => {
      !isExcludedButton(node) && node.closest("[data-rovalra-serverid]") && node.remove();
    }, { multiple: !0 }));
  }
  __name(attachCleanupObserver, "attachCleanupObserver");
  async function addCopyJoinLinkButton(server, serverId) {
    if (await cacheReadyPromise, isShareLinkEnabled === !1 || !isServerListModificationsEnabled || server.querySelector(".rovalra-copy-join-link")) return;
    let placeId = server.dataset.placeid || window.location.href.match(/\/games\/(\d+)\//)?.[1];
    if (!placeId) return;
    let btn = document.createElement("button");
    btn.className = "btn-full-width btn-control-xs btn-primary-md btn-min-width rovalra-copy-join-link", btn.textContent = "Share", btn.style.cssText = "margin-top: 5px; width: 100%;", btn.onclick = (e) => {
      e.preventDefault(), e.stopPropagation();
      let link = `https://www.fishstrap.app/v1/joingame?placeId=${placeId}&gameInstanceId=${serverId}`;
      navigator.clipboard.writeText(link).then(() => {
        btn.textContent = "Copied!", setTimeout(() => btn.textContent = "Share", 2e3);
      });
    };
    let joinBtn = server.querySelector(".game-server-join-btn");
    joinBtn ? (joinBtn.style.width = "100%", joinBtn.after(btn)) : server.querySelector(".rbx-game-server-details")?.appendChild(btn);
  }
  __name(addCopyJoinLinkButton, "addCopyJoinLinkButton");
  async function enhanceServer(server, context) {
    if (await cacheReadyPromise, !isServerListModificationsEnabled) return;
    injectStyles2();
    let { serverLocations: serverLocations2, serverUptimes, serverPerformanceCache, uptimeBatch, serverIpMap: serverIpMap4, processUptimeBatch: processUptimeBatch2 } = context;
    server._rovalraListener || (server._rovalraListener = () => enhanceServer(server, context), server.addEventListener("rovalra-serverid-set", server._rovalraListener));
    let serverId = server.getAttribute("data-rovalra-serverid"), isPrivate = server.classList.contains("rbx-private-game-server-item");
    if (!serverId && isPrivate && (serverId = server.dataset.accessCode), !serverId) return;
    let lastId = server._rovalraLastProcessedId;
    if (lastId && lastId !== serverId ? (server.dataset.rovalraEnhanced = "false", cleanupServerUI(server)) : server.dataset.rovalraEnhanced === "true" && lastId === serverId && enableAvatarLinks(server), server._rovalraLastProcessedId = serverId, server.dataset.rovalraEnhanced = "true", server.classList.add("rovalra-checked"), cleanupServerUI(server), attachCleanupObserver(server), getOrCreateDetailsContainer(server), displayPerformance(server, serverPerformanceCache[serverId] ?? "Unknown", serverLocations2), !isPrivate) {
      let cachedUptime = serverUptimes[serverId];
      displayUptime(server, cachedUptime !== void 0 ? cachedUptime : "fetching", serverLocations2);
    }
    let cachedVersion = serverVersionsCache[serverId];
    displayPlaceVersion(server, cachedVersion || "Unknown", serverLocations2);
    let cachedLocation = serverLocations2[serverId];
    displayRegion(server, cachedLocation || "Unknown", serverLocations2);
    let apiData = server._rovalraApiData;
    if (apiData && (apiData.server_id || apiData.id) === serverId) {
      if (apiData.place_version && (serverVersionsCache[serverId] = apiData.place_version, displayPlaceVersion(server, apiData.place_version, serverLocations2)), apiData.first_seen && !isPrivate) {
        let date = new Date(apiData.first_seen.endsWith("Z") ? apiData.first_seen : apiData.first_seen + "Z"), uptime = isNaN(date) ? 0 : Math.max(0, (/* @__PURE__ */ new Date() - date) / 1e3);
        serverUptimes[serverId] = uptime, displayUptime(server, uptime, serverLocations2);
      }
      let locParts = [apiData.city, apiData.region, apiData.country].filter(Boolean);
      if (locParts.length) {
        let locStr = [...new Set(locParts)].join(", ");
        serverLocations2[serverId] = locStr, displayRegion(server, locStr, serverLocations2);
      }
    }
    if ((isServerUptimeEnabled || isServerRegionEnabled || isPlaceVersionEnabled) && (serverUptimes[serverId] === void 0 && !isPrivate ? (serverUptimes[serverId] = "fetching", uptimeBatch.add(serverId), clearTimeout(server._rovalraUptimeTimeout), server._rovalraUptimeTimeout = setTimeout(() => processUptimeBatch2(), 100)) : serverUptimes[serverId] === "fetching" && !isPrivate && displayUptime(server, "fetching", serverLocations2)), fetchAndDisplayRegion(server, serverId, serverIpMap4, serverLocations2, { isPrivate, accessCode: server.dataset.accessCode }), displayIpAndDcId(server), isPrivate || addCopyJoinLinkButton(server, serverId), enableAvatarLinks(server), isFullServerIDEnabled && !isPrivate) {
      let idDiv = server.querySelector(".server-id-text");
      if (!idDiv) {
        idDiv = document.createElement("div"), idDiv.className = "server-id-text text-info xsmall";
        let appendTarget = server.querySelector(".rovalra-copy-join-link") || server.querySelector(".game-server-join-btn");
        appendTarget ? appendTarget.after(idDiv) : server.querySelector(".rbx-game-server-details")?.appendChild(idDiv);
      }
      idDiv.style.cssText = "font-size: 9px; margin-top: 6px; text-align: center; width: 100%; white-space: normal; word-break: break-all;", idDiv.innerHTML = "";
      let prefixSpan = document.createElement("span");
      prefixSpan.textContent = "ID: ", prefixSpan.style.userSelect = "none";
      let uuidSpan = document.createElement("span");
      uuidSpan.textContent = serverId, server.querySelector(".avatar-card-link") !== null && uuidSpan.classList.add("show-on-hover"), idDiv.appendChild(prefixSpan), idDiv.appendChild(uuidSpan);
    }
  }
  __name(enhanceServer, "enhanceServer");

  // src/content/features/games/serverlist/serverlist.js
  var SHARED_STYLES = `
    #rovalra-main-controls {
        display: flex;
        align-items: center;
        flex: 1; 
        margin-left: 5px; 
        gap: 10px; 
        flex-wrap: nowrap;
    }

    #rovalra-main-controls .rovalra-dropdown-container {
        margin: 0 !important; 
    }

    .filter-button-alignment {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        padding: 6px 8px;
        min-height: 38px; 
        box-sizing: border-box;
    }
    
    .filter-button-alignment svg { width: 20px; height: 20px; }

    body.rovalra-filter-active .rbx-public-running-games-footer { display: none !important; }
`, _state = {
    serverIpMap: null,
    serverLocations: {},
    serverUptimes: {},
    serverPerformanceCache: {},
    vipStatusCache: {},
    uptimeBatch: /* @__PURE__ */ new Set(),
    collectedPlayerTokens: [],
    recentlyUsedTokens: [],
    originalServerElements: [],
    isFilterActive: !1,
    elements: {
      container: null,
      clearButton: null
    },
    filterSettings: {
      serverFilter: !0,
      region: !0,
      uptime: !0,
      version: !0
    }
  };
  function init26() {
    if (typeof chrome > "u" || !chrome.storage || !chrome.storage.local) {
      safeInitAll();
      return;
    }
    chrome.storage.local.get([
      "ServerlistmodificationsEnabled",
      "ServerFilterEnabled",
      "RegionFiltersEnabled",
      "UptimeFiltersEnabled",
      "VersionFiltersEnabled"
    ], (settings) => {
      settings && settings.ServerlistmodificationsEnabled === !1 && settings.ServerFilterEnabled === !1 || (settings && (_state.filterSettings = {
        serverFilter: settings.ServerFilterEnabled !== !1,
        region: settings.RegionFiltersEnabled !== !1,
        uptime: settings.UptimeFiltersEnabled !== !1,
        version: settings.VersionFiltersEnabled !== !1
      }), safeInitAll());
    });
  }
  __name(init26, "init");
  function safeInitAll() {
    if (!document.getElementById("rovalra-filter-shared-styles")) {
      let s = document.createElement("style");
      s.id = "rovalra-filter-shared-styles", s.textContent = SHARED_STYLES, document.head.appendChild(s);
    }
    try {
      typeof loadDatacenterMap == "function" && loadDatacenterMap().catch(() => {
      });
    } catch {
    }
    try {
      typeof initServerIdExtraction == "function" && initServerIdExtraction();
    } catch {
    }
    try {
      typeof initGlobalStatsBar == "function" && initGlobalStatsBar();
    } catch {
    }
    startController();
  }
  __name(safeInitAll, "safeInitAll");
  function createFilterUI(parentContainer) {
    if (_state.elements.container && document.body.contains(_state.elements.container)) return;
    let container = document.createElement("div");
    container.id = "rovalra-main-controls", parentContainer.closest("#roseal-running-game-instances-container") ? (parentContainer.insertAdjacentElement("afterend", container), container.style.marginTop = "5px", container.style.marginBottom = "5px") : parentContainer.appendChild(container), _state.elements.container = container;
    let filters = _state.filterSettings;
    if (filters.serverFilter) {
      if (filters.version) try {
        typeof initVersionFilters == "function" && initVersionFilters();
      } catch {
      }
      if (filters.uptime) try {
        typeof initUptimeFilters == "function" && initUptimeFilters();
      } catch {
      }
      if (filters.region) try {
        typeof initRegionFilters == "function" && initRegionFilters();
      } catch {
      }
    }
    createClearButton(container);
  }
  __name(createFilterUI, "createFilterUI");
  function createClearButton(container) {
    let wrapper = document.createElement("div");
    wrapper.id = "rovalra-clear-filter-btn", wrapper.className = "rbx-refresh-button-wrapper", wrapper.style.cssText = "margin-left: auto; display: none;";
    let btn = createButton("Clear", "secondary");
    btn.classList.add("filter-button-alignment"), btn.innerHTML = purify.sanitize('<span>Clear</span><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6L18 18"/></svg>'), btn.addEventListener("click", () => {
      clearAllFilters();
    }), wrapper.appendChild(btn), container.appendChild(wrapper), _state.elements.clearButton = wrapper;
  }
  __name(createClearButton, "createClearButton");
  function handleFilterActivation() {
    if (_state.isFilterActive) return;
    let serverListContainer = document.querySelector("#rbx-public-game-server-item-container");
    serverListContainer && !_state.originalServerElements.length && (_state.originalServerElements = Array.from(serverListContainer.children)), _state.isFilterActive = !0, document.body.classList.add("rovalra-filter-active"), _state.elements.clearButton && (_state.elements.clearButton.style.display = "flex");
    let defaultFooter = document.querySelector(".rbx-public-running-games-footer");
    defaultFooter && (defaultFooter.style.display = "none");
  }
  __name(handleFilterActivation, "handleFilterActivation");
  function clearAllFilters() {
    let serverListContainer = document.querySelector("#rbx-public-game-server-item-container");
    document.getElementById("rovalra-load-more-btn")?.remove(), serverListContainer && _state.originalServerElements.length && (serverListContainer.innerHTML = "", _state.originalServerElements.forEach((el2) => {
      el2.style.display = "block", serverListContainer.appendChild(el2);
    })), _state.isFilterActive = !1, _state.originalServerElements = [], document.body.classList.remove("rovalra-filter-active"), _state.elements.clearButton && (_state.elements.clearButton.style.display = "none");
    let footer = document.querySelector(".rbx-public-running-games-footer");
    footer && (footer.style.display = "block"), document.dispatchEvent(new CustomEvent("rovalraClearFilters"));
    let rbxRefresh = document.getElementById("rbx-public-running-games")?.querySelector(".rbx-refresh");
    rbxRefresh && setTimeout(() => rbxRefresh.click(), 50);
  }
  __name(clearAllFilters, "clearAllFilters");
  function attachGlobalListeners2() {
    document.addEventListener("rovalraRegionSelected", (ev) => {
      ev.detail?.regionCode && handleFilterActivation();
    }), document.addEventListener("rovalraUptimeSelected", () => {
      handleFilterActivation();
    }), document.addEventListener("rovalraVersionSelected", () => {
      handleFilterActivation();
    }), document.addEventListener("rovalraRegionServersLoaded", (ev) => {
      let detail = ev && ev.detail;
      if (detail && detail.error) {
        displayMessageInContainer(detail.error, !0);
        return;
      }
      if (!detail) return;
      let servers = detail.servers || [], nextCursor = detail.next_cursor, append = !!detail.append, regionCode = detail.regionCode, serverListContainer = document.querySelector("#rbx-public-game-server-item-container");
      serverListContainer && (append || (serverListContainer.innerHTML = ""), servers.length > 0 ? (renderAndAppendServers(servers, serverListContainer, getPlaceIdFromUrl6()), manageLoadMoreButton(nextCursor, regionCode)) : append ? document.getElementById("rovalra-load-more-btn")?.remove() : displayMessageInContainer("No servers found via the RoValra API.", !1));
    }), document.addEventListener("rovalraRequestError", (ev) => {
      let errorMessage = ev.detail?.message || "Failed to load servers from RoValra API.";
      displayMessageInContainer(errorMessage, !0);
    }), document.addEventListener("rovalra-server-inactive", (ev) => {
      let serverId = ev.detail?.serverId;
      if (!serverId) return;
      let serverElement = document.querySelector(`li[data-rovalra-serverid="${serverId}"]`);
      serverElement && serverElement.remove();
    });
  }
  __name(attachGlobalListeners2, "attachGlobalListeners");
  function manageLoadMoreButton(nextCursor, regionCode) {
    if (document.getElementById("rovalra-load-more-btn")?.remove(), nextCursor) {
      let serverListContainer = document.querySelector("#rbx-public-game-server-item-container"), loadMoreButton = document.createElement("button");
      loadMoreButton.id = "rovalra-load-more-btn", loadMoreButton.textContent = "Load More", loadMoreButton.className = "btn-control-sm rbx-upgrade-now-button", loadMoreButton.style.width = "100%", loadMoreButton.style.display = "block", loadMoreButton.style.marginTop = "10px", loadMoreButton.style.cursor = "pointer", loadMoreButton.addEventListener("click", () => {
        loadMoreButton.innerHTML = purify.sanitize('<span class="spinner spinner-default"></span>'), loadMoreButton.disabled = !0, document.dispatchEvent(new CustomEvent("rovalraRequestRegionServers", {
          detail: { regionCode, cursor: nextCursor }
        }));
      }), serverListContainer && serverListContainer.parentElement && serverListContainer.parentElement.appendChild(loadMoreButton);
    }
  }
  __name(manageLoadMoreButton, "manageLoadMoreButton");
  var _started = { value: !1 };
  function startController() {
    if (!_started.value) {
      _started.value = !0;
      try {
        typeof startObserving == "function" && startObserving();
      } catch {
      }
      loadServerIpMap().then(() => {
        initializeEnhancementObserver();
      }).catch(() => {
        initializeEnhancementObserver();
      }), attachGlobalListeners2(), observeElement(".server-list-options", (optionsBar) => {
        createFilterUI(optionsBar);
      }, { multiple: !1 });
    }
  }
  __name(startController, "startController");
  function getPlaceIdFromUrl6() {
    return window.location.pathname.match(/\/games\/(\d+)\//)?.[1] || window.location.pathname.match(/\/(\d{5,})\b/)?.[1] || "";
  }
  __name(getPlaceIdFromUrl6, "getPlaceIdFromUrl");
  async function loadServerIpMap() {
    try {
      typeof loadDatacenterMap == "function" && await loadDatacenterMap();
    } catch {
    }
    if (typeof chrome > "u" || !chrome.storage || !chrome.storage.local) {
      _state.serverIpMap = {};
      return;
    }
    try {
      let result = await new Promise((resolve) => chrome.storage.local.get("rovalraDatacenters", resolve)), apiData = result && result.rovalraDatacenters;
      if (!apiData || !Array.isArray(apiData)) {
        _state.serverIpMap = {};
        return;
      }
      let map = {};
      for (let dcGroup of apiData)
        if (!(!dcGroup || !dcGroup.dataCenterIds || !Array.isArray(dcGroup.dataCenterIds) || !dcGroup.location))
          for (let id of dcGroup.dataCenterIds)
            map[id] = dcGroup.location;
      _state.serverIpMap = map;
    } catch {
      _state.serverIpMap = {};
    }
  }
  __name(loadServerIpMap, "loadServerIpMap");
  function processUptimeBatch() {
    if (_state.uptimeBatch.size === 0) return;
    let placeId = window.location.pathname.match(/\/games\/(\d+)\//)?.[1];
    if (!placeId) return;
    let batch = Array.from(_state.uptimeBatch);
    _state.uptimeBatch.clear();
    try {
      fetchServerUptime2(placeId, batch, _state.serverLocations, _state.serverUptimes).catch(() => {
      });
    } catch {
    }
  }
  __name(processUptimeBatch, "processUptimeBatch");
  function initializeEnhancementObserver() {
    let serverSelector = ".rbx-public-game-server-item, .rbx-friends-game-server-item", uptimeDebounce = null, scheduleUptime = /* @__PURE__ */ __name(() => {
      clearTimeout(uptimeDebounce), uptimeDebounce = setTimeout(() => processUptimeBatch(), 120);
    }, "scheduleUptime");
    try {
      observeElement(serverSelector, (el2) => {
        try {
          enhanceServer(el2, {
            serverLocations: _state.serverLocations,
            serverUptimes: _state.serverUptimes,
            serverPerformanceCache: _state.serverPerformanceCache,
            vipStatusCache: _state.vipStatusCache,
            uptimeBatch: _state.uptimeBatch,
            serverIpMap: _state.serverIpMap,
            processUptimeBatch
          }).catch(() => {
          });
        } catch {
        }
        scheduleUptime();
      }, { multiple: !0 });
      try {
        setTimeout(() => processUptimeBatch(), 50);
      } catch {
      }
    } catch {
    }
  }
  __name(initializeEnhancementObserver, "initializeEnhancementObserver");
  try {
    document.addEventListener("rovalra-game-servers-response", (event) => {
      try {
        let detail = event && event.detail;
        if (!detail) return;
        let data = detail.data || detail, serversArray = Array.isArray(data.data) ? data.data : Array.isArray(data) ? data : null;
        if (!serversArray) return;
        serversArray.forEach((serverData) => {
          let serverId = serverData.id || serverData.server_id || serverData.serverId || serverData.server_id, fps = serverData.fps ?? serverData.FPS ?? serverData.performance ?? null;
          if (serverData.playerTokens && Array.isArray(serverData.playerTokens) && (_state.collectedPlayerTokens.push(...serverData.playerTokens), _state.collectedPlayerTokens.length > 2e3 && _state.collectedPlayerTokens.splice(0, _state.collectedPlayerTokens.length - 2e3)), !serverId || typeof fps != "number") return;
          _state.serverPerformanceCache[serverId] = fps;
          let serverElement = document.querySelector(`[data-rovalra-serverid="${serverId}"]`);
          if (serverElement)
            try {
              displayPerformance(serverElement, fps, _state.serverLocations);
            } catch {
            }
        });
      } catch {
      }
    });
  } catch {
  }
  async function createServerCardFromRobloxApi(server, placeId) {
    try {
      let listItemClass = "rbx-public-game-server-item col-md-3 col-sm-4 col-xs-6", serverItem = document.createElement("li");
      serverItem.className = listItemClass;
      let serverId = server.id || server.server_id || "";
      serverItem.dataset.rovalraServerid = serverId;
      let playerTokens = server.playerTokens || [], playerThumbnailsHTML = "";
      if (playerTokens.length > 0) {
        let thumbnailItems = playerTokens.slice(0, 12).map((token) => ({ id: token })), thumbnailMap = await fetchThumbnails(thumbnailItems, "PlayerToken", "150x150");
        playerThumbnailsHTML = playerTokens.slice(0, 12).map((token) => `<span class="avatar avatar-headshot-md player-avatar"><span class="thumbnail-2d-container avatar-card-image"><img src="${thumbnailMap.get(token)?.imageUrl || ""}" alt="Player"></span></span>`).join("");
      }
      let remainingPlayers = server.playing - playerTokens.length, extraPlayersHTML = remainingPlayers > 0 ? `<span class="avatar avatar-headshot-md player-avatar hidden-players-placeholder">+${remainingPlayers}</span>` : "", playerThumbnailsContainerHTML = `<div class="player-thumbnails-container">${playerThumbnailsHTML}${extraPlayersHTML}</div>`, serverDetailsHTML = `
            <div class="text-info rbx-game-status rbx-public-game-server-status text-overflow">${server.playing} of ${server.maxPlayers} people max</div>
            <div class="server-player-count-gauge border"><div class="gauge-inner-bar border" style="width: ${server.playing / server.maxPlayers * 100}%;"></div></div>`;
      if (serverItem.innerHTML = purify.sanitize(`
            <div class="card-item card-item-public-server">
                ${playerThumbnailsContainerHTML}
                <div class="rbx-public-game-server-details game-server-details">
                    ${serverDetailsHTML}
                </div>
            </div>`), placeId) {
        let detailsDiv = serverItem.querySelector(".game-server-details"), joinBtn = document.createElement("button");
        joinBtn.className = "btn-full-width btn-control-xs rbx-public-game-server-join game-server-join-btn btn-primary-md btn-min-width", joinBtn.textContent = "Join", joinBtn.onclick = () => launchGame(placeId, serverId), detailsDiv.appendChild(joinBtn);
      }
      try {
        serverItem._rovalraApiData = server, serverItem.setAttribute("data-rovalra-api", "1");
      } catch {
      }
      return typeof server.fps == "number" && (_state.serverPerformanceCache[serverId] = server.fps), enhanceServer(serverItem, _state), serverItem;
    } catch {
      return null;
    }
  }
  __name(createServerCardFromRobloxApi, "createServerCardFromRobloxApi");
  async function createServerCardFromApi(server, placeId = "") {
    try {
      let listItemClass = "rbx-public-game-server-item col-md-3 col-sm-4 col-xs-6", serverItem = document.createElement("li");
      serverItem.className = listItemClass;
      let serverId = server.server_id || server.id || "";
      serverItem.dataset.rovalraServerid = serverId;
      let thumbnailsHTML = "", placeholderSrc = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTAgMTUwIj48cmVjdCB3aWR0aD0iMTUwIiBoZWlnaHQ9IjE1MCIgZmlsbD0iI0UzRTNFMyIvPjwvc3ZnPg==", tokensToFetch = [];
      if (_state.collectedPlayerTokens && _state.collectedPlayerTokens.length > 0) {
        let availableTokens = _state.collectedPlayerTokens.filter((t) => !_state.recentlyUsedTokens.includes(t));
        availableTokens.length < 6 && (availableTokens = [..._state.collectedPlayerTokens]);
        for (let i = 0; i < 6 && availableTokens.length !== 0; i++) {
          let randomIndex = Math.floor(Math.random() * availableTokens.length), token = availableTokens[randomIndex];
          tokensToFetch.push({ id: token }), availableTokens.splice(randomIndex, 1), _state.recentlyUsedTokens.push(token);
        }
        _state.recentlyUsedTokens.length > 60 && _state.recentlyUsedTokens.splice(0, _state.recentlyUsedTokens.length - 60);
      }
      if (tokensToFetch.length > 0)
        try {
          let thumbnailMap = await fetchThumbnails(tokensToFetch, "PlayerToken", "150x150");
          thumbnailsHTML = tokensToFetch.map((t) => {
            let data = thumbnailMap.get(t.id);
            return `<span class="avatar avatar-headshot-md player-avatar"><span class="thumbnail-2d-container avatar-card-image"><img src="${data && data.imageUrl ? data.imageUrl : placeholderSrc}" alt="Player"></span></span>`;
          }).join("");
        } catch {
        }
      if (!thumbnailsHTML)
        for (let i = 0; i < 6; i++)
          thumbnailsHTML += `<span class="avatar avatar-headshot-md player-avatar"><span class="thumbnail-2d-container avatar-card-image"><img src="${placeholderSrc}" alt="Player"></span></span>`;
      let playerThumbnailsContainerHTML = `
            <div class="player-thumbnails-container" style="position: relative;">
                ${thumbnailsHTML}
                <span class="icon-moreinfo rovalra-unknown-count-icon" style="position: absolute; top: -11px; right: -15px; z-index: 5; cursor: help;"></span>
            </div>`, serverDetailsHTML = `
            <div class="text-info rbx-game-status rbx-public-game-server-status text-overflow">Player count unknown</div>`;
      serverItem.innerHTML = purify.sanitize(`
            <div class="card-item card-item-public-server">
                ${playerThumbnailsContainerHTML}
                <div class="rbx-public-game-server-details game-server-details">
                    ${serverDetailsHTML}
                </div>
            </div>`);
      let infoIcon = serverItem.querySelector(".rovalra-unknown-count-icon");
      if (infoIcon && addTooltip(infoIcon, "Player count is unknown, this is a Roblox limitation. the thumbnails are not representative of the people in game", { position: "top" }), placeId) {
        let detailsDiv = serverItem.querySelector(".game-server-details"), joinBtn = document.createElement("button");
        joinBtn.className = "btn-full-width btn-control-xs rbx-public-game-server-join game-server-join-btn btn-primary-md btn-min-width", joinBtn.textContent = "Join", joinBtn.onclick = () => launchGame(placeId, serverId), detailsDiv.appendChild(joinBtn);
      }
      try {
        serverItem._rovalraApiData = server, serverItem.setAttribute("data-rovalra-api", "1");
      } catch {
      }
      return enhanceServer(serverItem, _state), serverItem;
    } catch {
      return null;
    }
  }
  __name(createServerCardFromApi, "createServerCardFromApi");
  async function renderAndAppendServers(servers, serverListContainer, placeId) {
    let serverCardPromises = servers.map((server) => server.playerTokens ? createServerCardFromRobloxApi(server, placeId) : createServerCardFromApi(server, placeId));
    (await Promise.all(serverCardPromises)).forEach((serverItem) => {
      serverItem && serverListContainer.appendChild(serverItem);
    }), equalizeCardHeights();
  }
  __name(renderAndAppendServers, "renderAndAppendServers");
  function equalizeCardHeights() {
    let serverListContainer = document.querySelector("#rbx-public-game-server-item-container");
    if (!serverListContainer) return;
    let serverCards = serverListContainer.querySelectorAll(".rbx-public-game-server-item .card-item");
    if (serverCards.length < 2) return;
    serverCards.forEach((card) => card.style.minHeight = "");
    let maxHeight = 0;
    serverCards.forEach((card) => {
      card.offsetHeight > maxHeight && (maxHeight = card.offsetHeight);
    }), serverCards.forEach((card) => card.style.minHeight = `${maxHeight}px`);
  }
  __name(equalizeCardHeights, "equalizeCardHeights");
  function displayMessageInContainer(message, isError = !1) {
    let serverListContainer = document.querySelector("#rbx-public-game-server-item-container");
    if (!serverListContainer) return;
    serverListContainer.innerHTML = "", document.getElementById("rovalra-load-more-btn")?.remove();
    let listItem = document.createElement("li");
    listItem.style.width = "100%", listItem.style.textAlign = "center", listItem.style.padding = "40px 10px", listItem.style.listStyleType = "none", listItem.className = "rbx-public-game-server-item";
    let textEl = document.createElement("div");
    textEl.textContent = message, textEl.className = isError ? "text-error" : "text-secondary", textEl.style.fontSize = "16px", textEl.style.fontWeight = "500", listItem.appendChild(textEl), serverListContainer.appendChild(listItem);
  }
  __name(displayMessageInContainer, "displayMessageInContainer");

  // src/content/features/games/serverlist/recentservers.js
  var isRenderingRecentServers = !1;
  function formatTimeAgo(timestamp) {
    let now = Date.now(), secondsPast = Math.floor((now - timestamp) / 1e3);
    return secondsPast < 60 ? `${secondsPast}s ago` : secondsPast < 3600 ? `${Math.floor(secondsPast / 60)}m ago` : secondsPast <= 86400 ? `${Math.floor(secondsPast / 3600)}h ago` : `${Math.floor(secondsPast / 86400)}d ago`;
  }
  __name(formatTimeAgo, "formatTimeAgo");
  function createServerItem(serverData, userThumbnailUrl, userId) {
    let { presence, timestamp } = serverData, serverItem = document.createElement("li");
    serverItem.className = "rbx-game-server-item", serverItem.dataset.rovalraServerid = presence.gameId, serverItem.dataset.placeid = presence.rootPlaceId;
    let lastJoinedInfo = timestamp ? `<p class="text-info" style="font-size: 12px; margin-top: 4px;">Last Joined: ${formatTimeAgo(
      timestamp
    )}</p>` : "", avatarHtml = '<a class="avatar-card-link" style="display: none;"></a>';
    userThumbnailUrl && userId && (avatarHtml = `
            <a class="avatar-card-link" href="https://www.roblox.com/users/${userId}/profile">
                <span class="avatar avatar-headshot-md player-avatar">
                    <span class="thumbnail-2d-container avatar-card-image" style="width: 60px; height: 60px;">
                        <img src="${userThumbnailUrl}" alt="Me" style="width: 60px; height: 60px; border-radius: 50%;">
                    </span>
                </span>
            </a>`);
    let serverContent = `
        <div class="card-content" style="display: flex; flex-direction: column;">
            <div class="player-thumbnails-container" style="align-self: center; margin-bottom: 20px;">
                ${avatarHtml}
            </div>
            <div class="rbx-game-server-details">
                ${lastJoinedInfo}
            </div>
        </div>
    `;
    serverItem.innerHTML = purify.sanitize(serverContent);
    let detailsDiv = serverItem.querySelector(".rbx-game-server-details");
    if (detailsDiv) {
      let joinBtn = document.createElement("button");
      joinBtn.className = "btn-full-width btn-control-xs rbx-public-game-server-join game-server-join-btn btn-primary-md btn-min-width", joinBtn.textContent = "Join", joinBtn.onclick = () => launchGame(presence.rootPlaceId, presence.gameId), detailsDiv.appendChild(joinBtn);
    }
    return serverItem;
  }
  __name(createServerItem, "createServerItem");
  async function checkServerIsActive(placeId, gameId) {
    try {
      let info = await callRobloxApiJson({
        subdomain: "gamejoin",
        endpoint: "/v1/join-game-instance",
        method: "POST",
        body: { placeId: parseInt(placeId, 10), gameId, isTeleport: !1, gameJoinAttemptId: createUUID() },
        noCache: !0
      });
      return !!(info.jobId || info.joinScript || info.status === 2 || info.queuePosition && info.queuePosition > 0);
    } catch {
      return !1;
    }
  }
  __name(checkServerIsActive, "checkServerIsActive");
  function initRecentServers() {
    chrome.storage.local.get({ recentServersEnabled: !0 }, (settings) => {
      if (!settings.recentServersEnabled) return;
      let inject = /* @__PURE__ */ __name(() => {
        let container = document.querySelector("#roseal-running-game-instances-container") || document.querySelector("#running-game-instances-container");
        if (!container) return;
        let section = container.querySelector("#rbx-recent-running-games-rovalra");
        if (!section) {
          section = document.createElement("div"), section.id = "rbx-recent-running-games-rovalra", section.className = "server-list-section";
          let content = `
                <div class="container-header">
                    <div class="server-list-container-header">
                        <h2 class="server-list-header">Recent Servers</h2>
                        <button type="button" class="btn-more rbx-refresh refresh-link-icon btn-control-xs btn-min-width">Refresh</button>
                    </div>
                </div>
                <div class="rbx-recent-servers-grid">
                    <div class="section-content-off empty-game-instances-container">
                        <p class="no-servers-message">No Recent Servers Found.</p>
                    </div>
                </div>
            `;
          section.innerHTML = purify.sanitize(content);
          let friendsSection = container.querySelector("#rbx-friends-running-games"), publicSection = container.querySelector("#rbx-public-running-games");
          friendsSection ? friendsSection.before(section) : publicSection ? publicSection.before(section) : container.appendChild(section);
          let refreshButton = section.querySelector(".rbx-refresh");
          refreshButton && refreshButton.addEventListener("click", () => renderRecentServers(section));
        }
        renderRecentServers(section);
      }, "inject");
      observeElement("#running-game-instances-container, #roseal-running-game-instances-container", () => {
        inject();
      }), observeElement("#rbx-friends-running-games", (friendsSection) => {
        let section = document.getElementById("rbx-recent-running-games-rovalra");
        section && friendsSection.before(section);
      }), observeElement("#rbx-recent-running-games-rovalra", () => {
      }, {
        onRemove: /* @__PURE__ */ __name(() => {
          setTimeout(() => {
            let container = document.querySelector("#roseal-running-game-instances-container") || document.querySelector("#running-game-instances-container");
            container && !container.querySelector("#rbx-recent-running-games-rovalra") && inject();
          }, 500);
        }, "onRemove")
      }), chrome.runtime.onMessage.addListener((request) => {
        if (request.action === "presenceUpdate") {
          let section = document.querySelector("#rbx-recent-running-games-rovalra");
          section && document.body.contains(section) && renderRecentServers(section);
        }
      });
    });
  }
  __name(initRecentServers, "initRecentServers");
  async function renderRecentServers(section) {
    if (!isRenderingRecentServers) {
      isRenderingRecentServers = !0;
      try {
        let placeId = getPlaceIdFromUrl();
        if (!placeId)
          return;
        let gridContainer = section.querySelector(".rbx-recent-servers-grid");
        gridContainer || (gridContainer = document.createElement("div"), gridContainer.className = "rbx-recent-servers-grid", section.appendChild(gridContainer)), gridContainer.innerHTML = "", section.querySelectorAll(":scope > .section-content, :scope > .section-content-off").forEach((el2) => el2.remove());
        let spinnerSection = document.createElement("div");
        spinnerSection.className = "section-content", spinnerSection.innerHTML = '<div class="spinner spinner-default"></div>', gridContainer.appendChild(spinnerSection);
        let [settings, userId] = await Promise.all([
          new Promise((resolve) => chrome.storage.local.get(["ServerlistmodificationsEnabled"], resolve)),
          getAuthenticatedUserId()
        ]), userThumbnailUrl = null;
        if (userId)
          try {
            let thumb = (await fetchThumbnails([{ id: userId }], "AvatarHeadshot", "150x150", !0)).get(userId);
            thumb && thumb.state === "Completed" && (userThumbnailUrl = thumb.imageUrl);
          } catch (e) {
            console.warn("Recent Servers: Failed to fetch user thumbnail", e);
          }
        let serverListModificationsEnabled = settings.ServerlistmodificationsEnabled !== !1, gameHistory = ((await new Promise((resolve) => chrome.storage.local.get({ rovalra_server_history: {} }, resolve))).rovalra_server_history || {})[placeId] || [];
        if (spinnerSection.remove(), gameHistory.length === 0) {
          let noServers = document.createElement("div");
          noServers.className = "section-content-off empty-game-instances-container", noServers.innerHTML = '<p class="no-servers-message">No Recent Servers Found.</p>', gridContainer.appendChild(noServers);
          return;
        }
        let activityStatus = await Promise.all(
          gameHistory.map((serverData) => checkServerIsActive(placeId, serverData.presence.gameId))
        ), activeServers = gameHistory.filter((_2, index) => activityStatus[index]);
        if (activeServers.length === 0) {
          let noActive = document.createElement("div");
          noActive.className = "section-content-off empty-game-instances-container", noActive.innerHTML = '<p class="no-servers-message">No active recent servers found.</p>', gridContainer.appendChild(noActive);
          return;
        }
        activeServers.sort((a, b2) => b2.timestamp - a.timestamp), gridContainer.style.display = "flex", gridContainer.style.flexWrap = "wrap", gridContainer.style.width = "100%", gridContainer.style.gap = "16px";
        let context = { ..._state, processUptimeBatch };
        activeServers.forEach((serverData) => {
          if (serverData.presence && serverData.presence.gameId) {
            let contentSection = document.createElement("div");
            contentSection.className = "section-content", contentSection.style.width = "23%", contentSection.style.padding = "12px", contentSection.style.boxSizing = "border-box";
            let serverList = document.createElement("ul");
            serverList.className = "rbx-game-server-item-container", contentSection.appendChild(serverList);
            let serverItem = createServerItem(serverData, userThumbnailUrl, userId);
            serverList.appendChild(serverItem), gridContainer.appendChild(contentSection);
            let obsReq = observeElement(`li[data-rovalra-serverid="${serverData.presence.gameId}"]`, () => {
            }, {
              onRemove: /* @__PURE__ */ __name(() => {
                if (serverList.children.length === 0 && (contentSection.remove(), gridContainer.children.length === 0)) {
                  let noActive = document.createElement("div");
                  noActive.className = "section-content-off empty-game-instances-container", noActive.innerHTML = '<p class="no-servers-message">No active recent servers found.</p>', gridContainer.appendChild(noActive);
                }
                obsReq && (obsReq.active = !1);
              }, "onRemove")
            });
            serverListModificationsEnabled && enhanceServer(serverItem, context).catch((e) => console.error("Error enhancing recent server:", e));
          }
        }), processUptimeBatch && setTimeout(() => processUptimeBatch(), 150);
      } finally {
        isRenderingRecentServers = !1;
      }
    }
  }
  __name(renderRecentServers, "renderRecentServers");

  // src/content/features/games/RegionPlayButton.js
  var targetContainerIdSelector = "#game-details-play-button-container", playButtonSelector = 'button[data-testid="play-button"]', buttonToHideSelector = "button.random-server-join-button", NEW_BUTTON_ID = "rovalra-join-preferred-region", NEW_BUTTON_ARIA_LABEL = "Select or Join Preferred Server Region", NEW_BUTTON_WIDTH = 64, NEW_BUTTON_HEIGHT = 60, NEW_BUTTON_MARGIN_LEFT = 5, ROVALRA_BUTTON_CLASS = "rovalra-region-button", REGIONS4 = {}, isRegionsLoaded = !1;
  function getPlaceId() {
    let match = window.location.href.match(/\/games\/(\d+)/);
    return match ? match[1] : null;
  }
  __name(getPlaceId, "getPlaceId");
  function getUniverseId2() {
    let meta = document.querySelector('meta[name="universe-id"]');
    return meta ? meta.getAttribute("data-universe-id") : null;
  }
  __name(getUniverseId2, "getUniverseId");
  function createGlobeSVG() {
    let svg2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    return svg2.setAttribute("width", "30"), svg2.setAttribute("height", "30"), svg2.setAttribute("viewBox", "0 0 24 24"), svg2.setAttribute("fill", "none"), svg2.innerHTML = '<path d="M19.3 16.9c.4-.7.7-1.5.7-2.4 0-2.5-2-4.5-4.5-4.5S11 12 11 14.5s2 4.5 4.5 4.5c.9 0 1.7-.3 2.4-.7l3.2 3.2 1.4-1.4zm-3.8.1c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5M12 20v2C6.48 22 2 17.52 2 12S6.48 2 12 2c4.84 0 8.87 3.44 9.8 8h-2.07c-.64-2.46-2.4-4.47-4.73-5.41V5c0 1.1-.9 2-2 2h-2v2c0 .55-.45 1-1 1H8v2h2v3H9l-4.79-4.79C4.08 10.79 4 11.38 4 12c0 4.41 3.59 8 8 8"></path>', svg2;
  }
  __name(createGlobeSVG, "createGlobeSVG");
  function getFullLocationName2(regionCode) {
    if (!regionCode || regionCode === "AUTO") return "Best Region (Auto)";
    let regionData = REGIONS4[regionCode];
    if (!regionData) {
      if (regionCode.startsWith("US-")) {
        let parts2 = regionCode.split("-");
        return parts2.length === 3 ? `${parts2[2]}, ${parts2[1]}, USA` : `${parts2[1]}, USA`;
      }
      return regionCode;
    }
    let parts = [];
    return regionData.city && regionData.city !== regionData.country && parts.push(regionData.city), regionData.state && regionData.country === "United States" && parts.push(regionData.state), regionData.country && parts.push(regionData.country), parts = [...new Set(parts.filter((p) => p))], parts.length > 1 && parts[parts.length - 1] === "United States" && (parts[parts.length - 1] = "USA"), parts.join(", ") || regionCode;
  }
  __name(getFullLocationName2, "getFullLocationName");
  async function loadRegionsForTooltip() {
    if (!isRegionsLoaded)
      return new Promise((resolve) => {
        chrome.storage.local.get(["cachedRegions"], (result) => {
          result.cachedRegions && (REGIONS4 = result.cachedRegions), isRegionsLoaded = !0, resolve();
        });
      });
  }
  __name(loadRegionsForTooltip, "loadRegionsForTooltip");
  function injectCustomCSS() {
    let styleId = "rovalra-custom-ui-styles";
    if (document.getElementById(styleId)) return;
    let css = `
        .${ROVALRA_BUTTON_CLASS} {
            position: relative; overflow: visible;
            width: ${NEW_BUTTON_WIDTH}px !important; height: ${NEW_BUTTON_HEIGHT}px !important;
            margin-left: ${NEW_BUTTON_MARGIN_LEFT}px !important; 
            padding: 0 !important; display: flex !important; align-items: center !important;
            justify-content: center !important; flex-shrink: 0 !important; visibility: visible !important;
            opacity: 1 !important; border: none !important;
            background-color: var(--rovalra-playbutton-color) !important; color: white !important;
            cursor: pointer; border-radius: 12px;
            transition: background-color 0.2s;
            order: 5 !important;
        }
        .${ROVALRA_BUTTON_CLASS}:hover {
            background-color: var(--rovalra-playbutton-color) !important;
        }
        .${ROVALRA_BUTTON_CLASS} svg path { 
            fill: white !important; 
            stroke: none !important;
        }
    `, style = document.createElement("style");
    style.id = styleId, style.textContent = css, document.head.appendChild(style);
  }
  __name(injectCustomCSS, "injectCustomCSS");
  async function updateButtonTooltip(button) {
    try {
      await loadRegionsForTooltip();
      let savedRegion = await getSavedPreferredRegion(), tooltipText;
      !savedRegion || savedRegion === "AUTO" ? tooltipText = "Join Preferred Region<br><b>Best Region (Auto)</b>" : tooltipText = `Join Preferred Region<br><b>${getFullLocationName2(savedRegion)}</b>`, addTooltip(button, purify.sanitize(tooltipText), { position: "top" });
    } catch {
      addTooltip(button, "Join Preferred Region", { position: "top" });
    }
  }
  __name(updateButtonTooltip, "updateButtonTooltip");
  function reconcileButtons(container) {
    if (!container) return;
    let randomButton = container.querySelector(buttonToHideSelector);
    if (!randomButton) return;
    let playButton = container.querySelector(playButtonSelector);
    Array.from(container.children).filter((child) => child === playButton || child.contains(playButton) || child === randomButton || child.id === NEW_BUTTON_ID || child.classList.contains(ROVALRA_BUTTON_CLASS) || child.id === "id-verification-container" || window.getComputedStyle(child).display === "none" ? !1 : !!(child.tagName === "BUTTON" || child.querySelector("button"))).length > 0 ? randomButton.style.display !== "none" && (Object.assign(randomButton.style, { display: "none", width: "0", minWidth: "0", padding: "0", margin: "0", border: "none", visibility: "hidden" }), randomButton.setAttribute("aria-hidden", "true")) : randomButton.style.display === "none" && (randomButton.style.display = "", randomButton.style.width = "", randomButton.style.minWidth = "", randomButton.style.padding = "", randomButton.style.margin = "", randomButton.style.border = "", randomButton.style.visibility = "", randomButton.removeAttribute("aria-hidden"));
  }
  __name(reconcileButtons, "reconcileButtons");
  function addCustomButton(container) {
    if (!container || container.querySelector(`.${ROVALRA_BUTTON_CLASS}`) || document.getElementById(NEW_BUTTON_ID) || !container.querySelector(playButtonSelector)) return !1;
    try {
      let s = window.getComputedStyle(container);
      s.display !== "flex" && (container.style.display = "flex"), s.flexDirection !== "row" && (container.style.flexDirection = "row");
    } catch {
    }
    let newButton = document.createElement("button");
    return newButton.type = "button", newButton.id = NEW_BUTTON_ID, newButton.className = `btn-primary-md ${ROVALRA_BUTTON_CLASS}`, newButton.setAttribute("aria-label", NEW_BUTTON_ARIA_LABEL), newButton.appendChild(createGlobeSVG()), container.appendChild(newButton), addTooltip(newButton, "Join Preferred Region", { position: "top" }), updateButtonTooltip(newButton), newButton.addEventListener("click", async (event) => {
      event.stopPropagation();
      let currentRegion = await getSavedPreferredRegion(), placeId = getPlaceId(), universeId = getUniverseId2();
      placeId && performJoinAction(placeId, universeId, currentRegion === "AUTO" ? null : currentRegion);
    }), !0;
  }
  __name(addCustomButton, "addCustomButton");
  function processContainer(container) {
    addCustomButton(container), reconcileButtons(container);
  }
  __name(processContainer, "processContainer");
  function init27() {
    chrome.storage.local.get({ PreferredRegionEnabled: !0 }, (settings) => {
      settings.PreferredRegionEnabled && (injectCustomCSS(), observeElement(targetContainerIdSelector, (container) => {
        processContainer(container);
      }), observeElement(`${targetContainerIdSelector} button`, (button) => {
        let container = button.closest(targetContainerIdSelector);
        container && processContainer(container);
      }, { multiple: !0 }));
    });
  }
  __name(init27, "init");

  // src/content/core/ui/games/tab.js
  function createTab({ id, label, container, contentContainer, hash }) {
    let tab = document.createElement("li");
    tab.id = `tab-${id}`, tab.className = `rbx-tab tab-${id}`, tab.innerHTML = `<a class="rbx-tab-heading"><span class="text-lead">${label}</span></a>`;
    let contentPane = document.createElement("div");
    contentPane.className = "tab-pane", contentPane.id = `${id}-content-pane`;
    let init54 = /* @__PURE__ */ __name(() => {
      container.appendChild(tab), contentContainer.appendChild(contentPane);
      let otherPanes = contentContainer.querySelectorAll(".tab-pane");
      Array.from(otherPanes).some((pane) => {
        if (pane === contentPane) return !1;
        let bgColor = window.getComputedStyle(pane).backgroundColor;
        return bgColor && bgColor !== "rgba(0, 0, 0, 0)" && bgColor !== "transparent";
      }) && (contentPane.style.backgroundColor = "var(--rovalra-container-background-color)"), container.style.display = "flex", container.style.flexWrap = "nowrap", observeElement("#horizontal-tabs .rbx-tab", (tab2) => {
        tab2.style.width = "auto", tab2.style.flex = "1 1 auto", tab2.style.float = "none", tab2.style.minWidth = "0";
      }, { multiple: !0 }), tab.addEventListener("click", (e) => {
        e.preventDefault(), document.querySelectorAll(".rbx-tab.active, .tab-pane.active").forEach((el2) => el2.classList.remove("active")), tab.classList.add("active"), contentPane.classList.add("active"), hash && window.location.hash !== hash && (window.location.hash = hash);
      }), hash && window.location.hash === hash && setTimeout(() => tab.click(), 200);
    }, "init");
    return document.readyState === "complete" ? init54() : window.addEventListener("load", init54, { once: !0 }), { tab, contentPane };
  }
  __name(createTab, "createTab");

  // src/content/features/games/tab/Subplaces.js
  var PAGE_SIZE = 12;
  async function init28() {
    chrome.storage.local.get(["subplacesEnabled"], async (result) => {
      if (result.subplacesEnabled) {
        let fetchUniverseId2 = /* @__PURE__ */ __name(async (placeId) => {
          let response = await callRobloxApi({
            subdomain: "games",
            endpoint: `/v1/games/multiget-place-details?placeIds=${placeId}`,
            method: "GET"
          });
          if (!response.ok)
            throw new Error(`Failed to fetch universe ID: ${response.status}`);
          let data = await response.json();
          if (data?.[0]?.universeId)
            return data[0].universeId;
          throw new Error("Universe ID not found in the API response.");
        }, "fetchUniverseId"), fetchUniverseDetails = /* @__PURE__ */ __name(async (universeId) => {
          let response = await callRobloxApi({
            subdomain: "games",
            endpoint: `/v1/games?universeIds=${universeId}`,
            method: "GET"
          });
          if (!response.ok)
            throw new Error(`Failed to fetch universe details: ${response.status}`);
          let data = await response.json();
          if (data?.data?.[0])
            return data.data[0];
          throw new Error("Universe details not found in the API response.");
        }, "fetchUniverseDetails"), checkSubplaceJoinability = /* @__PURE__ */ __name(async (placeId) => {
          try {
            let attemptId = self.crypto.randomUUID(), response = await callRobloxApi({
              subdomain: "gamejoin",
              endpoint: "/v1/join-game",
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                placeId: parseInt(placeId, 10),
                gameJoinAttemptId: attemptId
              })
            });
            return response.ok ? await response.json() : null;
          } catch {
            return null;
          }
        }, "checkSubplaceJoinability"), fetchAllSubplaces = /* @__PURE__ */ __name(async (universeId) => {
          let allSubplaces = [], nextCursor = "";
          do {
            let retryCount = 0, success = !1;
            for (; retryCount < 3 && !success; )
              try {
                let endpoint = nextCursor ? `/v2/universes/${universeId}/places?limit=100&cursor=${nextCursor}` : `/v2/universes/${universeId}/places?limit=100`, response = await callRobloxApi({
                  subdomain: "develop",
                  endpoint,
                  method: "GET"
                });
                if (!response.ok) {
                  if (response.status === 429) {
                    let delay = Math.pow(2, retryCount) * 1e3;
                    await new Promise((resolve) => setTimeout(resolve, delay)), retryCount++;
                    continue;
                  }
                  throw new Error(`HTTP error! status: ${response.status}`);
                }
                let data = await response.json();
                data?.data && allSubplaces.push(...data.data), nextCursor = data?.nextPageCursor || "", success = !0;
              } catch {
                if (retryCount++, retryCount >= 3)
                  return allSubplaces;
                await new Promise((resolve) => setTimeout(resolve, 2e3 * retryCount));
              }
          } while (nextCursor);
          return allSubplaces.sort((a, b2) => a.isRootPlace && !b2.isRootPlace ? -1 : !a.isRootPlace && b2.isRootPlace ? 1 : 0), allSubplaces;
        }, "fetchAllSubplaces"), fetchThumbnails2 = /* @__PURE__ */ __name(async (gamesToDisplay) => {
          if (gamesToDisplay.length === 0) return /* @__PURE__ */ new Map();
          try {
            return await fetchThumbnails(gamesToDisplay, "PlaceIcon", "150x150");
          } catch {
            return /* @__PURE__ */ new Map();
          }
        }, "fetchThumbnails"), createSubplacesTab = /* @__PURE__ */ __name((subplaces, horizontalTabs, contentSection) => {
          let displayedCount = 0, allDisplayed = !1, { contentPane: subplacesContentDiv } = createTab({
            id: "subplaces",
            label: "Subplaces",
            container: horizontalTabs,
            contentContainer: contentSection,
            hash: "#!/subplaces"
          }), searchWrapper = document.createElement("div");
          searchWrapper.className = "rovalra-subplaces-search-wrapper";
          let searchInputComponent = createStyledInput({
            id: "rovalra-subplaces-search",
            label: "Search subplaces",
            placeholder: " "
          });
          searchWrapper.appendChild(searchInputComponent.container);
          let searchInput = searchInputComponent.input, subplacesContainer = document.createElement("div");
          subplacesContainer.className = "rovalra-subplaces-list";
          let loadMoreWrapper = document.createElement("div");
          loadMoreWrapper.className = "rovalra-load-more-wrapper";
          let loadMoreButton = document.createElement("button");
          loadMoreButton.textContent = "Load More", loadMoreButton.className = "rovalra-load-more-btn btn-control-md", loadMoreWrapper.appendChild(loadMoreButton), subplacesContentDiv.append(searchWrapper, subplacesContainer, loadMoreWrapper);
          let displaySubplaces = /* @__PURE__ */ __name(async (gamesToDisplay) => {
            let thumbnails = await fetchThumbnails2(gamesToDisplay);
            gamesToDisplay.forEach((subplace) => {
              let gameData = {
                id: subplace.id,
                name: subplace.name,
                rootPlaceId: subplace.id
              }, card = createGameCard({
                game: gameData,
                stats: { thumbnails },
                showVotes: !1,
                showPlayers: !1
              });
              card.classList.add("rovalra-subplace-card", "game-card-container");
              let nameEl = card.querySelector(".game-card-name");
              if (nameEl && (nameEl.dataset.fullName = subplace.name), subplace.isRootPlace) {
                let rootLabel = document.createElement("p");
                rootLabel.textContent = "Root Place", rootLabel.className = "root-place-label";
                let link = card.querySelector(".game-card-link");
                link && link.appendChild(rootLabel);
              }
              subplacesContainer.appendChild(card);
            });
          }, "displaySubplaces"), loadMore = /* @__PURE__ */ __name(async () => {
            let toLoad = subplaces.slice(displayedCount, displayedCount + PAGE_SIZE);
            toLoad.length > 0 && (await displaySubplaces(toLoad), displayedCount += toLoad.length), displayedCount >= subplaces.length && (allDisplayed = !0, loadMoreWrapper.style.display = "none");
          }, "loadMore");
          subplaces.length === 0 ? (subplacesContainer.innerHTML = '<p style="grid-column: 1 / -1;">No subplaces found.</p>', loadMoreWrapper.style.display = "none") : (loadMore(), subplaces.length > PAGE_SIZE && (loadMoreButton.style.display = "block", loadMoreButton.addEventListener("click", loadMore))), searchInput.addEventListener("input", async () => {
            let term = searchInput.value.trim().toLowerCase();
            if (term && !allDisplayed)
              for (; !allDisplayed; )
                await loadMore();
            subplacesContainer.querySelectorAll(".rovalra-subplace-card").forEach((c) => {
              let name = c.querySelector(".game-card-name")?.dataset.fullName?.toLowerCase() || "";
              c.style.display = name.includes(term) ? "" : "none";
            }), loadMoreWrapper.style.display = term || allDisplayed ? "none" : "flex";
          });
        }, "createSubplacesTab"), initializeSubplacesFeature = /* @__PURE__ */ __name(async (tabContainer) => {
          if (tabContainer.dataset.rovalraSubplacesInitialized === "true")
            return;
          tabContainer.dataset.rovalraSubplacesInitialized = "true";
          let placeId = getPlaceIdFromUrl();
          if (!placeId)
            return;
          let contentSection = document.querySelector(".tab-content.rbx-tab-content");
          if (contentSection) {
            document.querySelector(".tab-subplaces")?.remove(), document.getElementById("subplaces-content-pane")?.remove();
            try {
              let universeId = await fetchUniverseId2(placeId);
              if (universeId) {
                let subplaces = await fetchAllSubplaces(universeId), universeDetails = await fetchUniverseDetails(universeId);
                if (universeDetails && universeDetails.rootPlaceId && universeDetails.rootPlaceId.toString() !== placeId) {
                  let rootPlaceData = subplaces.find((p) => p.isRootPlace), rootPlaceName = purify.sanitize(rootPlaceData ? rootPlaceData.name : "the main experience"), rootPlaceId = universeDetails.rootPlaceId, joinData = await checkSubplaceJoinability(placeId), bannerTitle = `You are currently viewing a subplace of [${rootPlaceName}](https://www.roblox.com/games/${rootPlaceId}).`, bannerDescription = "Some experiences may disable joining subplaces.";
                  joinData && joinData.status === 12 && (bannerDescription = "This subplace cannot be joined due to join restrictions."), joinData && joinData.status === 2 && (bannerDescription = "This subplace can be joined.");
                  let checkBannerInterval = setInterval(() => {
                    window.GameBannerManager && (clearInterval(checkBannerInterval), window.GameBannerManager.addNotice(bannerTitle, '<svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1phnduy" focusable="false" aria-hidden="true" viewBox="0 0 24 24"><path d="M13 22h8v-7h-3v-4h-5V9h3V2H8v7h3v2H6v4H3v7h8v-7H8v-2h8v2h-3z"></path></svg>', bannerDescription));
                  }, 200);
                }
                createSubplacesTab(subplaces, tabContainer, contentSection);
              }
            } catch {
              tabContainer.dataset.rovalraSubplacesInitialized = "false";
            }
          }
        }, "initializeSubplacesFeature");
        observeElement && typeof observeElement == "function" && observeElement(
          "#horizontal-tabs",
          (tabContainer) => initializeSubplacesFeature(tabContainer),
          { onRemove: /* @__PURE__ */ __name(() => {
            let oldTabContainer = document.querySelector("[data-rovalra-subplaces-initialized]");
            oldTabContainer && (oldTabContainer.dataset.rovalraSubplacesInitialized = "false");
          }, "onTabContainerRemoved") }
        );
      }
    });
  }
  __name(init28, "init");

  // src/content/features/games/thumbnails/gametrailers.js
  function injectVideoStyles() {
    let styleId = "rovalra-video-styles";
    if (document.getElementById(styleId)) return;
    let style = document.createElement("style");
    style.id = styleId, style.textContent = `
        .carousel-item.carousel-video > *:not(#rovalra-trailer-video) {
            display: none !important;
            opacity: 0 !important;
            visibility: hidden !important;
        }
        
        #rovalra-trailer-video {
            background: #000;
        }
    `;
    let target = document.head || document.documentElement;
    target && target.appendChild(style);
  }
  __name(injectVideoStyles, "injectVideoStyles");
  function setupTrailerVideo(targetItem, videoId, assetType, carouselContainer, shouldAutoplay) {
    let lastUserInteraction = 0, registerInteraction = /* @__PURE__ */ __name(() => {
      lastUserInteraction = Date.now();
    }, "registerInteraction"), attachNavListeners = /* @__PURE__ */ __name(() => {
      carouselContainer.querySelectorAll(".carousel-controls, .carousel-indicators li").forEach((btn) => btn.addEventListener("click", registerInteraction, !0));
    }, "attachNavListeners");
    attachNavListeners(), observeElement(".carousel-controls-container", () => attachNavListeners());
    let videoElement = document.createElement("video");
    videoElement.id = "rovalra-trailer-video", videoElement.autoplay = shouldAutoplay, videoElement.loop = !1, videoElement.muted = !0, videoElement.playsInline = !0, videoElement.controls = !0, videoElement.style.cssText = `
        width: 100%; height: 100%; border: 0; background: #000;
        object-fit: contain; position: absolute; top: 0; left: 0; z-index: 10;
        display: block;
    `, videoElement.addEventListener("click", (e) => e.stopPropagation()), targetItem.classList.add("carousel-video"), targetItem.appendChild(videoElement);
    let wasActive = !1, enforceLoop = /* @__PURE__ */ __name(() => {
      targetItem && !targetItem.contains(videoElement) && targetItem.appendChild(videoElement), targetItem && !targetItem.classList.contains("carousel-video") && targetItem.classList.add("carousel-video");
      let isPlaying = !videoElement.paused && !videoElement.ended && videoElement.readyState > 2, userJustClicked = Date.now() - lastUserInteraction < 800;
      if (isPlaying && !userJustClicked) {
        targetItem.classList.contains("carousel-item-active") || targetItem.classList.add("carousel-item-active"), targetItem.classList.contains("carousel-item-active-out") && targetItem.classList.remove("carousel-item-active-out"), targetItem.classList.contains("carousel-item-left") && targetItem.classList.remove("carousel-item-left"), targetItem.classList.contains("carousel-item-right") && targetItem.classList.remove("carousel-item-right");
        let siblings = carouselContainer.querySelectorAll(".carousel-item");
        for (let sib of siblings)
          sib !== targetItem && (sib.classList.contains("carousel-item-active") && sib.classList.remove("carousel-item-active"), sib.classList.contains("carousel-item-next") && sib.classList.remove("carousel-item-next"), sib.classList.contains("carousel-item-prev") && sib.classList.remove("carousel-item-prev"));
      }
      let isActive = targetItem.classList.contains("carousel-item-active"), isNext = targetItem.classList.contains("carousel-item-next"), isPrev = targetItem.classList.contains("carousel-item-prev"), isSliding = targetItem.classList.contains("carousel-item-left") || targetItem.classList.contains("carousel-item-right"), currentlyVisible = isActive || isNext || isPrev || isSliding;
      currentlyVisible ? wasActive || (videoElement.currentTime = 0, shouldAutoplay && videoElement.play().catch(() => {
      })) : videoElement.paused || videoElement.pause(), wasActive = currentlyVisible, requestAnimationFrame(enforceLoop);
    }, "enforceLoop");
    requestAnimationFrame(enforceLoop), (async () => {
      try {
        let fetchAssetData = /* @__PURE__ */ __name(async (type) => await callRobloxApiJson({
          subdomain: "assetdelivery",
          endpoint: "/v1/assets/batch",
          method: "POST",
          body: [{ assetId: videoId, assetType: type, requestId: "0" }]
        }), "fetchAssetData"), data = await fetchAssetData(assetType);
        data && data.length > 0 && data[0].errors && (data = await fetchAssetData(assetType === "Video" ? "GamePreviewVideo" : "Video")), await streamRobloxVideo(data, videoElement, () => {
        });
      } catch (error) {
        console.error("something went wrong with the gametrailers.", error);
      }
    })();
  }
  __name(setupTrailerVideo, "setupTrailerVideo");
  function hijackFirstSlot(videoId, assetType, carouselContainer, shouldAutoplay) {
    injectVideoStyles();
    let runSetup = /* @__PURE__ */ __name(() => {
      if (carouselContainer.dataset.rovalraVideoInjected) return;
      let targetItem = carouselContainer.querySelector(".carousel-item");
      targetItem && (carouselContainer.dataset.rovalraVideoInjected = "true", setupTrailerVideo(targetItem, videoId, assetType, carouselContainer, shouldAutoplay));
    }, "runSetup");
    carouselContainer.querySelector(".carousel-item") ? runSetup() : observeElement('#game-details-carousel-container [data-testid="carousel"] .carousel-item', (item) => {
      carouselContainer.contains(item) && runSetup();
    }, { multiple: !0 });
  }
  __name(hijackFirstSlot, "hijackFirstSlot");
  function init29() {
    chrome.storage.local.get(["EnableGameTrailer", "Enableautoplay"], (result) => {
      if (result && result.EnableGameTrailer === !0) {
        let shouldAutoplay = result.Enableautoplay === !0;
        document.addEventListener("rovalra-game-media-response", (event) => {
          let videoAsset = event.detail?.data?.find(
            (item) => (item.assetType === "Video" || item.assetType === "GamePreviewVideo") && item.approved
          );
          videoAsset && videoAsset.videoId && observeElement('#game-details-carousel-container [data-testid="carousel"]', (carousel) => {
            carousel.dataset.rovalraInjected || (carousel.dataset.rovalraInjected = "true", hijackFirstSlot(videoAsset.videoId, videoAsset.assetType, carousel, shouldAutoplay));
          });
        });
      }
    });
  }
  __name(init29, "init");

  // src/content/core/ui/games/banner.js
  var isInitialized4 = !1;
  function init30() {
    if (isInitialized4) return;
    isInitialized4 = !0, startObserving();
    let BANNER_ID = "rovalra-game-notice-banner", TARGET_PARENT_SELECTOR = "#game-detail-page";
    window.GameBannerManager || (window.GameBannerManager = {
      addNotice: /* @__PURE__ */ __name(function(title, iconHtml = "", description = "") {
        let banner = document.getElementById(BANNER_ID);
        if (!banner) return;
        let fontSize = "20px";
        title.length > 100 ? fontSize = "14px" : title.length > 50 && (fontSize = "16px");
        let parsedTitle = purify.sanitize(parseMarkdown(title)), parsedDescription = purify.sanitize(
          parseMarkdown(description)
        ), entry = document.createElement("div");
        entry.className = "rovalra-game-notice-entry";
        let iconContent = "";
        if (iconHtml) {
          let tempDiv = document.createElement("div");
          tempDiv.innerHTML = purify.sanitize(iconHtml);
          let svgElement = tempDiv.querySelector("svg");
          svgElement && (svgElement.setAttribute("fill", "currentColor"), iconContent = `<div class="rovalra-game-notice-icon">${svgElement.outerHTML}</div>`);
        }
        let textContainer = document.createElement("div");
        textContainer.className = "rovalra-game-notice-text-container";
        let titleDiv = document.createElement("div");
        titleDiv.className = "rovalra-game-notice-title", titleDiv.innerHTML = parsedTitle, titleDiv.style.fontSize = fontSize, titleDiv.style.fontWeight = description ? "600" : "400";
        let mdWrapper = titleDiv.querySelector(".rovalra-markdown");
        if (mdWrapper && (mdWrapper.style.display = "contents"), titleDiv.querySelectorAll("p").forEach((p) => {
          p.style.margin = "0", p.style.padding = "0", p.style.display = "inline", p.style.color = "inherit", p.style.fontWeight = "inherit", p.style.fontSize = "inherit";
        }), textContainer.appendChild(titleDiv), description) {
          let descDiv = document.createElement("div");
          descDiv.className = "rovalra-game-notice-description", descDiv.innerHTML = parsedDescription;
          let descWrapper = descDiv.querySelector(".rovalra-markdown");
          descWrapper && (descWrapper.style.display = "contents"), descDiv.querySelectorAll("p").forEach((p) => {
            p.style.margin = "0", p.style.color = "inherit";
          }), textContainer.appendChild(descDiv);
        }
        entry.innerHTML = iconContent, entry.appendChild(textContainer), banner.appendChild(entry), banner.style.display = "flex";
      }, "addNotice")
    });
    function initializeBannerContainer() {
      if (document.getElementById(BANNER_ID)) return;
      let parent = document.querySelector(TARGET_PARENT_SELECTOR);
      if (parent) {
        let banner = document.createElement("div");
        banner.id = BANNER_ID, parent.prepend(banner);
      }
    }
    __name(initializeBannerContainer, "initializeBannerContainer"), observeElement(TARGET_PARENT_SELECTOR, initializeBannerContainer);
  }
  __name(init30, "init");

  // src/content/features/games/banner.js
  function init31() {
    chrome.storage.local.get({ EnablebannerTest: !1 }, (settings) => {
      if (settings.EnablebannerTest) {
        let checkApi = setInterval(() => {
          window.GameBannerManager && (clearInterval(checkApi), window.GameBannerManager.addNotice(`
Markdown test
# H1
## H2
### H3
**bold**
*italic*
~~strikethrough~~
> Blockquotes are perfect for quoting text.
- wow
 \`inline code\` 

                    `, '<svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1phnduy" focusable="false" aria-hidden="true" viewBox="0 0 24 24" fill="currentColor"><path d="M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5s-.96.06-1.41.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20zm-6 8h-4v-2h4zm0-4h-4v-2h4z"></path></svg>', "This is a test of the markdown rendering system."));
        }, 200);
      }
    });
  }
  __name(init31, "init");

  // src/content/core/ui/general/scrollButtons.js
  function createScrollButtons({ onLeftClick, onRightClick }) {
    let createArrow = /* @__PURE__ */ __name((direction) => {
      let button = document.createElement("div");
      button.setAttribute("data-testid", "carousel-scroll-arrow"), button.className = `scroll-arrow ${direction}`, button.setAttribute("role", "button"), button.tabIndex = 0, button.style.cursor = "pointer";
      let icon = document.createElement("span");
      return icon.className = `icon-chevron-heavy-${direction}`, icon.setAttribute("data-testid", "carousel-scroll-arrow-icon"), button.appendChild(icon), button;
    }, "createArrow"), leftButton = createArrow("left"), rightButton = createArrow("right");
    return onLeftClick && leftButton.addEventListener("click", onLeftClick), onRightClick && rightButton.addEventListener("click", onRightClick), { leftButton, rightButton };
  }
  __name(createScrollButtons, "createScrollButtons");

  // src/content/core/ui/roblox/alert.js
  function showSystemAlert(message, type = "success") {
    let feedbackContainer = document.querySelector(".sg-system-feedback");
    feedbackContainer || (feedbackContainer = document.createElement("div"), feedbackContainer.className = "sg-system-feedback", document.body.appendChild(feedbackContainer));
    let container = document.createElement("div");
    container.className = "alert-system-feedback";
    let alertDiv = document.createElement("div");
    alertDiv.className = `alert alert-${type}`, alertDiv.setAttribute("role", "alert");
    let span = document.createElement("span");
    span.className = "alert-content", span.textContent = message, alertDiv.appendChild(span), container.appendChild(alertDiv), feedbackContainer.appendChild(container), alertDiv.offsetWidth, alertDiv.classList.add("on"), setTimeout(() => {
      alertDiv.classList.remove("on"), setTimeout(() => container.remove(), 300);
    }, 3e3);
  }
  __name(showSystemAlert, "showSystemAlert");

  // src/content/features/games/actions/quickOutfits.js
  async function fetchAllOutfits(userId) {
    let outfits = [], paginationToken = null, hasMore = !0;
    for (; hasMore; ) {
      let url = `https://avatar.roblox.com/v2/avatar/users/${userId}/outfits?outfitType=1&page=1&itemsPerPage=50&isEditable=true`;
      paginationToken && (url += `&paginationToken=${paginationToken}`);
      try {
        let response = await callRobloxApi({
          subdomain: "avatar",
          endpoint: url.replace("https://avatar.roblox.com", "")
        });
        if (!response.ok) break;
        let result = await response.json();
        result.data && (outfits = outfits.concat(result.data)), paginationToken = result.paginationToken, hasMore = !!paginationToken;
      } catch (e) {
        console.warn("Error fetching outfits", e);
        break;
      }
    }
    return outfits;
  }
  __name(fetchAllOutfits, "fetchAllOutfits");
  async function wearOutfit(outfitId) {
    let callWithRetry = /* @__PURE__ */ __name(async (options) => {
      let retries500 = 0;
      for (; ; ) {
        let response = await callRobloxApi(options);
        if (response.ok) return response;
        if (response.status === 429) {
          await new Promise((r) => setTimeout(r, 1e3));
          continue;
        }
        if (response.status >= 500 && retries500 < 3) {
          retries500++, await new Promise((r) => setTimeout(r, 1e3));
          continue;
        }
        return response;
      }
    }, "callWithRetry");
    try {
      let detailsRes = await callWithRetry({
        subdomain: "avatar",
        endpoint: `/v1/outfits/${outfitId}/details`
      });
      if (!detailsRes.ok) return detailsRes;
      let details = await detailsRes.json(), promises = [];
      return details.bodyColors && promises.push(callWithRetry({
        subdomain: "avatar",
        endpoint: "/v1/avatar/set-body-colors",
        method: "POST",
        body: details.bodyColors
      })), details.assets && promises.push(callWithRetry({
        subdomain: "avatar",
        endpoint: "/v2/avatar/set-wearing-assets",
        method: "POST",
        body: { assets: details.assets }
      })), details.playerAvatarType && promises.push(callWithRetry({
        subdomain: "avatar",
        endpoint: "/v1/avatar/set-player-avatar-type",
        method: "POST",
        body: { playerAvatarType: details.playerAvatarType }
      })), details.scale && promises.push(callWithRetry({
        subdomain: "avatar",
        endpoint: "/v1/avatar/set-scales",
        method: "POST",
        body: details.scale
      })), { ok: (await Promise.all(promises)).every((r) => r.ok) };
    } catch (e) {
      return console.error(e), { ok: !1 };
    }
  }
  __name(wearOutfit, "wearOutfit");
  function createOutfitCard(outfit, thumbnailData, onSuccess) {
    let container = document.createElement("div");
    Object.assign(container.style, {
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-start",
      width: "140px",
      height: "190px",
      cursor: "pointer",
      padding: "8px",
      borderRadius: "8px",
      transition: "background-color 0.2s"
    });
    let thumbContainer = document.createElement("div");
    Object.assign(thumbContainer.style, {
      width: "130px",
      height: "130px",
      borderRadius: "8px",
      overflow: "hidden",
      marginBottom: "8px",
      backgroundColor: "var(--rovalra-container-background-color)",
      position: "relative"
    });
    let thumb = createThumbnailElement(thumbnailData, outfit.name, "", { width: "100%", height: "100%", objectFit: "cover" });
    thumbContainer.appendChild(thumb);
    let hoverOverlay = document.createElement("div");
    Object.assign(hoverOverlay.style, {
      position: "absolute",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      pointerEvents: "none",
      transition: "box-shadow 0.5s ease",
      borderRadius: "8px",
      boxShadow: "inset 0 0 0 rgba(0, 0, 0, 0)"
    }), thumbContainer.appendChild(hoverOverlay);
    let name = document.createElement("div");
    return name.textContent = outfit.name, Object.assign(name.style, {
      fontSize: "14px",
      textAlign: "left",
      wordBreak: "break-word",
      lineHeight: "1.2",
      maxHeight: "2.4em",
      overflow: "hidden",
      color: "var(--rovalra-main-text-color)",
      width: "100%"
    }), container.appendChild(thumbContainer), container.appendChild(name), container.addEventListener("mouseenter", () => {
      hoverOverlay.style.boxShadow = "inset 0 0 30px rgba(0, 0, 0, 0.3)", container.style.backgroundColor = "var(rgba(0,0,0,0.05))";
    }), container.addEventListener("mouseleave", () => {
      hoverOverlay.style.boxShadow = "inset 0 0 0 rgba(0,0,0,0)", container.style.backgroundColor = "";
    }), container.onclick = async () => {
      let originalText = name.textContent;
      name.textContent = "Equipping...", name.style.opacity = "0.7";
      try {
        (await wearOutfit(outfit.id)).ok ? (name.textContent = "Equipped!", name.style.color = "#00b06f", onSuccess && onSuccess()) : (name.textContent = "Failed", name.style.color = "#ff4444");
      } catch (e) {
        name.textContent = "Error:", console.error(e), name.style.color = "#ff4444";
      }
      setTimeout(() => {
        name.textContent = originalText, name.style.color = "", name.style.opacity = "";
      }, 2e3);
    }, container;
  }
  __name(createOutfitCard, "createOutfitCard");
  async function showQuickOutfitsOverlay() {
    let userId = await getAuthenticatedUserId();
    if (!userId) {
      console.error("authed user id not found :C for quick outfits");
      return;
    }
    let mainContainer = document.createElement("div");
    Object.assign(mainContainer.style, {
      display: "flex",
      flexDirection: "column"
    });
    let gridContainer = document.createElement("div");
    Object.assign(gridContainer.style, {
      display: "flex",
      flexWrap: "wrap",
      gap: "8px",
      justifyContent: "center",
      padding: "10px",
      alignContent: "flex-start",
      minHeight: "410px",
      maxWidth: "630px",
      width: "100%"
    });
    let paginationContainer = document.createElement("div");
    Object.assign(paginationContainer.style, {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: "10px",
      gap: "15px",
      minHeight: "40px"
    }), mainContainer.appendChild(gridContainer), mainContainer.appendChild(paginationContainer), gridContainer.innerHTML = purify.sanitize('<div style="padding: 20px;">Loading outfits...</div>');
    let resizeObserver, { close } = createOverlay({
      title: "Quick Outfits",
      bodyContent: mainContainer,
      maxWidth: "fit-content",
      maxHeight: "60vh",
      showLogo: !0,
      onClose: /* @__PURE__ */ __name(() => {
        resizeObserver && resizeObserver.disconnect();
      }, "onClose")
    });
    try {
      let outfits = await fetchAllOutfits(userId);
      if (outfits.length === 0) {
        gridContainer.innerHTML = purify.sanitize('<div style="padding: 20px;">No outfits found.</div>');
        return;
      }
      let itemsPerPage = 8, currentPage = 0, totalPages = Math.ceil(outfits.length / itemsPerPage), thumbnailMap = /* @__PURE__ */ new Map(), isFetchingThumbnails = !0, updatePagination = /* @__PURE__ */ __name(() => {
        if (paginationContainer.innerHTML = "", totalPages <= 1) return;
        let { leftButton, rightButton } = createScrollButtons({
          onLeftClick: /* @__PURE__ */ __name(() => {
            currentPage > 0 && (currentPage--, renderPage());
          }, "onLeftClick"),
          onRightClick: /* @__PURE__ */ __name(() => {
            currentPage < totalPages - 1 && (currentPage++, renderPage());
          }, "onRightClick")
        });
        currentPage === 0 && (leftButton.style.opacity = "0.5", leftButton.style.cursor = "default"), currentPage === totalPages - 1 && (rightButton.style.opacity = "0.5", rightButton.style.cursor = "default");
        let pageInfo = document.createElement("span");
        pageInfo.textContent = `${currentPage + 1} / ${totalPages}`, pageInfo.style.color = "var(--rovalra-secondary-text-color)", pageInfo.style.fontWeight = "500", paginationContainer.append(leftButton, pageInfo, rightButton);
      }, "updatePagination"), renderPage = /* @__PURE__ */ __name(() => {
        gridContainer.innerHTML = "";
        let start = currentPage * itemsPerPage, end = start + itemsPerPage;
        outfits.slice(start, end).forEach((outfit) => {
          let thumbData = thumbnailMap.get(outfit.id);
          !thumbData && isFetchingThumbnails && (thumbData = { state: "Pending" });
          let card = createOutfitCard(outfit, thumbData, () => {
            close(), showSystemAlert("Successfully equipped outfit.");
          });
          gridContainer.appendChild(card);
        }), updatePagination();
      }, "renderPage"), calculateItemsPerPage = /* @__PURE__ */ __name(() => {
        let containerWidth = gridContainer.clientWidth;
        if (containerWidth <= 0) return 8;
        let cardWidth = 140, gap = 8, availableWidth = containerWidth - 20, itemsPerRow = Math.floor((availableWidth + gap) / (cardWidth + gap));
        return Math.max(1, itemsPerRow * 2);
      }, "calculateItemsPerPage");
      resizeObserver = new ResizeObserver(() => {
        let newItemsPerPage = calculateItemsPerPage();
        if (newItemsPerPage !== itemsPerPage) {
          let firstVisibleItemIndex = currentPage * itemsPerPage;
          itemsPerPage = newItemsPerPage, totalPages = Math.ceil(outfits.length / itemsPerPage), currentPage = Math.floor(firstVisibleItemIndex / itemsPerPage), currentPage >= totalPages && (currentPage = Math.max(0, totalPages - 1)), renderPage();
        }
      }), resizeObserver.observe(gridContainer), renderPage();
      let outfitIds = outfits.map((o) => ({ id: o.id }));
      thumbnailMap = await fetchThumbnails(outfitIds, "UserOutfit", "150x150"), isFetchingThumbnails = !1, renderPage();
    } catch (e) {
      console.error(e), gridContainer.innerHTML = purify.sanitize('<div style="padding: 20px; color: red;">Error loading outfits.</div>');
    }
  }
  __name(showQuickOutfitsOverlay, "showQuickOutfitsOverlay");
  function addQuickOutfitsButton(container) {
    if (container.querySelector(".rovalra-quick-outfits-btn-container"))
      return;
    let buttonContainer = document.createElement("div");
    buttonContainer.className = "rovalra-quick-outfits-btn-container", buttonContainer.style.marginTop = "12px";
    let button = createButton("", "secondary", { onClick: showQuickOutfitsOverlay });
    button.style.width = "40px", button.style.height = "40px", button.style.minWidth = "40px", button.style.padding = "0", button.style.display = "flex", button.style.alignItems = "center", button.style.justifyContent = "center";
    let svg2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg2.setAttribute("viewBox", "0 0 24 24"), svg2.setAttribute("width", "24"), svg2.setAttribute("height", "24"), svg2.style.fill = "currentColor";
    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", "M21.6 18.2 13 11.75v-.91c1.65-.49 2.8-2.17 2.43-4.05-.26-1.31-1.3-2.4-2.61-2.7C10.54 3.57 8.5 5.3 8.5 7.5h2c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5c0 .84-.69 1.52-1.53 1.5-.54-.01-.97.45-.97.99v1.76L2.4 18.2c-.77.58-.36 1.8.6 1.8h18c.96 0 1.37-1.22.6-1.8M6 18l6-4.5 6 4.5z"), svg2.appendChild(path), button.appendChild(svg2), addTooltip(button, "Quick Outfits"), buttonContainer.appendChild(button);
    let gameButtonsContainer = container.querySelector(".game-buttons-container");
    gameButtonsContainer && container.insertBefore(buttonContainer, gameButtonsContainer);
  }
  __name(addQuickOutfitsButton, "addQuickOutfitsButton");
  function init32() {
    chrome.storage.local.get("QuickOutfitsEnabled", (data) => {
      data.QuickOutfitsEnabled && observeElement(".game-calls-to-action", addQuickOutfitsButton);
    });
  }
  __name(init32, "init");

  // src/content/core/ui/games/devProductsUI.js
  function createDevProductCard({ id, name, price, thumbnail, universeId }) {
    let card = document.createElement("li");
    card.className = "list-item store-card", card.style.margin = "0 8.5px 20px 0";
    let container = document.createElement("div");
    container.className = "store-card-container";
    let link = document.createElement("a");
    link.className = "store-card-link", universeId && (link.href = `https://www.roblox.com/developer-product/${universeId}/product/${id}`);
    let thumbContainer = document.createElement("div");
    thumbContainer.className = "store-card-thumb-container", thumbContainer.style.position = "relative", thumbContainer.style.width = "100%", thumbContainer.style.paddingBottom = "100%";
    let thumb = createThumbnailElement(thumbnail, name, "store-card-thumb");
    thumb.style.position = "absolute", thumb.style.top = "0", thumb.style.left = "0", thumb.style.width = "100%", thumb.style.height = "100%", thumbContainer.appendChild(thumb);
    let details = document.createElement("div");
    details.className = "store-card-caption", details.style.textAlign = "left", details.style.position = "relative", details.style.zIndex = "1";
    let nameDiv = document.createElement("div");
    nameDiv.className = "store-card-name", nameDiv.textContent = name || "Unnamed Product", nameDiv.title = name || "Unnamed Product", nameDiv.style.display = "-webkit-box", nameDiv.style.webkitLineClamp = "2", nameDiv.style.setProperty("-webkit-box-orient", "vertical"), nameDiv.style.overflow = "hidden", nameDiv.style.textAlign = "left", nameDiv.style.minHeight = "2.6em", nameDiv.style.lineHeight = "1.3em";
    let priceContainer = document.createElement("div");
    priceContainer.className = "store-card-price", priceContainer.style.textAlign = "left", priceContainer.style.justifyContent = "flex-start";
    let icon = document.createElement("span");
    icon.className = "icon-robux-16x16";
    let priceSpan = document.createElement("span");
    return priceSpan.className = "text-robux", priceSpan.textContent = price !== null ? price : "Off Sale", priceContainer.appendChild(icon), priceContainer.appendChild(priceSpan), details.appendChild(nameDiv), details.appendChild(priceContainer), link.appendChild(thumbContainer), link.appendChild(details), container.appendChild(link), card.appendChild(container), card;
  }
  __name(createDevProductCard, "createDevProductCard");

  // src/content/features/games/tab/DevProducts.js
  async function fetchUniverseId(placeId) {
    let metaData = document.getElementById("game-detail-meta-data");
    if (metaData && metaData.dataset.universeId)
      return metaData.dataset.universeId;
    try {
      let response = await callRobloxApi({
        subdomain: "games",
        endpoint: `/v1/games/multiget-place-details?placeIds=${placeId}`,
        method: "GET"
      });
      if (!response.ok) throw new Error("Failed to fetch universe ID");
      return (await response.json())?.[0]?.universeId;
    } catch (error) {
      return console.error("RoValra: Error fetching universe ID", error), null;
    }
  }
  __name(fetchUniverseId, "fetchUniverseId");
  async function fetchDevProducts(universeId) {
    let allProducts = [], cursor = null;
    try {
      do {
        let endpoint = `/developer-products/v2/universes/${universeId}/developerproducts?limit=100` + (cursor ? `&cursor=${cursor}` : ""), response = await callRobloxApi({
          subdomain: "apis",
          endpoint,
          method: "GET"
        });
        if (!response.ok) throw new Error("Failed to fetch developer products");
        let data = await response.json();
        data?.developerProducts && (allProducts = allProducts.concat(data.developerProducts)), cursor = data?.nextPageCursor;
      } while (cursor);
      return allProducts;
    } catch (error) {
      return console.error("RoValra: Error fetching developer products", error), allProducts;
    }
  }
  __name(fetchDevProducts, "fetchDevProducts");
  async function loadAndRenderProducts(storeTab, placeId) {
    if (storeTab.dataset.rovalraDevProductsLoaded === "true") return;
    storeTab.dataset.rovalraDevProductsLoaded = "true";
    let universeId = await fetchUniverseId(placeId);
    if (!universeId) return;
    let products = await fetchDevProducts(universeId);
    if (!products || products.length === 0) return;
    let gamePassesContainer = storeTab.querySelector("#roseal-game-passes") || storeTab.querySelector("#rbx-game-passes"), passesList = gamePassesContainer ? gamePassesContainer.querySelector("ul.store-cards") : null, headerContainer = gamePassesContainer ? gamePassesContainer.querySelector(".container-header") : null, noPassesMessage = gamePassesContainer ? gamePassesContainer.querySelector(".section-content-off") : null;
    gamePassesContainer ? (headerContainer || (headerContainer = document.createElement("div"), headerContainer.className = "container-header", gamePassesContainer.prepend(headerContainer)), passesList || (passesList = document.createElement("ul"), passesList.id = "rbx-passes-container", passesList.className = "hlist store-cards gear-passes-container", gamePassesContainer.appendChild(passesList))) : (gamePassesContainer = document.createElement("div"), gamePassesContainer.id = "rbx-game-passes", gamePassesContainer.className = "container-list game-dev-store game-passes", headerContainer = document.createElement("div"), headerContainer.className = "container-header", passesList = document.createElement("ul"), passesList.id = "rbx-passes-container", passesList.className = "hlist store-cards gear-passes-container", gamePassesContainer.appendChild(headerContainer), gamePassesContainer.appendChild(passesList), storeTab.appendChild(gamePassesContainer));
    let devProductsList = document.createElement("ul");
    devProductsList.className = "hlist store-cards rovalra-dev-products-container", devProductsList.style.display = "none";
    let paginationContainer = document.createElement("div");
    paginationContainer.style.display = "none", paginationContainer.style.justifyContent = "center", paginationContainer.style.alignItems = "center", paginationContainer.style.marginTop = "15px", paginationContainer.style.gap = "15px";
    let ITEMS_PER_PAGE = 58, currentPage = 0, currentSortedItems = [], renderId = 0, globalThumbnailMap = /* @__PURE__ */ new Map(), updatePaginationControls = /* @__PURE__ */ __name(() => {
      paginationContainer.innerHTML = "";
      let totalPages = Math.ceil(currentSortedItems.length / ITEMS_PER_PAGE);
      if (totalPages <= 1) return;
      let { leftButton, rightButton } = createScrollButtons({
        onLeftClick: /* @__PURE__ */ __name(() => {
          currentPage > 0 && (currentPage--, renderPage());
        }, "onLeftClick"),
        onRightClick: /* @__PURE__ */ __name(() => {
          currentPage < totalPages - 1 && (currentPage++, renderPage());
        }, "onRightClick")
      });
      currentPage === 0 && (leftButton.style.opacity = "0.5", leftButton.style.cursor = "default"), currentPage >= totalPages - 1 && (rightButton.style.opacity = "0.5", rightButton.style.cursor = "default");
      let pageInfo = document.createElement("span");
      pageInfo.textContent = `${currentPage + 1} / ${totalPages}`, pageInfo.className = "text-secondary", pageInfo.style.fontWeight = "500", paginationContainer.appendChild(leftButton), paginationContainer.appendChild(pageInfo), paginationContainer.appendChild(rightButton);
    }, "updatePaginationControls"), renderPage = /* @__PURE__ */ __name(async () => {
      let currentRenderId = ++renderId;
      devProductsList.innerHTML = "";
      let start = currentPage * ITEMS_PER_PAGE, end = start + ITEMS_PER_PAGE, pageItems = currentSortedItems.slice(start, end), cardMap = /* @__PURE__ */ new Map();
      pageItems.forEach((product) => {
        let hasIcon = product.IconImageAssetId && product.IconImageAssetId > 0, thumbnailData = hasIcon ? { state: "Pending" } : { state: "Broken" };
        hasIcon && globalThumbnailMap.has(product.IconImageAssetId) && (thumbnailData = globalThumbnailMap.get(product.IconImageAssetId));
        let card = createDevProductCard({
          id: product.ProductId,
          name: product.Name,
          price: product.PriceInRobux,
          thumbnail: thumbnailData,
          universeId
        });
        devProductsList.appendChild(card), cardMap.set(product.ProductId, card);
      }), updatePaginationControls();
      let productsToFetch = pageItems.filter(
        (p) => p.IconImageAssetId > 0 && !globalThumbnailMap.has(p.IconImageAssetId)
      );
      if (productsToFetch.length === 0) return;
      let thumbnailMap = await fetchThumbnails(
        productsToFetch.map((p) => ({ id: p.IconImageAssetId })),
        "Asset",
        "150x150"
      );
      currentRenderId === renderId && productsToFetch.forEach((product) => {
        let thumbData = thumbnailMap.get(product.IconImageAssetId), oldCard = cardMap.get(product.ProductId);
        if (thumbData && (globalThumbnailMap.set(product.IconImageAssetId, thumbData), (thumbData.state === "Pending" || thumbData.state === "InReview") && thumbData.finalUpdate && thumbData.finalUpdate.then((finalData) => {
          finalData && globalThumbnailMap.set(product.IconImageAssetId, finalData);
        }), oldCard)) {
          let newCard = createDevProductCard({
            id: product.ProductId,
            name: product.Name,
            price: product.PriceInRobux,
            thumbnail: thumbData,
            universeId
          });
          oldCard.replaceWith(newCard);
        }
      });
    }, "renderPage"), renderProducts = /* @__PURE__ */ __name((items) => {
      currentSortedItems = items, currentPage = 0, renderPage();
    }, "renderProducts");
    gamePassesContainer.appendChild(devProductsList), gamePassesContainer.appendChild(paginationContainer), headerContainer.innerHTML = "";
    let controlsDiv = document.createElement("div");
    controlsDiv.style.display = "flex", controlsDiv.style.gap = "10px", controlsDiv.style.alignItems = "center", controlsDiv.style.marginBottom = "12px";
    let hasPasses = passesList.children.length > 0, currentSortField = "Created", currentSortOrder = "Desc", currentSearchTerm = "", sortProducts = /* @__PURE__ */ __name(() => {
      let items = [...products], trimmedSearch = currentSearchTerm ? currentSearchTerm.trim() : "";
      if (trimmedSearch) {
        let terms = trimmedSearch.toLowerCase().split(/\s+/);
        items = items.filter((p) => {
          let name = (p.Name || "").toLowerCase();
          return terms.every((term) => name.includes(term));
        });
      }
      let sorted = items.sort((a, b2) => {
        let valA, valB;
        switch (currentSortField) {
          case "Price":
            valA = a.PriceInRobux ?? 0, valB = b2.PriceInRobux ?? 0;
            break;
          case "Name":
            valA = (a.Name || "").toLowerCase(), valB = (b2.Name || "").toLowerCase();
            break;
          case "Updated":
            valA = a.Updated ? new Date(a.Updated).getTime() : 0, valB = b2.Updated ? new Date(b2.Updated).getTime() : 0;
            break;
          default:
            valA = a.ProductId ?? 0, valB = b2.ProductId ?? 0;
            break;
        }
        return valA < valB ? currentSortOrder === "Asc" ? -1 : 1 : valA > valB ? currentSortOrder === "Asc" ? 1 : -1 : 0;
      });
      renderProducts(sorted);
    }, "sortProducts"), sortFieldDropdown = createDropdown({
      items: [
        { value: "Created", label: "Sort by Created" },
        { value: "Price", label: "Sort by Price" },
        { value: "Updated", label: "Sort by Updated" },
        { value: "Name", label: "Sort by Name" }
      ],
      initialValue: "Created",
      onValueChange: /* @__PURE__ */ __name((value) => {
        currentSortField = value, sortProducts();
      }, "onValueChange")
    }), sortOrderDropdown = createDropdown({
      items: [
        { value: "Asc", label: "Sort Ascending" },
        { value: "Desc", label: "Sort Descending" }
      ],
      initialValue: "Desc",
      onValueChange: /* @__PURE__ */ __name((value) => {
        currentSortOrder = value, sortProducts();
      }, "onValueChange")
    }), searchInput = createStyledInput({
      id: "rovalra-dev-product-search",
      label: "Search",
      placeholder: " "
    });
    searchInput.container.style.width = "250px", searchInput.input.addEventListener("input", (e) => {
      currentSearchTerm = e.target.value, sortProducts();
    });
    let filterWrapper = document.createElement("div");
    filterWrapper.style.marginBottom = "10px", filterWrapper.style.display = "flex", filterWrapper.style.gap = "10px", filterWrapper.appendChild(searchInput.container), filterWrapper.appendChild(sortFieldDropdown.element), filterWrapper.appendChild(sortOrderDropdown.element);
    let updateTabState = /* @__PURE__ */ __name((isPasses) => {
      let currentRosealFilters = gamePassesContainer.querySelector(".store-item-filters");
      isPasses ? (passesList.style.display = "", currentRosealFilters && (currentRosealFilters.style.display = ""), noPassesMessage && (noPassesMessage.style.display = ""), devProductsList.style.display = "none", paginationContainer.style.display = "none", filterWrapper.style.display = "none") : (passesList.style.display = "none", currentRosealFilters && (currentRosealFilters.style.display = "none"), noPassesMessage && (noPassesMessage.style.display = "none"), devProductsList.style.display = "", paginationContainer.style.display = "flex", filterWrapper.style.display = "flex");
    }, "updateTabState"), toggle = createPillToggle({
      options: [
        { text: "Passes", value: "passes" },
        { text: "Developer Products", value: "devProducts" }
      ],
      initialValue: hasPasses ? "passes" : "devProducts",
      onChange: /* @__PURE__ */ __name((value) => updateTabState(value === "passes"), "onChange")
    });
    updateTabState(hasPasses), controlsDiv.appendChild(toggle), headerContainer.appendChild(controlsDiv), headerContainer.appendChild(filterWrapper), sortProducts();
  }
  __name(loadAndRenderProducts, "loadAndRenderProducts");
  function init33() {
    chrome.storage.local.get({ EnableDevProducts: !0 }, (settings) => {
      settings.EnableDevProducts && observeElement(".tab-pane.store", (storeTab) => {
        let placeId = getPlaceIdFromUrl();
        if (!placeId) return;
        let checkActive = /* @__PURE__ */ __name(() => {
          storeTab.classList.contains("active") && loadAndRenderProducts(storeTab, placeId);
        }, "checkActive");
        checkActive(), observeAttributes(storeTab, (mutation) => {
          mutation.attributeName === "class" && checkActive();
        }, ["class"]);
      });
    });
  }
  __name(init33, "init");

  // src/content/core/ui/time/time.js
  var TIME_FORMAT_KEY = "rovalra_time_format_preference", preferredFormat = "local", FORMATS = ["local", "24h", "relative"];
  chrome.storage.local.get([TIME_FORMAT_KEY], (result) => {
    result[TIME_FORMAT_KEY] && FORMATS.includes(result[TIME_FORMAT_KEY]) && (preferredFormat = result[TIME_FORMAT_KEY]);
  });
  chrome.storage.onChanged.addListener((changes, area) => {
    if (area === "local" && changes[TIME_FORMAT_KEY]) {
      let newFormat = changes[TIME_FORMAT_KEY].newValue;
      FORMATS.includes(newFormat) && newFormat !== preferredFormat && (preferredFormat = newFormat, document.dispatchEvent(new CustomEvent("rovalra-time-format-change", { detail: { format: newFormat } })));
    }
  });
  function formatRelativeTime(date) {
    let seconds = Math.floor((/* @__PURE__ */ new Date() - date) / 1e3);
    if (seconds < 5) return "just now";
    if (seconds < 60) return `${seconds}s ago`;
    let minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}m ago`;
    let hours = Math.floor(minutes / 60);
    if (hours < 24) return `${hours}h ago`;
    let days = Math.floor(hours / 24);
    if (days < 7) return `${days}d ago`;
    let weeks = Math.floor(days / 7);
    if (weeks < 5) return `${weeks}w ago`;
    let months = Math.floor(days / 30.44);
    return months < 12 ? `${months}mo ago` : `${Math.floor(days / 365.25)}y ago`;
  }
  __name(formatRelativeTime, "formatRelativeTime");
  function formatTime(date, format) {
    switch (format) {
      case "24h":
        return date.toLocaleTimeString([], { hour12: !1 });
      case "relative":
        return formatRelativeTime(date);
      default:
        return date.toLocaleTimeString([]);
    }
  }
  __name(formatTime, "formatTime");
  function createInteractiveTimestamp(dateString) {
    let date = new Date(dateString), currentFormat = preferredFormat, container = document.createElement("div");
    container.className = "rovalra-interactive-timestamp", container.style.position = "relative", container.style.cursor = "pointer";
    let timeSpan = document.createElement("span");
    timeSpan.style.borderBottom = "1px dashed color-mix(in srgb, var(--rovalra-secondary-text-color) 50%, transparent)";
    let updateInterval = null, updateDisplay = /* @__PURE__ */ __name((format) => {
      updateInterval && clearInterval(updateInterval), timeSpan.textContent = formatTime(date, format), format === "relative" && (updateInterval = setInterval(() => {
        timeSpan.textContent = formatTime(date, "relative");
      }, 6e4));
    }, "updateDisplay");
    updateDisplay(currentFormat);
    let handleFormatChange = /* @__PURE__ */ __name((e) => {
      let newFormat = e.detail.format;
      newFormat !== currentFormat && (currentFormat = newFormat, updateDisplay(newFormat));
    }, "handleFormatChange");
    document.addEventListener("rovalra-time-format-change", handleFormatChange), container.addEventListener("click", (e) => {
      e.stopPropagation();
      let nextIndex = (FORMATS.indexOf(currentFormat) + 1) % FORMATS.length, newFormat = FORMATS[nextIndex];
      preferredFormat = newFormat, chrome.storage.local.set({ [TIME_FORMAT_KEY]: newFormat }), document.dispatchEvent(new CustomEvent("rovalra-time-format-change", {
        detail: { format: newFormat }
      }));
    });
    let observer = new MutationObserver(() => {
      document.body.contains(container) || (updateInterval && clearInterval(updateInterval), document.removeEventListener("rovalra-time-format-change", handleFormatChange), observer.disconnect());
    });
    return observer.observe(document.body, { childList: !0, subtree: !0 }), container.appendChild(timeSpan), container;
  }
  __name(createInteractiveTimestamp, "createInteractiveTimestamp");

  // src/content/core/ui/heatmap.js
  function renderDetails(container, dateStr, updates) {
    container.innerHTML = "";
    let wrapper = document.createElement("div");
    wrapper.style.borderTop = "1px solid var(--divider-color)", wrapper.style.marginTop = "15px", wrapper.style.paddingTop = "10px";
    let dateFormatted = new Date(dateStr).toLocaleDateString(void 0, { timeZone: "UTC", weekday: "long", year: "numeric", month: "long", day: "numeric" }), header = document.createElement("div");
    header.textContent = `Updates on ${dateFormatted}`, header.style.fontWeight = "600", header.style.fontSize = "16px", header.style.marginBottom = "8px", header.style.color = "var(--rovalra-main-text-color, inherit)";
    let list = document.createElement("ul");
    list.style.listStyle = "none", list.style.padding = "0", list.style.margin = "0", updates.sort((a, b2) => new Date(b2.first_seen) - new Date(a.first_seen)), updates.forEach((update) => {
      let li = document.createElement("li");
      li.style.display = "flex", li.style.justifyContent = "space-between", li.style.padding = "8px 0", li.style.borderBottom = "1px solid var(--divider-color)", li.style.fontSize = "14px";
      let timeElement = createInteractiveTimestamp(update.first_seen), verSpan = document.createElement("span");
      verSpan.textContent = update.place_version ? `Version: ${update.place_version}` : "", verSpan.style.color = "var(--rovalra-secondary-text-color)", li.appendChild(timeElement), li.appendChild(verSpan), list.appendChild(li);
    }), list.lastChild && (list.lastChild.style.borderBottom = "none"), wrapper.appendChild(header), wrapper.appendChild(list), container.appendChild(wrapper);
  }
  __name(renderDetails, "renderDetails");
  function _renderHeatmap(graphContainer, history2, detailsContainer) {
    graphContainer.innerHTML = "", detailsContainer && (detailsContainer.innerHTML = "");
    let updatesByDate = {};
    history2 && history2.forEach((entry) => {
      let date = new Date(entry.first_seen).toISOString().split("T")[0];
      updatesByDate[date] || (updatesByDate[date] = []), updatesByDate[date].push(entry);
    });
    let today = /* @__PURE__ */ new Date(), endDate = new Date(today), startDate = new Date(today);
    startDate.setFullYear(startDate.getFullYear() - 1), startDate.setDate(startDate.getDate() - startDate.getDay());
    let cellSize = 10, cellGap = 3, weekWidth = cellSize + cellGap, leftPadding = 30, topPadding = 20, timeDiff = endDate - startDate, dayDiff = Math.ceil(timeDiff / (1e3 * 3600 * 24)), weeks = Math.ceil(dayDiff / 7), totalWidth = weeks * weekWidth + leftPadding, height = 7 * (cellSize + cellGap), totalHeight = topPadding + height + 20 + 10, svgNS = "http://www.w3.org/2000/svg", svg2 = document.createElementNS(svgNS, "svg");
    svg2.setAttribute("width", "100%"), svg2.setAttribute("viewBox", `0 0 ${totalWidth} ${totalHeight}`), svg2.style.display = "block";
    let dayLabels = ["Mon", "Wed", "Fri"];
    [1, 3, 5].forEach((dayIndex, i) => {
      let text2 = document.createElementNS(svgNS, "text");
      text2.setAttribute("x", leftPadding - 5), text2.setAttribute("y", topPadding + dayIndex * (cellSize + cellGap) + cellSize - 1), text2.setAttribute("text-anchor", "end"), text2.setAttribute("font-size", "9"), text2.setAttribute("fill", "var(--rovalra-secondary-text-color)"), text2.textContent = dayLabels[i], svg2.appendChild(text2);
    });
    let monthLabels = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], lastMonth = -1, firstLabelDrawn = !1;
    for (let w2 = 0; w2 < weeks; w2++) {
      let weekStartDate = new Date(startDate);
      weekStartDate.setDate(weekStartDate.getDate() + w2 * 7);
      let month = weekStartDate.getMonth();
      if (month !== lastMonth) {
        if (firstLabelDrawn) {
          let text2 = document.createElementNS(svgNS, "text");
          text2.setAttribute("x", leftPadding + w2 * weekWidth), text2.setAttribute("y", 10), text2.setAttribute("font-size", "10"), text2.setAttribute("fill", "var(--rovalra-secondary-text-color)"), text2.textContent = monthLabels[month], svg2.appendChild(text2);
        }
        lastMonth = month, firstLabelDrawn = !0;
      }
      for (let d = 0; d < 7; d++) {
        let currentDate = new Date(weekStartDate);
        if (currentDate.setDate(currentDate.getDate() + d), currentDate > today) continue;
        let dateStr = currentDate.toISOString().split("T")[0], updates = updatesByDate[dateStr] || [], count = updates.length, rect = document.createElementNS(svgNS, "rect");
        if (rect.setAttribute("x", leftPadding + w2 * weekWidth), rect.setAttribute("y", topPadding + d * (cellSize + cellGap)), rect.setAttribute("width", cellSize), rect.setAttribute("height", cellSize), rect.setAttribute("rx", 2), rect.setAttribute("ry", 2), count > 0) {
          rect.setAttribute("fill", "var(--rovalra-playbutton-color)");
          let opacity = 0.4;
          count >= 4 ? opacity = 1 : count === 3 ? opacity = 0.8 : count === 2 && (opacity = 0.6), rect.setAttribute("fill-opacity", opacity), rect.style.cursor = "pointer", rect.addEventListener("click", () => {
            renderDetails(detailsContainer, dateStr, updates);
          });
        } else
          rect.setAttribute("fill", "var(--divider-color)"), rect.setAttribute("fill-opacity", "0.5");
        svg2.appendChild(rect);
        let dateFormatted = currentDate.toLocaleDateString(void 0, { year: "numeric", month: "short", day: "numeric" }), tooltipText = `${count} update${count !== 1 ? "s" : ""} on ${dateFormatted}`;
        addTooltip(rect, tooltipText, { position: "top" });
      }
    }
    let legendY = topPadding + height + 15, legendRectSize = 10, legendGap = 3, legendWidth = 25 + 5 * (legendRectSize + legendGap) + 25, legendX = totalWidth - legendWidth;
    legendX < leftPadding && (legendX = leftPadding);
    let lessText = document.createElementNS(svgNS, "text");
    lessText.textContent = "Less", lessText.setAttribute("font-size", "10"), lessText.setAttribute("fill", "var(--rovalra-secondary-text-color)"), lessText.setAttribute("x", legendX), lessText.setAttribute("y", legendY + legendRectSize - 1), svg2.appendChild(lessText);
    let currentX = legendX + 25;
    [
      { fill: "var(--divider-color)", opacity: "0.5" },
      { fill: "var(--rovalra-playbutton-color)", opacity: "0.4" },
      { fill: "var(--rovalra-playbutton-color)", opacity: "0.6" },
      { fill: "var(--rovalra-playbutton-color)", opacity: "0.8" },
      { fill: "var(--rovalra-playbutton-color)", opacity: "1.0" }
    ].forEach((level) => {
      let r = document.createElementNS(svgNS, "rect");
      r.setAttribute("width", legendRectSize), r.setAttribute("height", legendRectSize), r.setAttribute("x", currentX), r.setAttribute("y", legendY), r.setAttribute("rx", 2), r.setAttribute("ry", 2), r.setAttribute("fill", level.fill), r.setAttribute("fill-opacity", level.opacity), svg2.appendChild(r), currentX += legendRectSize + legendGap;
    });
    let moreText = document.createElementNS(svgNS, "text");
    moreText.textContent = "More", moreText.setAttribute("font-size", "10"), moreText.setAttribute("fill", "var(--rovalra-secondary-text-color)"), moreText.setAttribute("x", currentX + 2), moreText.setAttribute("y", legendY + legendRectSize - 1), svg2.appendChild(moreText), graphContainer.appendChild(svg2);
  }
  __name(_renderHeatmap, "_renderHeatmap");
  function createHeatmap(historyData, titleText = "Update History") {
    let container = document.createElement("div");
    container.className = "rovalra-heatmap-container", container.style.marginTop = "24px", container.style.marginBottom = "12px", container.style.width = "100%", container.style.display = "flex", container.style.flexDirection = "column";
    let header = document.createElement("div");
    header.style.display = "flex", header.style.justifyContent = "space-between", header.style.alignItems = "center", header.style.marginBottom = "10px";
    let title = document.createElement("h2");
    title.textContent = titleText;
    let graphContainer = document.createElement("div");
    graphContainer.style.overflowX = "auto", graphContainer.style.width = "100%", graphContainer.style.display = "flex";
    let detailsContainer = document.createElement("div");
    return detailsContainer.className = "rovalra-heatmap-details", detailsContainer.style.width = "100%", header.appendChild(title), container.appendChild(header), container.appendChild(graphContainer), container.appendChild(detailsContainer), _renderHeatmap(graphContainer, historyData, detailsContainer), container;
  }
  __name(createHeatmap, "createHeatmap");

  // src/content/features/games/tab/updateHistory.js
  function init34() {
    chrome.storage.local.get({ updateHistoryEnabled: !1 }, (settings) => {
      settings.updateHistoryEnabled && observeElement("#horizontal-tabs", (tabContainer) => {
        if (tabContainer.dataset.rovalraUpdatesTabInitialized === "true") return;
        tabContainer.dataset.rovalraUpdatesTabInitialized = "true";
        let contentSection = document.querySelector(".tab-content.rbx-tab-content");
        if (!contentSection) return;
        let placeId = getPlaceIdFromUrl();
        if (placeId) {
          document.getElementById("tab-updates")?.remove(), document.getElementById("updates-content-pane")?.remove();
          let { contentPane } = createTab({
            id: "updates",
            label: "Updates",
            container: tabContainer,
            contentContainer: contentSection,
            hash: "#!/updates"
          });
          loadAndRenderHeatmap(placeId, contentPane);
        }
      }, {
        onRemove: /* @__PURE__ */ __name(() => {
          let oldContainer = document.querySelector("[data-rovalra-updates-tab-initialized]");
          oldContainer && (oldContainer.dataset.rovalraUpdatesTabInitialized = "false");
        }, "onRemove")
      });
    });
  }
  __name(init34, "init");
  async function loadAndRenderHeatmap(placeId, parentElement) {
    let universeId = document.getElementById("game-detail-meta-data")?.dataset.universeId;
    if (universeId)
      try {
        let gameMeta = (await callRobloxApiJson({
          subdomain: "apis",
          endpoint: "/discovery-api/omni-recommendation-metadata",
          method: "POST",
          body: {
            contents: [{ contentId: parseInt(universeId, 10), contentType: "Game" }],
            sessionId: self.crypto.randomUUID()
          }
        }))?.contentMetadata?.Game?.[universeId];
        if (gameMeta && gameMeta.contentMaturity === "restricted") {
          let msg = document.createElement("div");
          msg.className = "text-secondary", msg.style.padding = "20px", msg.style.textAlign = "center", msg.style.fontSize = "20px", msg.textContent = "Update History doesn't work on 18+ experiences", parentElement.appendChild(msg);
          return;
        }
      } catch (e) {
        console.warn("RoValra: Failed to check content maturity", e);
      }
    try {
      let placeDetails = await callRobloxApiJson({
        subdomain: "games",
        endpoint: `/v1/games/multiget-place-details?placeIds=${placeId}`,
        method: "GET"
      });
      if (placeDetails && placeDetails[0] && placeDetails[0].price > 0) {
        let msg = document.createElement("div");
        msg.className = "text-secondary", msg.style.padding = "20px", msg.style.textAlign = "center", msg.style.fontSize = "20px", msg.textContent = "Update History doesn't work on paid access experiences", parentElement.appendChild(msg);
        return;
      }
    } catch (e) {
      console.warn("RoValra: Failed to check paid access status", e);
    }
    try {
      let data = await callRobloxApiJson({
        isRovalraApi: !0,
        endpoint: `/v1/games/history?place_id=${placeId}`,
        method: "GET"
      }), historyData = data && data.history ? data.history : [], heatmapElement = createHeatmap(historyData, "Update History");
      parentElement.appendChild(heatmapElement);
    } catch (error) {
      console.error("RoValra: Failed to load heatmap data", error);
      let heatmapElement = createHeatmap([], "Update History");
      parentElement.appendChild(heatmapElement);
    }
  }
  __name(loadAndRenderHeatmap, "loadAndRenderHeatmap");

  // src/content/features/transactions/totalspent.js
  function onElementFound(container) {
    let buttonIdentifier = "rovalra-total-spent-btn";
    if (container.querySelector(`.${buttonIdentifier}`)) return;
    let CALCULATION_STATE = {
      IDLE: "IDLE",
      RUNNING: "RUNNING",
      PAUSED: "PAUSED",
      DONE: "DONE",
      ERROR: "ERROR"
    }, CALCULATION_TYPE = {
      ROBUX_SPENT: "ROBUX_SPENT",
      MONEY_SPENT: "MONEY_SPENT"
    }, state3 = {
      status: CALCULATION_STATE.IDLE,
      calculationType: null,
      totalSpent: 0,
      totalMoneySpent: 0,
      currencyCode: "USD",
      transactionsProcessed: 0,
      purchaseCounts: {},
      stipendCounts: {},
      itemTypeBreakdown: {},
      lastPurchaseCursor: "",
      lastStipendCursor: "",
      userId: 0,
      errorMessage: "",
      isRateLimited: !1,
      retryCount: 0
    }, overlayInstance = null, isUIUpdate = !1, animationController = {
      queue: [],
      isAnimating: !1,
      animationInterval: null,
      robuxToPriceMap: /* @__PURE__ */ new Map(),
      premiumRobuxToProductMap: /* @__PURE__ */ new Map(),
      addBatch(transactions) {
        this.queue.push(...transactions), this.isAnimating || this.start();
      },
      start() {
        this.isAnimating = !0, this.animationInterval = setInterval(() => this.tick(), 20);
      },
      tick() {
        if (this.queue.length === 0) {
          this.stop();
          return;
        }
        let transaction = this.queue.shift();
        if (state3.transactionsProcessed++, state3.calculationType === CALCULATION_TYPE.ROBUX_SPENT) {
          if (transaction.currency && transaction.currency.amount < 0) {
            let amount = Math.abs(transaction.currency.amount);
            state3.totalSpent += amount;
            let type = transaction.details && transaction.details.type ? transaction.details.type : "Other";
            state3.itemTypeBreakdown[type] || (state3.itemTypeBreakdown[type] = { count: 0, robux: 0 }), state3.itemTypeBreakdown[type].count++, state3.itemTypeBreakdown[type].robux += amount;
          }
        } else if (transaction.category === "Premium") {
          let amount = transaction.currency.amount, product = this.premiumRobuxToProductMap.get(amount);
          if (product) {
            state3.totalMoneySpent += product.price;
            let amountKey = amount.toString();
            state3.stipendCounts[amountKey] = (state3.stipendCounts[amountKey] || 0) + 1;
          }
        } else if (transaction.category === "Currency") {
          let amount = transaction.currency.amount, amountKey = amount.toString();
          state3.purchaseCounts[amountKey] = (state3.purchaseCounts[amountKey] || 0) + 1;
          let price = this.getPriceForRobuxAmount(amount);
          price && (state3.totalMoneySpent += price);
        }
        this.updateDOM();
      },
      getPriceForRobuxAmount(amount) {
        let closestAmount = 0, smallestDiff = 1 / 0;
        for (let robuxAmount of this.robuxToPriceMap.keys()) {
          let diff = Math.abs(robuxAmount - amount);
          diff < smallestDiff && (smallestDiff = diff, closestAmount = robuxAmount);
        }
        return closestAmount > 0 && smallestDiff / closestAmount < 0.25 ? this.robuxToPriceMap.get(closestAmount) : null;
      },
      stop() {
        clearInterval(this.animationInterval), this.animationInterval = null, this.isAnimating = !1;
      },
      waitUntilIdle() {
        return new Promise((resolve) => {
          let check = /* @__PURE__ */ __name(() => this.isAnimating ? setTimeout(check, 100) : resolve(), "check");
          check();
        });
      },
      updateDOM() {
        let transEl = document.getElementById(
          "rovalra-stat-transactions"
        ), robuxEl = document.getElementById("rovalra-stat-robux"), moneySpentEl = document.getElementById(
          "rovalra-stat-money-spent"
        ), purchaseBreakdownEl = document.getElementById(
          "rovalra-purchase-breakdown-container"
        ), premiumBreakdownEl = document.getElementById(
          "rovalra-premium-breakdown-container"
        ), itemTypeBreakdownEl = document.getElementById(
          "rovalra-itemtype-breakdown-container"
        ), robuxIcon = '<span class="icon-robux-16x16" style="vertical-align: -3px;"></span>', formatRobux = /* @__PURE__ */ __name((amount) => `${amount.toLocaleString()} ${robuxIcon}`, "formatRobux"), formatCurrency = /* @__PURE__ */ __name((amount) => amount.toLocaleString(void 0, {
          style: "currency",
          currency: state3.currencyCode
        }), "formatCurrency");
        if (transEl && (transEl.textContent = state3.transactionsProcessed.toLocaleString()), robuxEl && (robuxEl.innerHTML = purify.sanitize(
          formatRobux(state3.totalSpent)
        )), moneySpentEl && (moneySpentEl.textContent = state3.totalMoneySpent.toLocaleString(
          void 0,
          { style: "currency", currency: state3.currencyCode }
        )), itemTypeBreakdownEl) {
          let itemsHTML = Object.keys(state3.itemTypeBreakdown).sort(
            (a, b2) => state3.itemTypeBreakdown[b2].robux - state3.itemTypeBreakdown[a].robux
          ).map((type) => {
            let data = state3.itemTypeBreakdown[type];
            return `<li>
                                <span class="rovalra-breakdown-amount">${type.replace(/([A-Z])/g, " $1").trim()}</span>
                                <span class="rovalra-breakdown-count">x${data.count}</span>
                                <span class="rovalra-breakdown-price">${formatRobux(data.robux)}</span>
                            </li>`;
          }).join("");
          itemsHTML ? itemTypeBreakdownEl.innerHTML = purify.sanitize(
            `<ul class="rovalra-breakdown-list">${itemsHTML}</ul>`
          ) : itemTypeBreakdownEl.innerHTML = purify.sanitize(
            '<div class="text-secondary text-caption-body" style="padding:8px;">No items found yet.</div>'
          );
        }
        if (purchaseBreakdownEl) {
          let itemsHTML = Object.keys(state3.purchaseCounts).sort(
            (a, b2) => Number(b2) - Number(a)
          ).map((amountStr) => {
            let amount = Number(amountStr), count = state3.purchaseCounts[amountStr], price = this.getPriceForRobuxAmount(amount), total = price ? formatCurrency(price * count) : "N/A";
            return `<li>
                                <span class="rovalra-breakdown-amount">${formatRobux(amount)} Pack</span>
                                <span class="rovalra-breakdown-count">x${count}</span>
                                <span class="rovalra-breakdown-price">${total}</span>
                            </li>`;
          }).join("");
          purchaseBreakdownEl.innerHTML = purify.sanitize(
            `<ul class="rovalra-breakdown-list">${itemsHTML}</ul>`
          );
        }
        if (premiumBreakdownEl) {
          let itemsHTML = Object.keys(state3.stipendCounts).sort(
            (a, b2) => Number(b2) - Number(a)
          ).map((amountStr) => {
            let amount = Number(amountStr), count = state3.stipendCounts[amountStr], product = this.premiumRobuxToProductMap.get(amount), total = product ? formatCurrency(product.price * count) : "N/A";
            return `<li>
                                <span class="rovalra-breakdown-amount">${product ? product.name : `${formatRobux(amount)} Stipend`}</span>
                                <span class="rovalra-breakdown-count">x${count}</span>
                                <span class="rovalra-breakdown-price">${total}</span>
                            </li>`;
          }).join("");
          premiumBreakdownEl.innerHTML = purify.sanitize(
            `<ul class="rovalra-breakdown-list">${itemsHTML}</ul>`
          );
        }
      }
    }, handleOverlayClose = /* @__PURE__ */ __name(() => {
      isUIUpdate || (state3.status === CALCULATION_STATE.RUNNING && pauseCalculation(!0), overlayInstance = null);
    }, "handleOverlayClose"), updateOverlay = /* @__PURE__ */ __name(() => {
      isUIUpdate = !0, overlayInstance && overlayInstance.close();
      let moneySpentValue = state3.totalMoneySpent.toLocaleString(
        void 0,
        { style: "currency", currency: state3.currencyCode }
      ), robuxSpentValue = state3.totalSpent.toLocaleString(), transactionsValue = state3.transactionsProcessed.toLocaleString(), header = "", mainContent = "", actions = [], bodyContainer = document.createElement("div");
      if (bodyContainer.className = "rovalra-overlay-body", state3.status === CALCULATION_STATE.IDLE || state3.status === CALCULATION_STATE.PAUSED) {
        header = "Calculate Spend";
        let desc = document.createElement("div");
        desc.className = "rovalra-description";
        let btnStack = document.createElement("div");
        if (btnStack.className = "rovalra-action-stack", state3.status === CALCULATION_STATE.PAUSED) {
          desc.textContent = "Calculation paused. Resume to continue counting.";
          let resumeButton = createButton(
            "Resume Calculation",
            "primary",
            { onClick: runCalculation }
          ), newCalcButton = createButton(
            "Start New Calculation",
            "secondary",
            {
              onClick: /* @__PURE__ */ __name(() => {
                state3.status = CALCULATION_STATE.IDLE, updateOverlay();
              }, "onClick")
            }
          );
          btnStack.append(resumeButton, newCalcButton);
        } else {
          desc.textContent = "Select a mode to calculate your transaction history.";
          let robuxButton = createButton(
            "Calculate Robux Spent",
            "primary",
            {
              onClick: /* @__PURE__ */ __name(() => startCalculation(CALCULATION_TYPE.ROBUX_SPENT), "onClick")
            }
          ), moneyButton = createButton(
            "Calculate Money Spent",
            "primary",
            {
              onClick: /* @__PURE__ */ __name(() => startCalculation(CALCULATION_TYPE.MONEY_SPENT), "onClick")
            }
          );
          btnStack.append(robuxButton, moneyButton);
        }
        bodyContainer.append(desc, btnStack), mainContent = bodyContainer, overlayInstance = createOverlay({
          title: header,
          bodyContent: mainContent,
          actions: [],
          showLogo: "rovalraIcon",
          onClose: handleOverlayClose
        });
      } else {
        bodyContainer.classList.add("content-top");
        let statsGridHTML = "", breakdownsHTML = "", statusContent = "";
        switch (state3.calculationType === CALCULATION_TYPE.ROBUX_SPENT ? (statsGridHTML = `
                    <div class="rovalra-stats-grid">
                        <div class="rovalra-stat-item centered-content">
                            <span class="rovalra-stat-label">Transactions Scanned</span>
                            <span class="rovalra-stat-value" id="rovalra-stat-transactions">${transactionsValue}</span>
                        </div>
                        <div class="rovalra-stat-item centered-content">
                            <span class="rovalra-stat-label">Total Robux Spent</span>
                            <span class="rovalra-stat-value" id="rovalra-stat-robux">${robuxSpentValue} <span class="icon-robux-16x16" style="vertical-align: -3px;"></span></span>
                        </div>
                    </div>`, breakdownsHTML = `
                    <div class="rovalra-breakdown-section">
                        <span class="rovalra-stat-label">Item Type Breakdown</span>
                        <div id="rovalra-itemtype-breakdown-container"></div>
                    </div>
                `) : (statsGridHTML = `
                    <div class="rovalra-stats-grid">
                        <div class="rovalra-stat-item">
                            <span class="rovalra-stat-label">Transactions Scanned</span>
                            <span class="rovalra-stat-value" id="rovalra-stat-transactions">${transactionsValue}</span>
                        </div>
                        <div class="rovalra-stat-item">
                            <span class="rovalra-stat-label">Total Spent (Approx.)</span>
                            <span class="rovalra-stat-value" id="rovalra-stat-money-spent">${moneySpentValue}</span>
                        </div>
                    </div>`, breakdownsHTML = `
                    <div class="rovalra-breakdown-section">
                        <span class="rovalra-stat-label">Premium Subscription Breakdown</span>
                        <div id="rovalra-premium-breakdown-container"></div>
                    </div>
                    <div class="rovalra-breakdown-section">
                        <span class="rovalra-stat-label">Robux Purchase Breakdown</span>
                        <div id="rovalra-purchase-breakdown-container"></div>
                    </div>
                `), state3.status) {
          case CALCULATION_STATE.RUNNING: {
            header = "Calculating";
            let statusText = "Calculating...", statusClass = "rovalra-status-text";
            state3.isRateLimited && (statusText = "API rate limited. Still counting...", statusClass = "rovalra-status-text rovalra-rate-limit-text"), statusContent = `
                        <div class="rovalra-status-wrapper">
                            <span class="${statusClass}">${statusText}</span>
                            <span class="spinner spinner-default"></span>
                        </div>`, actions = [];
            break;
          }
          case CALCULATION_STATE.DONE: {
            header = "Calculation Complete";
            let doneText = '<p class="text-body">All relevant transactions have been scanned.</p><p class="text-caption-body text-secondary" style="margin-bottom: 16px;"></p>', newCalcBtn = createButton(
              "New Calculation",
              "primary",
              {
                onClick: /* @__PURE__ */ __name(() => {
                  state3.status = CALCULATION_STATE.IDLE, updateOverlay();
                }, "onClick")
              }
            ), btnWrapper = document.createElement("div");
            btnWrapper.className = "rovalra-action-stack", btnWrapper.appendChild(newCalcBtn), statusContent = doneText + btnWrapper.outerHTML, actions = [];
            break;
          }
          case CALCULATION_STATE.ERROR:
            header = "An Error Occurred", statusContent = `<p class="text-error">${state3.errorMessage}</p>`, actions = [
              createButton("Retry", "primary", {
                onClick: resetAndRunCalculation
              })
            ];
            break;
        }
        if (bodyContainer.innerHTML = purify.sanitize(`
                ${statsGridHTML}
                ${breakdownsHTML}
                <div class="rovalra-divider"></div>
                <div class="rovalra-status-content">${statusContent}</div>`), mainContent = bodyContainer, overlayInstance = createOverlay({
          title: header,
          bodyContent: mainContent,
          actions,
          showLogo: "rovalraIcon",
          onClose: handleOverlayClose
        }), state3.status === CALCULATION_STATE.DONE) {
          let btn = bodyContainer.querySelector(
            ".rovalra-action-stack button"
          );
          btn && btn.addEventListener("click", () => {
            state3.status = CALCULATION_STATE.IDLE, updateOverlay();
          });
        }
      }
      animationController.updateDOM(), setTimeout(() => {
        isUIUpdate = !1;
      }, 50);
    }, "updateOverlay"), pauseCalculation = /* @__PURE__ */ __name((silent = !1) => {
      state3.status === CALCULATION_STATE.RUNNING && (state3.status = CALCULATION_STATE.PAUSED, silent || updateOverlay());
    }, "pauseCalculation"), runCalculation = /* @__PURE__ */ __name(async () => {
      overlayInstance || updateOverlay(), state3.status = CALCULATION_STATE.RUNNING, updateOverlay(), totalSpentButton.style.pointerEvents = "none";
      class PausedException extends Error {
        static {
          __name(this, "PausedException");
        }
        constructor(message) {
          super(message), this.name = "PausedException";
        }
      }
      try {
        if (!state3.userId) {
          let userData = await callRobloxApiJson({
            subdomain: "users",
            endpoint: "/v1/users/authenticated"
          });
          if (!userData.id)
            throw new Error("Could not retrieve user ID.");
          state3.userId = userData.id;
        }
        if (state3.calculationType === CALCULATION_TYPE.MONEY_SPENT && animationController.robuxToPriceMap.size === 0) {
          let productsData = await callRobloxApiJson({
            subdomain: "premiumfeatures",
            endpoint: "/v1/products?skipPremiumUserCheck=true"
          });
          productsData.products.forEach((p) => {
            p.premiumFeatureTypeName === "Subscription" ? animationController.premiumRobuxToProductMap.set(
              p.robuxAmount,
              {
                price: p.price.amount,
                name: p.defaultDisplayName
              }
            ) : animationController.robuxToPriceMap.set(
              p.robuxAmount,
              p.price.amount
            );
          }), state3.currencyCode = productsData.products[0]?.price.currency.currencyCode || "USD", animationController.robuxToPriceMap.has(80) || animationController.robuxToPriceMap.set(80, 0.99);
        }
        let transactionTasks = state3.calculationType === CALCULATION_TYPE.ROBUX_SPENT ? [
          {
            type: "Purchase",
            cursorKey: "lastPurchaseCursor",
            category: "Currency"
          }
        ] : [
          {
            type: "PremiumStipend",
            cursorKey: "lastStipendCursor",
            category: "Premium"
          },
          {
            type: "CurrencyPurchase",
            cursorKey: "lastPurchaseCursor",
            category: "Currency"
          }
        ];
        for (let task of transactionTasks) {
          let hasNextPage = !0;
          for (; hasNextPage && state3.status === CALCULATION_STATE.RUNNING; ) {
            if (!document.getElementById("rovalra-stat-transactions"))
              throw new PausedException("Overlay closed by user.");
            await animationController.waitUntilIdle();
            let cursor = state3[task.cursorKey];
            try {
              let data = await callRobloxApiJson({
                subdomain: "apis",
                endpoint: `/transaction-records/v1/users/${state3.userId}/transactions?cursor=${cursor}&limit=100&transactionType=${task.type}&itemPricingType=PaidAndLimited`
              });
              if (state3.retryCount = 0, state3.isRateLimited && (state3.isRateLimited = !1, updateOverlay()), data.data && data.data.length > 0) {
                let processedData = data.data.map((t) => ({
                  ...t,
                  category: task.category
                }));
                animationController.addBatch(processedData);
              }
              data.nextPageCursor ? state3[task.cursorKey] = data.nextPageCursor : hasNextPage = !1;
            } catch (error) {
              if (error.status === 429 || error.message?.includes("429")) {
                state3.isRateLimited || (state3.isRateLimited = !0, updateOverlay());
                let waitUntil = Date.now() + 5 * 1e3;
                for (; Date.now() < waitUntil; ) {
                  if (state3.status !== CALCULATION_STATE.RUNNING)
                    throw new PausedException(
                      "Paused during rate-limit wait."
                    );
                  await new Promise(
                    (resolve) => setTimeout(resolve, 250)
                  );
                }
                state3.isRateLimited && (state3.isRateLimited = !1, updateOverlay());
                continue;
              } else {
                if (state3.retryCount++, state3.retryCount > 5)
                  throw new Error(
                    `Failed after multiple retries. Last error: ${error.message || "Unknown"}`
                  );
                let waitUntil = Date.now() + 1e3;
                for (; Date.now() < waitUntil; ) {
                  if (state3.status !== CALCULATION_STATE.RUNNING)
                    throw new PausedException(
                      "Paused during retry wait."
                    );
                  await new Promise(
                    (resolve) => setTimeout(resolve, 250)
                  );
                }
                continue;
              }
            }
          }
        }
        await animationController.waitUntilIdle(), state3.status === CALCULATION_STATE.RUNNING && (state3.status = CALCULATION_STATE.DONE, showReviewPopup("totalspent"));
      } catch (error) {
        error instanceof PausedException ? (console.log(`RoValra: ${error.message}`), await animationController.waitUntilIdle()) : (console.error(
          "RoValra: An error occurred during calculation:",
          error
        ), state3.status = CALCULATION_STATE.ERROR, state3.errorMessage = error.message, updateOverlay());
      } finally {
        totalSpentButton.style.pointerEvents = "auto", state3.isRateLimited = !1, overlayInstance && state3.status !== CALCULATION_STATE.PAUSED && updateOverlay();
      }
    }, "runCalculation"), startCalculation = /* @__PURE__ */ __name((type) => {
      state3 = {
        ...state3,
        status: CALCULATION_STATE.IDLE,
        calculationType: type,
        totalSpent: 0,
        totalMoneySpent: 0,
        transactionsProcessed: 0,
        purchaseCounts: {},
        stipendCounts: {},
        itemTypeBreakdown: {},
        lastPurchaseCursor: "",
        lastStipendCursor: "",
        errorMessage: "",
        retryCount: 0
      }, runCalculation();
    }, "startCalculation"), resetAndRunCalculation = /* @__PURE__ */ __name(() => {
      startCalculation(state3.calculationType);
    }, "resetAndRunCalculation"), totalSpentButton = createButton("Calculate Spend", "secondary", {
      id: buttonIdentifier,
      onClick: /* @__PURE__ */ __name(() => updateOverlay(), "onClick")
    });
    totalSpentButton.classList.add("btn-growth-md"), totalSpentButton.style.marginLeft = "10px", totalSpentButton.style.marginTop = "auto", totalSpentButton.style.maxHeight = "36px", observeElement(
      ".rovalra-global-overlay",
      () => {
      },
      // No action needed on add
      {
        onRemove: /* @__PURE__ */ __name(() => {
          isUIUpdate || state3.status === CALCULATION_STATE.RUNNING && pauseCalculation(!0);
        }, "onRemove")
      }
    ), container.appendChild(totalSpentButton);
  }
  __name(onElementFound, "onElementFound");
  function init35() {
    chrome.storage.local.get("totalspentEnabled", (result) => {
      result.totalspentEnabled && observeElement(
        ".dropdown-container.container-header",
        onElementFound
      );
    });
  }
  __name(init35, "init");

  // src/content/features/transactions/pendingRobuxTrans.js
  var API_LIMIT = 100, MAX_PAGES_TO_FETCH_FOR_INFERENCE = 2e3, MAX_PAGES_WITHOUT_PENDING_SALES = 5, API_CALL_DELAY_MS = 50, TARGET_ELEMENT_SELECTOR = "td.summary-transaction-pending-text.text-disabled", state = {
    userId: null,
    cachedResults: null
  }, sleep2 = /* @__PURE__ */ __name((ms) => new Promise((resolve) => setTimeout(resolve, ms)), "sleep"), parseTimestamp = /* @__PURE__ */ __name((timestampStr) => {
    if (!timestampStr) return null;
    try {
      let dt = new Date(timestampStr);
      return isNaN(dt.getTime()) ? null : dt;
    } catch (e) {
      return console.error(e), null;
    }
  }, "parseTimestamp");
  async function fetchTransactions(userId) {
    let allTransactionsData = [], currentCursor3 = "", pagesFetched = 0, consecutivePagesWithoutPendingSales = 0;
    transactionLoop: for (; pagesFetched < MAX_PAGES_TO_FETCH_FOR_INFERENCE; ) {
      pagesFetched++;
      let endpoint = `/v2/users/${userId}/transactions?limit=${API_LIMIT}&transactionType=Sale&itemPricingType=PaidAndLimited`;
      currentCursor3 && (endpoint += `&cursor=${currentCursor3}`);
      let data;
      try {
        for (; ; ) {
          let response = await callRobloxApi({
            subdomain: "economy",
            endpoint
          });
          if (response.ok) {
            data = await response.json();
            break;
          } else if (response.status === 429) {
            await sleep2(2e3);
            continue;
          } else
            break;
        }
        if (data && data.data) {
          let currentPageTransactions = data.data;
          if (!currentPageTransactions || currentPageTransactions.length === 0)
            break transactionLoop;
          let foundPendingSale = !1;
          for (let transaction of currentPageTransactions)
            if (Object.prototype.hasOwnProperty.call(
              transaction,
              "isPending"
            ) && transaction.isPending) {
              foundPendingSale = !0;
              break;
            }
          if (foundPendingSale)
            consecutivePagesWithoutPendingSales = 0;
          else if (consecutivePagesWithoutPendingSales++, consecutivePagesWithoutPendingSales >= MAX_PAGES_WITHOUT_PENDING_SALES)
            break transactionLoop;
          allTransactionsData.push(...currentPageTransactions);
          let nextCursor = data.nextPageCursor;
          if (!nextCursor)
            break transactionLoop;
          currentCursor3 = nextCursor, await sleep2(API_CALL_DELAY_MS);
        } else
          break transactionLoop;
      } catch (e) {
        console.error(e);
        break transactionLoop;
      }
    }
    return allTransactionsData;
  }
  __name(fetchTransactions, "fetchTransactions");
  function inferPendingDuration(transactionsList) {
    if (!transactionsList || transactionsList.length === 0)
      return null;
    for (let transaction of transactionsList)
      if ((!Object.prototype.hasOwnProperty.call(transaction, "isPending") || transaction.isPending) && transaction.details && transaction.details.type)
        break;
    let minDaysObserved = 1 / 0, foundCompleted = !1, completedCount = 0, now = /* @__PURE__ */ new Date();
    for (let transaction of transactionsList)
      if (Object.prototype.hasOwnProperty.call(transaction, "isPending") && !transaction.isPending) {
        let createdStr = transaction.created;
        if (!createdStr) continue;
        let createdDt = parseTimestamp(createdStr);
        if (!createdDt) continue;
        let daysDifference = (now.getTime() - createdDt.getTime()) / (1e3 * 60 * 60 * 24), daysRoundedUp = Math.ceil(daysDifference);
        daysRoundedUp >= 1 && (minDaysObserved = Math.min(minDaysObserved, daysRoundedUp), foundCompleted = !0, completedCount++);
      }
    return foundCompleted && minDaysObserved !== 1 / 0 && completedCount >= 2 ? minDaysObserved : null;
  }
  __name(inferPendingDuration, "inferPendingDuration");
  function calculateUnpendingRobux(transactionsList, pendingDaysToUse) {
    if (!transactionsList || transactionsList.length === 0)
      return { amount: 0, hasEnoughData: !1 };
    if (!transactionsList.some((t) => t.isPending))
      return { amount: 0, hasEnoughData: !0 };
    if (pendingDaysToUse === null)
      return { amount: 0, hasEnoughData: !1 };
    let totalUnpendingTomorrow = 0, now = /* @__PURE__ */ new Date(), tomorrow = new Date(now);
    tomorrow.setUTCDate(now.getUTCDate() + 1);
    let tomorrowUTCDateString = tomorrow.toISOString().split("T")[0];
    for (let transaction of transactionsList)
      if (!Object.prototype.hasOwnProperty.call(transaction, "isPending") || transaction.isPending) {
        let createdStr = transaction.created, amount = transaction.currency?.amount;
        if (!createdStr || amount === void 0 || amount === 0)
          continue;
        let createdDt = parseTimestamp(createdStr);
        if (!createdDt)
          continue;
        let estimatedUnpendingDt = new Date(createdDt);
        estimatedUnpendingDt.setUTCDate(
          createdDt.getUTCDate() + pendingDaysToUse
        ), estimatedUnpendingDt.toISOString().split("T")[0] === tomorrowUTCDateString && (totalUnpendingTomorrow += amount);
      }
    return { amount: totalUnpendingTomorrow, hasEnoughData: !0 };
  }
  __name(calculateUnpendingRobux, "calculateUnpendingRobux");
  function storeResults(userId, results) {
    state.cachedResults = {
      timestamp: Date.now(),
      userId,
      estimatedRobux: {
        amount: results.amount,
        hasEnoughData: results.hasEnoughData
      },
      pendingDays: results.pendingDays,
      lastCalculation: results.lastCalculation
    };
  }
  __name(storeResults, "storeResults");
  function getStoredResults() {
    return state.cachedResults && Date.now() - state.cachedResults.timestamp < 1440 * 60 * 1e3 && state.cachedResults.userId === state.userId ? state.cachedResults : null;
  }
  __name(getStoredResults, "getStoredResults");
  function injectResultElement(targetElement, result) {
    if (!document.body.contains(targetElement)) return;
    let pendingRow = targetElement.closest("tr.pending") || targetElement.closest("tr");
    if (!pendingRow)
      for (pendingRow = targetElement.parentElement; pendingRow && pendingRow.tagName !== "TR"; )
        pendingRow = pendingRow.parentElement;
    if (!pendingRow || !document.body.contains(pendingRow)) return;
    let estimatorRow = document.querySelector(".estimator-row"), amountHtml = "", tooltipText = "This is an estimate of how many Robux from your pending balance will become available tomorrow, based on your transaction data. The actual amount may vary. And this may be inaccurate.";
    if (result.isLoading ? amountHtml = '<span style="color: var(--rovalra-main-text-color); font-weight: 400; font-size: 13px;">Loading...</span>' : result.errorMessage ? amountHtml = `<span style="color: red; font-weight: 400; font-size: 13px;">Error: ${result.errorMessage}</span>` : result.hasEnoughData ? amountHtml = `
            <span class="icon-robux-16x16"></span>
            <span class="text-robux" style="color: var(--rovalra-main-text-color); font-weight: 400;">${result.amount.toLocaleString()}~</span>
        ` : (amountHtml = '<span style="color: var(--rovalra-main-text-color); font-weight: 400; font-size: 13px;">Insufficient data</span>', tooltipText = "Not enough transaction history to make an accurate estimate. Please wait for more transactions to complete."), estimatorRow) {
      let amountCell = estimatorRow.querySelector(".amount");
      amountCell && (amountCell.innerHTML = dompurify_default.sanitize(amountHtml));
      let infoIcon = estimatorRow.querySelector(".icon-moreinfo");
      if (infoIcon && infoIcon.dataset.tooltipText !== tooltipText) {
        let newIcon = infoIcon.cloneNode(!0);
        infoIcon.parentNode.replaceChild(newIcon, infoIcon), addTooltip(newIcon, tooltipText), newIcon.dataset.tooltipText = tooltipText;
      }
    } else {
      estimatorRow = document.createElement("tr"), estimatorRow.className = "estimator-row", estimatorRow.innerHTML = `
            <td class="unpending-sales" style="display: flex; align-items: center;">
                <div style="color: var(--rovalra-main-text-color);">
                    <span class="ng-binding">Unpending Robux tomorrow</span>
                </div>
                <span class="icon-moreinfo" style="margin-left: 4px; font-size: 12px; display: inline-flex; align-items: center; color: var(--rovalra-main-text-color); cursor: pointer;"></span>
            </td>
            <td class="amount icon-robux-container">
                ${amountHtml}
            </td>
        `;
      let infoIcon = estimatorRow.querySelector(".icon-moreinfo");
      infoIcon && (addTooltip(infoIcon, tooltipText), infoIcon.dataset.tooltipText = tooltipText);
      try {
        let table = pendingRow.parentNode;
        table && (table.insertBefore(estimatorRow, pendingRow), targetElement.classList.add("robux-estimator-processed"));
      } catch (error) {
        console.error(error);
      }
    }
  }
  __name(injectResultElement, "injectResultElement");
  async function onElementFound2(targetElement) {
    if (targetElement.classList.contains("robux-estimator-processed"))
      return;
    targetElement.classList.add("robux-estimator-processing");
    let rowToInjectInto = targetElement.closest("tr");
    rowToInjectInto || (rowToInjectInto = targetElement), document.body.contains(rowToInjectInto) && injectResultElement(rowToInjectInto, { isLoading: !0 });
    let storedResults = getStoredResults();
    if (storedResults && storedResults.userId === state.userId) {
      injectResultElement(rowToInjectInto, {
        amount: storedResults.estimatedRobux.amount,
        hasEnoughData: storedResults.estimatedRobux.hasEnoughData,
        pendingDays: storedResults.pendingDays,
        lastCalculation: storedResults.lastCalculation
      });
      return;
    }
    let transactions = await fetchTransactions(state.userId), pendingDaysToUse = inferPendingDuration(transactions), unpendingResult = calculateUnpendingRobux(
      transactions,
      pendingDaysToUse
    ), finalResults = {
      amount: unpendingResult.amount,
      hasEnoughData: unpendingResult.hasEnoughData,
      pendingDays: pendingDaysToUse,
      lastCalculation: Date.now()
    };
    storeResults(state.userId, finalResults), injectResultElement(rowToInjectInto, finalResults);
  }
  __name(onElementFound2, "onElementFound");
  function init36() {
    chrome.storage.local.get({ pendingrobuxtrans: !0 }, async (settings) => {
      if (!(!settings.pendingrobuxtrans || !window.location.pathname.includes("/transactions")))
        try {
          let userData = await callRobloxApiJson({
            subdomain: "users",
            endpoint: "/v1/users/authenticated"
          });
          if (state.userId = userData.id, !state.userId) {
            console.error(
              "RoValra: Could not get user ID for pending Robux feature."
            );
            return;
          }
          observeElement(TARGET_ELEMENT_SELECTOR, onElementFound2);
        } catch (e) {
          console.error(
            "RoValra: Failed to initialize pending Robux feature.",
            e
          );
        }
    });
  }
  __name(init36, "init");

  // src/content/features/transactions/totalearned.js
  function onElementFound3(container) {
    let buttonIdentifier = "rovalra-total-earned-btn";
    if (container.querySelector(`.${buttonIdentifier}`)) return;
    let CALCULATION_STATE = {
      IDLE: "IDLE",
      RUNNING: "RUNNING",
      PAUSED: "PAUSED",
      DONE: "DONE",
      ERROR: "ERROR"
    }, state3 = {
      status: CALCULATION_STATE.IDLE,
      totalEarned: 0,
      transactionsProcessed: 0,
      sourceBreakdown: {},
      lastSaleCursor: "",
      lastPayoutCursor: "",
      userId: 0,
      errorMessage: "",
      isRateLimited: !1,
      retryCount: 0
    }, overlayInstance = null, isUIUpdate = !1, animationController = {
      queue: [],
      isAnimating: !1,
      animationInterval: null,
      addBatch(transactions) {
        this.queue.push(...transactions), this.isAnimating || this.start();
      },
      start() {
        this.isAnimating = !0, this.animationInterval = setInterval(() => this.tick(), 20);
      },
      tick() {
        if (this.queue.length === 0) {
          this.stop();
          return;
        }
        let transaction = this.queue.shift();
        if (state3.transactionsProcessed++, transaction.currency && transaction.currency.amount > 0) {
          let amount = transaction.currency.amount;
          state3.totalEarned += amount;
          let type = "Other";
          transaction.category === "GroupPayout" ? type = "Group Payout" : transaction.details && transaction.details.type ? type = transaction.details.type : transaction.transactionType && (type = transaction.transactionType), state3.sourceBreakdown[type] || (state3.sourceBreakdown[type] = { count: 0, robux: 0 }), state3.sourceBreakdown[type].count++, state3.sourceBreakdown[type].robux += amount;
        }
        this.updateDOM();
      },
      stop() {
        clearInterval(this.animationInterval), this.animationInterval = null, this.isAnimating = !1;
      },
      waitUntilIdle() {
        return new Promise((resolve) => {
          let check = /* @__PURE__ */ __name(() => this.isAnimating ? setTimeout(check, 100) : resolve(), "check");
          check();
        });
      },
      updateDOM() {
        let transEl = document.getElementById(
          "rovalra-stat-transactions"
        ), robuxEl = document.getElementById("rovalra-stat-robux"), breakdownEl = document.getElementById(
          "rovalra-earnings-breakdown-container"
        ), robuxIcon = '<span class="icon-robux-16x16" style="vertical-align: -3px;"></span>', formatRobux = /* @__PURE__ */ __name((amount) => `${amount.toLocaleString()} ${robuxIcon}`, "formatRobux");
        if (transEl && (transEl.textContent = state3.transactionsProcessed.toLocaleString()), robuxEl && (robuxEl.innerHTML = purify.sanitize(
          formatRobux(state3.totalEarned)
        )), breakdownEl) {
          let itemsHTML = Object.keys(state3.sourceBreakdown).sort(
            (a, b2) => state3.sourceBreakdown[b2].robux - state3.sourceBreakdown[a].robux
          ).map((type) => {
            let data = state3.sourceBreakdown[type];
            return `<li>
                                <span class="rovalra-breakdown-amount">${type.replace(/([A-Z])/g, " $1").trim()}</span>
                                <span class="rovalra-breakdown-count">x${data.count}</span>
                                <span class="rovalra-breakdown-price">${formatRobux(data.robux)}</span>
                            </li>`;
          }).join("");
          itemsHTML ? breakdownEl.innerHTML = purify.sanitize(
            `<ul class="rovalra-breakdown-list">${itemsHTML}</ul>`
          ) : breakdownEl.innerHTML = purify.sanitize(
            '<div class="text-secondary text-caption-body" style="padding:8px;">No earnings found yet.</div>'
          );
        }
      }
    }, handleOverlayClose = /* @__PURE__ */ __name(() => {
      isUIUpdate || (state3.status === CALCULATION_STATE.RUNNING && pauseCalculation(!0), overlayInstance = null);
    }, "handleOverlayClose"), updateOverlay = /* @__PURE__ */ __name(() => {
      isUIUpdate = !0, overlayInstance && overlayInstance.close();
      let robuxEarnedValue = state3.totalEarned.toLocaleString(), transactionsValue = state3.transactionsProcessed.toLocaleString(), header = "", mainContent = "", actions = [], bodyContainer = document.createElement("div");
      if (bodyContainer.className = "rovalra-overlay-body", state3.status === CALCULATION_STATE.IDLE || state3.status === CALCULATION_STATE.PAUSED) {
        header = "Calculate Earnings";
        let desc = document.createElement("div");
        desc.className = "rovalra-description";
        let btnStack = document.createElement("div");
        if (btnStack.className = "rovalra-action-stack", state3.status === CALCULATION_STATE.PAUSED) {
          desc.textContent = "Calculation paused. Resume to continue counting.";
          let resumeButton = createButton(
            "Resume Calculation",
            "primary",
            { onClick: runCalculation }
          ), newCalcButton = createButton(
            "Start New Calculation",
            "secondary",
            {
              onClick: /* @__PURE__ */ __name(() => {
                state3.status = CALCULATION_STATE.IDLE, updateOverlay();
              }, "onClick")
            }
          );
          btnStack.append(resumeButton, newCalcButton);
        } else {
          desc.textContent = "Calculate your total Robux earned from Sales and Group Payouts.";
          let robuxButton = createButton(
            "Start Calculation",
            "primary",
            { onClick: startCalculation }
          );
          btnStack.append(robuxButton);
        }
        bodyContainer.append(desc, btnStack), mainContent = bodyContainer, overlayInstance = createOverlay({
          title: header,
          bodyContent: mainContent,
          actions: [],
          showLogo: "rovalraIcon",
          onClose: handleOverlayClose
        });
      } else {
        bodyContainer.classList.add("content-top");
        let statsGridHTML = `
                <div class="rovalra-stats-grid">
                    <div class="rovalra-stat-item centered-content">
                        <span class="rovalra-stat-label">Transactions Scanned</span>
                        <span class="rovalra-stat-value" id="rovalra-stat-transactions">${transactionsValue}</span>
                    </div>
                    <div class="rovalra-stat-item centered-content">
                        <span class="rovalra-stat-label">Total Robux Earned</span>
                        <span class="rovalra-stat-value" id="rovalra-stat-robux">${robuxEarnedValue} <span class="icon-robux-16x16" style="vertical-align: -3px;"></span></span>
                    </div>
                </div>`, breakdownsHTML = `
                <div class="rovalra-breakdown-section">
                    <span class="rovalra-stat-label">Earnings Source Breakdown</span>
                    <div id="rovalra-earnings-breakdown-container"></div>
                </div>
            `, statusContent = "";
        switch (state3.status) {
          case CALCULATION_STATE.RUNNING: {
            header = "Calculating Earnings";
            let statusText = "Scanning transaction history...", statusClass = "rovalra-status-text";
            state3.isRateLimited && (statusText = "API rate limited. Still counting...", statusClass = "rovalra-status-text rovalra-rate-limit-text"), statusContent = `
                        <div class="rovalra-status-wrapper">
                            <span class="${statusClass}">${statusText}</span>
                            <span class="spinner spinner-default"></span>
                        </div>`, actions = [];
            break;
          }
          case CALCULATION_STATE.DONE: {
            header = "Calculation Complete";
            let doneText = '<p class="text-body">All earning records have been scanned.</p>', newCalcBtn = createButton(
              "New Calculation",
              "primary",
              {
                onClick: /* @__PURE__ */ __name(() => {
                  state3.status = CALCULATION_STATE.IDLE, updateOverlay();
                }, "onClick")
              }
            ), btnWrapper = document.createElement("div");
            btnWrapper.className = "rovalra-action-stack", btnWrapper.appendChild(newCalcBtn), statusContent = doneText + btnWrapper.outerHTML, actions = [];
            break;
          }
          case CALCULATION_STATE.ERROR:
            header = "An Error Occurred", statusContent = `<p class="text-error">${state3.errorMessage}</p>`, actions = [
              createButton("Retry", "primary", {
                onClick: runCalculation
              })
            ];
            break;
        }
        if (bodyContainer.innerHTML = purify.sanitize(`
                ${statsGridHTML}
                ${breakdownsHTML}
                <div class="rovalra-divider"></div>
                <div class="rovalra-status-content">${statusContent}</div>`), mainContent = bodyContainer, overlayInstance = createOverlay({
          title: header,
          bodyContent: mainContent,
          actions,
          showLogo: "rovalraIcon",
          onClose: handleOverlayClose
        }), state3.status === CALCULATION_STATE.DONE) {
          let btn = bodyContainer.querySelector(
            ".rovalra-action-stack button"
          );
          btn && btn.addEventListener("click", () => {
            state3.status = CALCULATION_STATE.IDLE, updateOverlay();
          });
        }
      }
      animationController.updateDOM(), setTimeout(() => {
        isUIUpdate = !1;
      }, 50);
    }, "updateOverlay"), pauseCalculation = /* @__PURE__ */ __name((silent = !1) => {
      state3.status === CALCULATION_STATE.RUNNING && (state3.status = CALCULATION_STATE.PAUSED, silent || updateOverlay());
    }, "pauseCalculation"), runCalculation = /* @__PURE__ */ __name(async () => {
      overlayInstance || updateOverlay(), state3.status = CALCULATION_STATE.RUNNING, updateOverlay(), totalEarnedButton.style.pointerEvents = "none";
      class PausedException extends Error {
        static {
          __name(this, "PausedException");
        }
        constructor(message) {
          super(message), this.name = "PausedException";
        }
      }
      try {
        if (!state3.userId) {
          let userData = await callRobloxApiJson({
            subdomain: "users",
            endpoint: "/v1/users/authenticated"
          });
          if (!userData.id)
            throw new Error("Could not retrieve user ID.");
          state3.userId = userData.id;
        }
        let transactionTasks = [
          { type: "Sale", cursorKey: "lastSaleCursor", category: "Sale" },
          {
            type: "GroupPayout",
            cursorKey: "lastPayoutCursor",
            category: "GroupPayout"
          }
        ];
        for (let task of transactionTasks) {
          let hasNextPage = !0;
          for (; hasNextPage && state3.status === CALCULATION_STATE.RUNNING; ) {
            if (!document.getElementById("rovalra-stat-transactions"))
              throw new PausedException("Overlay closed.");
            await animationController.waitUntilIdle();
            let cursor = state3[task.cursorKey];
            try {
              let data = await callRobloxApiJson({
                subdomain: "apis",
                endpoint: `/transaction-records/v1/users/${state3.userId}/transactions?cursor=${cursor}&limit=100&transactionType=${task.type}&itemPricingType=PaidAndLimited`
              });
              if (state3.retryCount = 0, state3.isRateLimited && (state3.isRateLimited = !1, updateOverlay()), data.data && data.data.length > 0) {
                let processedData = data.data.map((t) => ({
                  ...t,
                  category: task.category
                }));
                animationController.addBatch(processedData);
              }
              data.nextPageCursor ? state3[task.cursorKey] = data.nextPageCursor : hasNextPage = !1;
            } catch (error) {
              if (error.status === 429 || error.message?.includes("429")) {
                state3.isRateLimited || (state3.isRateLimited = !0, updateOverlay());
                let waitUntil = Date.now() + 5 * 1e3;
                for (; Date.now() < waitUntil; ) {
                  if (state3.status !== CALCULATION_STATE.RUNNING)
                    throw new PausedException("Paused.");
                  await new Promise(
                    (resolve) => setTimeout(resolve, 250)
                  );
                }
                continue;
              } else {
                if (state3.retryCount++, state3.retryCount > 5)
                  throw new Error(
                    `Failed after retries: ${error.message}`
                  );
                await new Promise(
                  (resolve) => setTimeout(resolve, 1e3)
                );
                continue;
              }
            }
          }
        }
        await animationController.waitUntilIdle(), state3.status === CALCULATION_STATE.RUNNING && (state3.status = CALCULATION_STATE.DONE);
      } catch (error) {
        error instanceof PausedException ? await animationController.waitUntilIdle() : (console.error("RoValra Earned: Error:", error), state3.status = CALCULATION_STATE.ERROR, state3.errorMessage = error.message, updateOverlay());
      } finally {
        totalEarnedButton.style.pointerEvents = "auto", state3.isRateLimited = !1, overlayInstance && state3.status !== CALCULATION_STATE.PAUSED && updateOverlay();
      }
    }, "runCalculation"), startCalculation = /* @__PURE__ */ __name(() => {
      state3 = {
        ...state3,
        status: CALCULATION_STATE.IDLE,
        totalEarned: 0,
        transactionsProcessed: 0,
        sourceBreakdown: {},
        lastSaleCursor: "",
        lastPayoutCursor: "",
        errorMessage: "",
        retryCount: 0
      }, runCalculation();
    }, "startCalculation"), totalEarnedButton = createButton("Calculate Earned", "secondary", {
      id: buttonIdentifier,
      onClick: /* @__PURE__ */ __name(() => updateOverlay(), "onClick")
    });
    totalEarnedButton.classList.add("btn-growth-md"), totalEarnedButton.style.marginLeft = "10px", totalEarnedButton.style.marginTop = "auto", totalEarnedButton.style.maxHeight = "36px", observeElement(
      ".rovalra-global-overlay",
      () => {
      },
      // No action needed on add
      {
        onRemove: /* @__PURE__ */ __name(() => {
          isUIUpdate || state3.status === CALCULATION_STATE.RUNNING && pauseCalculation(!0);
        }, "onRemove")
      }
    ), container.appendChild(totalEarnedButton);
  }
  __name(onElementFound3, "onElementFound");
  function init37() {
    chrome.storage.local.get("totalearnedEnabled", (result) => {
      result.totalearnedEnabled && observeElement(
        ".dropdown-container.container-header",
        onElementFound3
      );
    });
  }
  __name(init37, "init");

  // src/content/core/ui/shimmer.js
  function createShimmerGrid(count, itemStyle = { width: "150px", height: "240px" }) {
    let fragment = document.createDocumentFragment();
    for (let i = 0; i < count; i++) {
      let card = document.createElement("div");
      card.style.cssText = `display: flex; flex-direction: column; justify-self: center; width: ${itemStyle.width}; height: ${itemStyle.height};`;
      let thumb = document.createElement("div");
      thumb.className = "thumbnail-2d-container shimmer", thumb.style.cssText = `width: 100%; height: ${itemStyle.width}; margin-bottom: 8px; border-radius: 8px;`;
      let nameBar = document.createElement("div");
      nameBar.className = "thumbnail-2d-container shimmer", nameBar.style.cssText = "width: 90%; height: 14px; margin-top: 8px; border-radius: 4px;", card.append(thumb, nameBar), fragment.appendChild(card);
    }
    return fragment;
  }
  __name(createShimmerGrid, "createShimmerGrid");

  // src/content/features/groups/hiddenGroupGames.js
  var PAGE_SIZE2 = 50, ACCESS_FILTER = { ALL: 1, PUBLIC: 2 }, el = /* @__PURE__ */ __name((tag, className, props = {}, children = []) => {
    let element = document.createElement(tag);
    return className && (element.className = className), Object.assign(element, props), Object.assign(element.style, props.style || {}), children.forEach((child) => child && element.append(child)), element;
  }, "el"), sleep3 = /* @__PURE__ */ __name((ms) => new Promise((r) => setTimeout(r, ms)), "sleep"), groupListCache = /* @__PURE__ */ new Map(), sharedStatsCache = {
    likes: /* @__PURE__ */ new Map(),
    players: /* @__PURE__ */ new Map(),
    updated: /* @__PURE__ */ new Map(),
    thumbnails: /* @__PURE__ */ new Map()
  }, api = {
    async safeGet(endpoint) {
      let delay = 3e3, retries = 5;
      for (let i = 0; i <= retries; i++)
        try {
          return await callRobloxApiJson({
            subdomain: "games",
            endpoint,
            method: "GET"
          });
        } catch (err) {
          if (err.status === 429 && i < retries) {
            await sleep3(delay), delay *= 2;
            continue;
          }
          if (i === retries || err.status !== 429)
            return null;
        }
      return null;
    },
    async getGroupGames(groupId, accessFilter) {
      let cacheKey = `${groupId}:${accessFilter}`;
      if (groupListCache.has(cacheKey))
        return groupListCache.get(cacheKey);
      let fetchPromise = (async () => {
        let games = [], cursor = "";
        do {
          let endpoint = `/v2/groups/${groupId}/gamesV2?accessFilter=${accessFilter}&limit=50&sortOrder=Desc&cursor=${cursor}`, json = await this.safeGet(endpoint);
          if (json?.data) {
            let formattedGames = json.data.map((game) => ({
              ...game,
              rootPlaceId: game.rootPlace?.id
            }));
            games = games.concat(formattedGames), cursor = json.nextPageCursor || "";
          } else
            cursor = "";
        } while (cursor);
        return games;
      })();
      return groupListCache.set(cacheKey, fetchPromise), fetchPromise.catch(() => groupListCache.delete(cacheKey)), fetchPromise;
    },
    async getGameDetails(games, cache) {
      let batch = games.filter((g2) => g2 && !cache.likes.has(g2.id));
      if (batch.length)
        for (let i = 0; i < batch.length; i += 50) {
          let universeIds = batch.slice(i, i + 50).map((g2) => g2.id).join(",");
          if (!universeIds) continue;
          let [votesData, playersData] = await Promise.all([this.safeGet(`/v1/games/votes?universeIds=${universeIds}`), this.safeGet(`/v1/games?universeIds=${universeIds}`)]);
          votesData?.data && votesData.data.forEach((item) => {
            let total = item.upVotes + item.downVotes, ratio = total > 0 ? Math.round(item.upVotes / total * 100) : 0;
            cache.likes.set(item.id, { ratio, total, upVotes: item.upVotes, downVotes: item.downVotes });
          }), playersData?.data && playersData.data.forEach((item) => {
            cache.players.set(item.id, item.playing || 0), cache.updated.set(item.id, item.updated || 0);
          });
        }
    },
    async getThumbnails(games, cache) {
      let uncached = games.filter((g2) => g2 && !cache.has(g2.id));
      if (!uncached.length) return;
      (await fetchThumbnails(uncached, "GameIcon", "256x256")).forEach((data, id) => cache.set(id, data));
    }
  }, HiddenGamesManager = class {
    static {
      __name(this, "HiddenGamesManager");
    }
    constructor(allHiddenGames) {
      this.allGames = allHiddenGames, this.filteredGames = [], this.filters = { sort: "default", order: "desc" }, this.displayedCount = 0, this.isLoading = !1, this.isPaginating = !1, this.cache = sharedStatsCache, this.elements = {}, this.render();
    }
    render() {
      let sortDropdown = createDropdown({
        items: [
          { value: "default", label: "Recently Updated" },
          { value: "like-ratio", label: "Like Ratio" },
          { value: "likes", label: "Likes" },
          { value: "dislikes", label: "Dislikes" },
          { value: "players", label: "Players" },
          { value: "name", label: "Name (Z-A)" }
        ],
        initialValue: "default",
        onValueChange: /* @__PURE__ */ __name((v2) => {
          this.filters.sort = v2, this.applyFilters();
        }, "onValueChange")
      }), orderDropdown = createDropdown({
        items: [
          { value: "desc", label: "Descending" },
          { value: "asc", label: "Ascending" }
        ],
        initialValue: "desc",
        onValueChange: /* @__PURE__ */ __name((v2) => {
          this.filters.order = v2, this.applyFilters();
        }, "onValueChange")
      }), createFilterGroup = /* @__PURE__ */ __name((label, input) => el("div", "", { style: { display: "flex", flexDirection: "column", gap: "4px" } }, [el("label", "", { textContent: label, style: { fontSize: "12px", fontWeight: "500", color: "var(--rovalra-secondary-text-color)" } }), input]), "createFilterGroup"), body = el("div", "", { style: { display: "flex", flexDirection: "column" } }, [
        el(
          "div",
          "rovalra-filters-container",
          {
            style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))", gap: "16px 24px", padding: "16px 24px", backgroundColor: "var(--surface-default)", borderBottom: "1px solid var(--border-default)" }
          },
          [createFilterGroup("Sort", sortDropdown.element), createFilterGroup("Order", orderDropdown.element)]
        ),
        el("div", "hidden-games-list", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(160px, 1fr))", gap: "10px", padding: "24px" } }),
        el("div", "rovalra-load-more-container", { style: { padding: "10px 0", textAlign: "center" } })
      ]);
      this.elements.list = body.querySelector(".hidden-games-list"), this.elements.filters = body.querySelector(".rovalra-filters-container"), this.elements.loader = body.querySelector(".rovalra-load-more-container");
      let { overlay } = createOverlay({
        title: `Hidden Group Experiences (${this.allGames.length} Total)`,
        bodyContent: body,
        maxWidth: "1200px",
        maxHeight: "85vh"
      }), scrollContainer = overlay.querySelector(".rovalra-overlay-body");
      scrollContainer && scrollContainer.addEventListener("scroll", () => {
        let { scrollTop, clientHeight, scrollHeight } = scrollContainer;
        scrollTop + clientHeight >= scrollHeight - 150 && this.loadMore();
      }), this.allGames.length === 0 ? (this.elements.list.innerHTML = purify.sanitize('<p class="btr-no-servers-message">This group has no hidden experiences.</p>'), this.elements.filters.style.display = "none") : this.applyFilters();
    }
    async applyFilters() {
      if (this.isLoading) return;
      this.isLoading = !0, this.isPaginating = !1, this.elements.list.innerHTML = "", this.elements.list.appendChild(createShimmerGrid(12, { width: "150px", height: "240px" })), this.elements.loader.innerHTML = "";
      let { sort, order } = this.filters;
      (sort === "like-ratio" || sort === "likes" || sort === "dislikes" || sort === "players") && await api.getGameDetails(this.allGames, this.cache);
      let orderMultiplier = order === "desc" ? -1 : 1, processed = [...this.allGames];
      sort === "like-ratio" ? processed.sort((a, b2) => ((this.cache.likes.get(a.id)?.ratio || 0) - (this.cache.likes.get(b2.id)?.ratio || 0)) * orderMultiplier) : sort === "likes" ? processed.sort((a, b2) => ((this.cache.likes.get(a.id)?.upVotes || 0) - (this.cache.likes.get(b2.id)?.upVotes || 0)) * orderMultiplier) : sort === "dislikes" ? processed.sort((a, b2) => ((this.cache.likes.get(a.id)?.downVotes || 0) - (this.cache.likes.get(b2.id)?.downVotes || 0)) * orderMultiplier) : sort === "players" ? processed.sort((a, b2) => ((this.cache.players.get(a.id) || 0) - (this.cache.players.get(b2.id) || 0)) * orderMultiplier) : sort === "name" ? processed.sort((a, b2) => a.name.localeCompare(b2.name) * orderMultiplier) : order === "asc" && processed.reverse(), this.filteredGames = processed, this.displayedCount = 0;
      let firstBatch = this.filteredGames.slice(0, PAGE_SIZE2);
      firstBatch.length > 0 && (await Promise.all([api.getGameDetails(firstBatch, this.cache), api.getThumbnails(firstBatch, this.cache.thumbnails)]), this.displayedCount = firstBatch.length), this.isLoading = !1, this.renderList();
    }
    renderList() {
      this.elements.list.innerHTML = "";
      let gamesToShow = this.filteredGames.slice(0, this.displayedCount);
      if (gamesToShow.length === 0) {
        this.elements.list.innerHTML = purify.sanitize('<p class="btr-no-servers-message">No hidden experiences match the current filters.</p>');
        return;
      }
      let fragment = document.createDocumentFragment();
      gamesToShow.forEach((game) => {
        fragment.appendChild(createGameCard({ game, stats: this.cache }));
      }), this.elements.list.appendChild(fragment);
    }
    async loadMore() {
      if (!(this.isLoading || this.isPaginating || this.displayedCount >= this.filteredGames.length)) {
        this.isPaginating = !0, this.elements.loader.innerHTML = purify.sanitize('<p class="rovalra-loading-text">Loading more games...</p>');
        try {
          let nextBatch = this.filteredGames.slice(this.displayedCount, this.displayedCount + PAGE_SIZE2);
          if (nextBatch.length > 0) {
            await Promise.all([api.getGameDetails(nextBatch, this.cache), api.getThumbnails(nextBatch, this.cache.thumbnails)]);
            let fragment = document.createDocumentFragment();
            nextBatch.forEach((game) => {
              fragment.appendChild(createGameCard({ game, stats: this.cache }));
            }), this.elements.list.appendChild(fragment), this.displayedCount += nextBatch.length;
          }
        } catch (err) {
          console.warn("RoValra: Error loading more games", err);
        } finally {
          this.elements.loader.innerHTML = "", this.isPaginating = !1;
        }
      }
    }
  };
  function init38() {
    chrome.storage.local.get(["groupGamesEnabled"], (result) => {
      if (result.groupGamesEnabled !== !0) return;
      let getGroupIdFromUrl2 = /* @__PURE__ */ __name(() => {
        let match = window.location.href.match(/(?:groups|communities)\/(\d+)/);
        return match ? match[1] : null;
      }, "getGroupIdFromUrl"), cleanupLegacyButtons = /* @__PURE__ */ __name((header) => {
        if (!header) return;
        [".rovalra-hidden-games-container", ".hidden-games-button"].forEach((sel) => {
          header.querySelectorAll(sel).forEach((el2) => el2.remove());
        });
      }, "cleanupLegacyButtons"), initHeader = /* @__PURE__ */ __name(async (header) => {
        if (!header || !header.isConnected) return;
        let currentGroupId = getGroupIdFromUrl2();
        if (!currentGroupId) return;
        let attachedGroupId = header.dataset.rovalraGroupId;
        if (attachedGroupId)
          if (attachedGroupId === currentGroupId) {
            let existing = header.querySelectorAll(".rovalra-hidden-games-container");
            if (existing.length > 1)
              cleanupLegacyButtons(header), delete header.dataset.rovalraGroupId;
            else if (existing.length === 1)
              return;
          } else
            cleanupLegacyButtons(header), delete header.dataset.rovalraGroupId;
        header.dataset.rovalraGroupId = currentGroupId;
        try {
          let [allGames, publicGames] = await Promise.all([api.getGroupGames(currentGroupId, ACCESS_FILTER.ALL), api.getGroupGames(currentGroupId, ACCESS_FILTER.PUBLIC)]);
          if (getGroupIdFromUrl2() !== currentGroupId || !header.isConnected)
            return;
          let publicIds = new Set(publicGames.map((g2) => g2.id)), hiddenGames = allGames.filter((g2) => !publicIds.has(g2.id));
          cleanupLegacyButtons(header);
          let btn = createButton("Hidden Experiences", "secondary");
          btn.addEventListener("click", () => new HiddenGamesManager(hiddenGames));
          let container = el(
            "div",
            "rovalra-hidden-games-container",
            {
              style: { marginTop: "10px" }
            },
            [btn]
          ), description = header.querySelector(".description-container");
          description ? description.after(container) : header.appendChild(container);
        } catch {
          delete header.dataset.rovalraGroupId, cleanupLegacyButtons(header);
        }
      }, "initHeader");
      observeElement(".group-profile-header", (header) => {
        initHeader(header);
      });
      let lastUrl = window.location.href, checkForUrlChange = /* @__PURE__ */ __name(() => {
        let currentUrl = window.location.href;
        if (currentUrl !== lastUrl) {
          lastUrl = currentUrl;
          let header = document.querySelector(".group-profile-header");
          header && initHeader(header);
        }
      }, "checkForUrlChange");
      setInterval(checkForUrlChange, 1e3), window.addEventListener("popstate", checkForUrlChange);
    });
  }
  __name(init38, "init");

  // src/content/features/groups/Antibots.js
  var userPermissions = { canBan: null, canKick: null, lastChecked: 0 }, quickActionState = {
    cursor: null,
    isLoading: !1,
    hasMore: !0,
    groupId: null,
    abortController: null,
    scrollListener: null,
    members: []
  }, antiBotState = {
    abortController: null,
    isScanning: !1,
    allMembersCache: [],
    likelyBotsCache: [],
    thumbnailCache: {},
    hashesCache: {},
    renderCursor: 0,
    scrollListener: null
  }, isInitialized5 = !1;
  async function getFeatureSettings() {
    return new Promise((resolve) => {
      chrome && chrome.storage && chrome.storage.local ? chrome.storage.local.get({ antibotsEnabled: !0, QuickActionsEnabled: !0 }, resolve) : resolve({ antibotsEnabled: !0, QuickActionsEnabled: !0 });
    });
  }
  __name(getFeatureSettings, "getFeatureSettings");
  async function checkUserPermissions() {
    let now = Date.now();
    if (userPermissions.lastChecked && now - userPermissions.lastChecked < 3e5) return userPermissions;
    let groupId = getGroupIdFromUrl();
    if (!groupId) return { canBan: !1, canKick: !1 };
    try {
      let permissions = (await callRobloxApiJson({ subdomain: "groups", endpoint: `/v1/groups/${groupId}/membership` })).permissions.groupMembershipPermissions;
      return userPermissions = { canBan: permissions.banMembers === !0, canKick: permissions.removeMembers === !0, lastChecked: now }, userPermissions;
    } catch {
      return { canBan: !1, canKick: !1 };
    }
  }
  __name(checkUserPermissions, "checkUserPermissions");
  async function getGroupDetails(groupId) {
    return await callRobloxApiJson({ subdomain: "groups", endpoint: `/v1/groups/${groupId}` });
  }
  __name(getGroupDetails, "getGroupDetails");
  async function banUser(groupId, userId) {
    return await callRobloxApiJson({ subdomain: "groups", endpoint: `/v1/groups/${groupId}/bans/${userId}`, method: "POST", body: {} });
  }
  __name(banUser, "banUser");
  async function kickUser(groupId, userId) {
    return await callRobloxApiJson({ subdomain: "groups", endpoint: `/v1/groups/${groupId}/users/${userId}`, method: "DELETE" });
  }
  __name(kickUser, "kickUser");
  async function showActionOverlay(selectedMembers, isFromBotScan = !1) {
    if (!selectedMembers.length) return;
    membersToAction = selectedMembers;
    let bodyContainer = document.createElement("div");
    bodyContainer.innerHTML = purify.sanitize(`
        <div class="rovalra-action-description">Review ${selectedMembers.length} selected members:</div>
        <ul class="rovalra-action-summary-list">
            ${selectedMembers.map((m2) => `<li>${m2.user.displayName} (@${m2.user.username})</li>`).join("")}
        </ul>
        ${isFromBotScan ? '<div class="rovalra-action-bot-warning rovalra-ban-warning"><strong>Warning:</strong> Ensure these are bots before taking action.</div>' : ""}
        <div class="rovalra-action-permission-warning rovalra-ban-warning" style="display:none"></div>
        <div class="rovalra-action-progress-container" style="display:none">
            <div class="rovalra-action-status-text"></div>
            <div class="rovalra-action-progress-bar-container">
                <div class="rovalra-action-progress-bar"></div>
            </div>
        </div>
    `);
    let btnBan = createBtn("Ban Members", "btn-alert-md"), btnKick = createBtn("Kick Members", "btn-control-md"), btnCancel = createBtn("Cancel", "btn-secondary-md"), overlayInstance = createOverlay({
      title: `Action Required (${selectedMembers.length})`,
      bodyContent: bodyContainer,
      actions: [btnBan, btnKick, btnCancel],
      showLogo: !0,
      preventBackdropClose: !0
    }), permissions = await checkUserPermissions(), warningEl = bodyContainer.querySelector(".rovalra-action-permission-warning");
    permissions.canBan || (btnBan.disabled = !0), permissions.canKick || (btnKick.disabled = !0), !permissions.canBan && !permissions.canKick && (warningEl.textContent = "You do not have permission to ban or kick members.", warningEl.style.display = "block"), btnBan.onclick = () => showDoubleConfirmOverlay("ban", isFromBotScan), btnKick.onclick = () => showDoubleConfirmOverlay("kick", isFromBotScan), btnCancel.onclick = () => {
      overlayInstance.close(), window.rovalra.ui.actionOverlay = null;
    }, window.rovalra.ui.actionOverlay = overlayInstance, btnCancel.classList.add("rovalra-action-cancel-btn"), btnBan.classList.add("rovalra-action-ban-btn"), btnKick.classList.add("rovalra-action-kick-btn");
  }
  __name(showActionOverlay, "showActionOverlay");
  function showDoubleConfirmOverlay(actionType, isFromBotScan) {
    let memberCount = membersToAction.length, bodyContent = document.createElement("div"), message = actionType === "ban" ? `You are about to <strong>ban ${memberCount} member(s)</strong>. They will be permanently blocked.` : `You are about to <strong>kick ${memberCount} member(s)</strong>. They can rejoin anytime.`;
    actionType === "ban" && isFromBotScan && (message += '<br><br><div class="rovalra-ban-warning" style="margin-top:0;"><strong>Reminder:</strong> Verify bot scores before banning.</div>'), bodyContent.innerHTML = purify.sanitize(`<div id="rovalra-double-confirm-message" style="text-align:center; font-size:16px;">${message}</div>`);
    let btnConfirm = createBtn(`Yes, ${actionType.charAt(0).toUpperCase() + actionType.slice(1)}`, "btn-alert-md"), btnCancel = createBtn("Cancel", "btn-secondary-md"), overlayInstance = createOverlay({
      title: "Confirm Action",
      bodyContent,
      actions: [btnConfirm, btnCancel],
      maxWidth: "400px"
    });
    window.rovalra.ui.doubleConfirmOverlay = overlayInstance, btnConfirm.onclick = () => {
      overlayInstance.close(), processMembers(actionType);
    }, btnCancel.onclick = () => overlayInstance.close();
  }
  __name(showDoubleConfirmOverlay, "showDoubleConfirmOverlay");
  function createBtn(text2, className) {
    let btn = document.createElement("button");
    return btn.textContent = text2, btn.className = className, btn;
  }
  __name(createBtn, "createBtn");
  var membersToAction = [];
  async function processMembers(actionType) {
    let groupId = getGroupIdFromUrl();
    if (!groupId) return;
    let overlayInstance = window.rovalra.ui.actionOverlay;
    if (!overlayInstance || !overlayInstance.overlay) return;
    let overlayEl = overlayInstance.overlay, totalMembers = membersToAction.length, successCount = 0, failedMembers = [], progressBar = overlayEl.querySelector(".rovalra-action-progress-bar"), statusText = overlayEl.querySelector(".rovalra-action-status-text"), progressContainer = overlayEl.querySelector(".rovalra-action-progress-container"), summaryList = overlayEl.querySelector(".rovalra-action-summary-list"), warning = overlayEl.querySelector(".rovalra-action-bot-warning"), btns = overlayEl.querySelectorAll("button:not(.rovalra-action-cancel-btn)");
    if (summaryList && (summaryList.style.display = "none"), warning && (warning.style.display = "none"), btns.forEach((b2) => b2.style.display = "none"), progressContainer) {
      progressContainer.style.display = "block";
      let barContainer = progressContainer.querySelector(".rovalra-action-progress-bar-container");
      barContainer && (barContainer.style.display = "block");
    }
    progressBar && (progressBar.style.width = "0%");
    let startTime = Date.now();
    for (let i = 0; i < totalMembers; i++) {
      if (!window.rovalra.ui.actionOverlay || !document.body.contains(overlayEl)) return;
      let user = membersToAction[i].user, success = !1, elapsedTime = (Date.now() - startTime) / 1e3, avgTimePerUser = i > 0 ? elapsedTime / i : 2, remainingTime = Math.round(avgTimePerUser * (totalMembers - i));
      statusText && (statusText.textContent = `Processing ${i + 1} of ${totalMembers}: ${user.displayName}... ETA: ${remainingTime}s`);
      let retries = 0;
      for (; ; ) {
        if (!window.rovalra.ui.actionOverlay || !document.body.contains(overlayEl)) return;
        try {
          actionType === "ban" ? await banUser(groupId, user.userId) : actionType === "kick" && await kickUser(groupId, user.userId), success = !0;
          break;
        } catch (error) {
          if (error && (error.status == 429 || error.message && error.message.includes("429"))) {
            retries++;
            let delay = Math.min(retries, 10);
            statusText && (statusText.textContent = `Rate limited. Retrying in ${delay}s...`), await new Promise((r) => setTimeout(r, 1e3 * delay));
            continue;
          }
          let reason = error.message || "Unknown Error";
          error.status && (reason = `API Error ${error.status}`), failedMembers.push({ user, reason });
          break;
        }
      }
      if (success) {
        successCount++, antiBotState.allMembersCache = antiBotState.allMembersCache.filter((m2) => m2.user.userId !== user.userId), antiBotState.likelyBotsCache = antiBotState.likelyBotsCache.filter((m2) => m2.user.userId !== user.userId), quickActionState.members = quickActionState.members.filter((m2) => m2.user.userId !== user.userId);
        let cardElement = document.getElementById(`quick-ban-card-${user.userId}`);
        if (cardElement) {
          cardElement.classList.add("processed"), cardElement.classList.remove("selected");
          let radio = cardElement.querySelector('button[role="checkbox"]');
          radio && radio.setChecked && radio.setChecked(!1);
        }
      }
      progressBar && (progressBar.style.width = `${(i + 1) / totalMembers * 100}%`);
    }
    let finalMessage = `${successCount} of ${totalMembers} members were successfully ${actionType}ed.`;
    failedMembers.length > 0 && (finalMessage += `
${failedMembers.length} failed.`), statusText && (statusText.innerHTML = purify.sanitize(finalMessage.replace(`
`, "<br>")));
    let cancelBtn = overlayEl.querySelector(".rovalra-action-cancel-btn");
    cancelBtn && (cancelBtn.textContent = "Close", cancelBtn.style.display = "block"), successCount > 0 && showReviewPopup("antibots"), updateActionCount();
  }
  __name(processMembers, "processMembers");
  function createMemberCard(member, thumbnail, isBot = !1) {
    let li = document.createElement("li");
    li.className = "list-item avatar-card quick-ban-card", li.id = `quick-ban-card-${member.user.userId}`;
    let container = document.createElement("div");
    container.className = "avatar-card-container", container.style.position = "relative";
    let radio = createRadioButton({
      id: `rb-${member.user.userId}`,
      checked: !1,
      onChange: /* @__PURE__ */ __name((isChecked) => {
        li.classList.toggle("selected", isChecked), updateActionCount();
      }, "onChange")
    });
    radio.style.position = "absolute", radio.style.top = "4px", radio.style.right = "4px", radio.style.zIndex = "10";
    let content = document.createElement("div");
    content.className = "avatar-card-content";
    let avatarDiv = document.createElement("div");
    avatarDiv.className = "avatar avatar-card-fullbody";
    let thumbContainer = document.createElement("span");
    thumbContainer.className = "thumbnail-2d-container", thumbContainer.style.cssText = "display:flex;justify-content:center;align-items:center;width:100%;height:100%;";
    let thumbEl = createThumbnailElement(thumbnail, member.user.displayName);
    thumbContainer.appendChild(thumbEl), avatarDiv.appendChild(thumbContainer);
    let captionDiv = document.createElement("div");
    captionDiv.className = "avatar-card-caption";
    let span = document.createElement("span"), nameDiv = document.createElement("div");
    nameDiv.className = "avatar-name text-overflow", nameDiv.textContent = member.user.displayName;
    let tagDiv = document.createElement("div");
    if (tagDiv.className = "avatar-card-label text-overflow", tagDiv.textContent = `@${member.user.username}`, span.append(nameDiv, tagDiv), isBot) {
      let { score } = member, scoreColor = score >= 85 ? "#e34040" : score >= 60 ? "#f58d42" : "#f5c542", scoreDiv = document.createElement("div");
      scoreDiv.className = "avatar-card-label", scoreDiv.style.cssText = `color:${scoreColor};font-weight:bold;`, scoreDiv.textContent = `Score: ${score}/100`, span.appendChild(scoreDiv);
    }
    return captionDiv.appendChild(span), content.append(avatarDiv, captionDiv), container.append(radio, content), li.appendChild(container), li.addEventListener("click", (e) => {
      let currentState = radio.getAttribute("aria-checked") === "true";
      radio.setChecked(!currentState), li.classList.toggle("selected", !currentState), updateActionCount();
    }), li;
  }
  __name(createMemberCard, "createMemberCard");
  function updateActionCount() {
    ["rovalra-quick-ban-list", "rovalra-bot-list"].forEach((listId) => {
      let container = document.getElementById(listId);
      if (!container || container.offsetParent === null) return;
      let btnId = listId === "rovalra-quick-ban-list" ? "rovalra-quick-ban-confirm-btn" : "rovalra-antibot-confirm-btn", btn = document.getElementById(btnId);
      if (container && btn) {
        let count = container.querySelectorAll('button[role="checkbox"][aria-checked="true"]').length;
        btn.textContent = `Action (${count})`, btn.disabled = count === 0;
        let selectAllBtnId = listId === "rovalra-quick-ban-list" ? "rovalra-quick-ban-select-all-btn" : "rovalra-antibot-select-all-btn", selectAllBtn = document.getElementById(selectAllBtnId);
        if (selectAllBtn) {
          let total = container.querySelectorAll(".quick-ban-card").length;
          selectAllBtn.textContent = count > 0 && count === total ? "Unselect All" : "Select All";
        }
      }
    });
  }
  __name(updateActionCount, "updateActionCount");
  async function addFeatureButtons(searchContainer) {
    if (document.getElementById("rovalra-button-container")) return;
    let settings = await getFeatureSettings();
    if (document.getElementById("rovalra-button-container") || !settings.antibotsEnabled && !settings.QuickActionsEnabled) return;
    let buttonContainer = document.createElement("div");
    buttonContainer.id = "rovalra-button-container", buttonContainer.style.cssText = "display: flex; gap: 5px;";
    let antiBotsButton, banByScoreButton, antiBotSelectAllButton, antiBotConfirmButton, quickBanButton, quickBanSelectAllButton, quickBanConfirmButton;
    function createBtnControl(id, text2, extraClass = "", hidden = !1) {
      let btn = document.createElement("button");
      return btn.id = id, btn.className = `btn-control btn-control-sm ${extraClass}`, btn.textContent = text2, hidden && (btn.style.display = "none"), btn;
    }
    if (__name(createBtnControl, "createBtnControl"), settings.antibotsEnabled && (antiBotsButton = createBtnControl("rovalra-anti-bots-btn", "Anti Bots"), banByScoreButton = createBtnControl("rovalra-ban-by-score-btn", "Ban by Score", "btn-alert-sm", !0), antiBotSelectAllButton = createBtnControl("rovalra-antibot-select-all-btn", "Select All", "", !0), antiBotConfirmButton = createBtnControl("rovalra-antibot-confirm-btn", "Action (0)", "btn-alert-sm", !0), buttonContainer.append(antiBotSelectAllButton, antiBotConfirmButton, banByScoreButton, antiBotsButton)), settings.QuickActionsEnabled && (quickBanButton = createBtnControl("rovalra-quick-ban-btn", "Quick Action", "btn-secondary-sm"), quickBanSelectAllButton = createBtnControl("rovalra-quick-ban-select-all-btn", "Select All", "", !0), quickBanConfirmButton = createBtnControl("rovalra-quick-ban-confirm-btn", "Action (0)", "btn-alert-sm", !0), buttonContainer.prepend(quickBanSelectAllButton, quickBanConfirmButton, quickBanButton)), buttonContainer.children.length > 0) {
      let parentContainer = searchContainer.parentNode;
      parentContainer.style.display = "flex", parentContainer.style.alignItems = "center";
      let spacer = document.createElement("div");
      spacer.id = "rovalra-button-spacer", spacer.style.flexGrow = "1", parentContainer.insertBefore(spacer, searchContainer), parentContainer.insertBefore(buttonContainer, searchContainer);
    }
    let membersTitleElement = document.querySelector("h2.group-title-with-input"), originalMembersTitleText = membersTitleElement ? membersTitleElement.textContent : "Members", originalMemberList = document.querySelector(".hlist.avatar-cards"), roleDropdown = document.querySelector(".input-group-btn.group-dropdown"), botMemberListContainer, quickBanListContainer, isBotDetectionActive = !1, isQuickBanActive = !1, resetUiState = /* @__PURE__ */ __name(() => {
      quickActionState.scrollListener && (window.removeEventListener("scroll", quickActionState.scrollListener), quickActionState.scrollListener = null), quickActionState.abortController && (quickActionState.abortController.abort(), quickActionState.abortController = null), quickActionState.members = [], quickActionState.cursor = null, quickBanListContainer && (quickBanListContainer.remove(), quickBanListContainer = null), antiBotState.abortController && (antiBotState.abortController.abort(), antiBotState.abortController = null), antiBotState.scrollListener && (window.removeEventListener("scroll", antiBotState.scrollListener), antiBotState.scrollListener = null), antiBotState.hashesCache = {}, botMemberListContainer && (botMemberListContainer.remove(), botMemberListContainer = null), [
        banByScoreButton,
        quickBanConfirmButton,
        quickBanSelectAllButton,
        antiBotConfirmButton,
        antiBotSelectAllButton
      ].forEach((b2) => {
        b2 && (b2.style.display = "none");
      }), antiBotsButton && (antiBotsButton.textContent = "Anti Bots", antiBotsButton.disabled = !1, antiBotsButton.style.display = ""), quickBanButton && (quickBanButton.textContent = "Quick Action", quickBanButton.style.display = ""), membersTitleElement && (membersTitleElement.textContent = originalMembersTitleText), originalMemberList && (originalMemberList.style.display = ""), searchContainer && (searchContainer.style.display = ""), roleDropdown && (roleDropdown.style.display = ""), isBotDetectionActive = !1, isQuickBanActive = !1;
    }, "resetUiState");
    function toggleSelectAll(container, btn) {
      if (!container) return;
      let shouldSelect = btn.textContent === "Select All";
      container.querySelectorAll('button[role="checkbox"]').forEach((radio) => {
        radio.setChecked(shouldSelect);
        let card = radio.closest(".quick-ban-card");
        card && card.classList.toggle("selected", shouldSelect);
      }), updateActionCount();
    }
    __name(toggleSelectAll, "toggleSelectAll"), quickBanSelectAllButton && (quickBanSelectAllButton.onclick = () => toggleSelectAll(quickBanListContainer, quickBanSelectAllButton)), antiBotSelectAllButton && (antiBotSelectAllButton.onclick = () => toggleSelectAll(botMemberListContainer, antiBotSelectAllButton));
    function getSelectedMembers(cache) {
      let selectedIds = /* @__PURE__ */ new Set(), container = isQuickBanActive ? quickBanListContainer : botMemberListContainer;
      return container ? (container.querySelectorAll('button[role="checkbox"][aria-checked="true"]').forEach((btn) => {
        let userId = parseInt(btn.id.replace("rb-", ""));
        selectedIds.add(userId);
      }), cache.filter((m2) => selectedIds.has(m2.user.userId))) : [];
    }
    __name(getSelectedMembers, "getSelectedMembers"), quickBanConfirmButton && (quickBanConfirmButton.onclick = () => {
      showActionOverlay(getSelectedMembers(quickActionState.members), !1);
    }), antiBotConfirmButton && (antiBotConfirmButton.onclick = () => {
      showActionOverlay(getSelectedMembers(antiBotState.likelyBotsCache), !0);
    }), quickBanButton && (quickBanButton.onclick = async function() {
      if (isQuickBanActive) {
        resetUiState();
        return;
      }
      resetUiState(), isQuickBanActive = !0, quickBanButton.textContent = "Cancel", antiBotsButton && (antiBotsButton.style.display = "none"), searchContainer && (searchContainer.style.display = "none"), roleDropdown && (roleDropdown.style.display = "none"), originalMemberList.style.display = "none", quickBanListContainer = document.createElement("ul"), quickBanListContainer.id = "rovalra-quick-ban-list", quickBanListContainer.className = "hlist avatar-cards", originalMemberList.parentNode.insertBefore(quickBanListContainer, originalMemberList.nextSibling), quickActionState.groupId = getGroupIdFromUrl(), quickActionState.cursor = null, quickActionState.hasMore = !0, quickActionState.isLoading = !1, quickActionState.abortController = new AbortController(), membersTitleElement && (membersTitleElement.textContent = "Loading Members..."), await loadNextQuickBanPage(), quickActionState.scrollListener = () => {
        isQuickBanActive && window.innerHeight + window.scrollY >= document.body.offsetHeight - 500 && loadNextQuickBanPage();
      }, window.addEventListener("scroll", quickActionState.scrollListener), quickBanConfirmButton.style.display = "", quickBanConfirmButton.disabled = !0, quickBanSelectAllButton.style.display = "", quickBanSelectAllButton.textContent = "Select All";
    });
    async function loadNextQuickBanPage() {
      if (quickActionState.isLoading || !quickActionState.hasMore || !isQuickBanActive) return;
      quickActionState.isLoading = !0;
      let loader = quickBanListContainer.querySelector(".rovalra-loading-more");
      loader || (loader = document.createElement("div"), loader.className = "rovalra-loading-more", quickBanListContainer.appendChild(loader));
      try {
        let signal = quickActionState.abortController.signal, pageData = await fetchMemberPageWithRetry(quickActionState.groupId, quickActionState.cursor);
        if (signal.aborted) {
          loader.remove();
          return;
        }
        let newMembers = pageData.data || [];
        if (quickActionState.cursor = pageData.nextPageCursor, quickActionState.hasMore = !!pageData.nextPageCursor, loader.remove(), newMembers.length > 0) {
          quickActionState.members = quickActionState.members.concat(newMembers);
          let ids = newMembers.map((m2) => m2.user.userId), thumbnails = await getThumbnailsWithCache(ids, signal);
          if (signal.aborted) return;
          newMembers.forEach((member) => {
            let thumb = thumbnails.find((t) => t && t.targetId === member.user.userId), card = createMemberCard(member, thumb);
            quickBanListContainer.appendChild(card);
          }), equalizeCardHeights2(quickBanListContainer), membersTitleElement && (membersTitleElement.textContent = `Select Members for Action (${quickActionState.members.length} Loaded)`);
        } else quickActionState.members.length === 0 && (quickBanListContainer.innerHTML = purify.sanitize('<div style="text-align: center; padding: 20px;">No members found.</div>'));
      } catch (e) {
        loader.remove(), e.name !== "AbortError" && console.error(e);
      } finally {
        quickActionState.isLoading = !1;
      }
    }
    __name(loadNextQuickBanPage, "loadNextQuickBanPage");
    function renderNextBotBatch() {
      if (!botMemberListContainer) return;
      let BATCH_SIZE2 = 50, totalBots = antiBotState.likelyBotsCache.length;
      if (antiBotState.renderCursor >= totalBots) return;
      let nextBatch = antiBotState.likelyBotsCache.slice(
        antiBotState.renderCursor,
        antiBotState.renderCursor + BATCH_SIZE2
      ), fragment = document.createDocumentFragment();
      nextBatch.forEach((member) => {
        let thumb = antiBotState.thumbnailCache[member.user.userId], card = createMemberCard(member, thumb, !0);
        fragment.appendChild(card);
      }), botMemberListContainer.appendChild(fragment), antiBotState.renderCursor += nextBatch.length, equalizeCardHeights2(botMemberListContainer);
    }
    __name(renderNextBotBatch, "renderNextBotBatch"), antiBotsButton && (antiBotsButton.onclick = async function() {
      if (isBotDetectionActive) {
        resetUiState();
        return;
      }
      resetUiState(), isBotDetectionActive = !0, antiBotsButton.textContent = "Cancel", quickBanButton && (quickBanButton.style.display = "none"), searchContainer && (searchContainer.style.display = "none"), roleDropdown && (roleDropdown.style.display = "none"), originalMemberList.style.display = "none", botMemberListContainer = document.createElement("ul"), botMemberListContainer.id = "rovalra-bot-list", botMemberListContainer.className = "hlist avatar-cards", originalMemberList.parentNode.insertBefore(botMemberListContainer, originalMemberList.nextSibling), antiBotState.abortController = new AbortController();
      let signal = antiBotState.abortController.signal, processedImageCount = 0, loadedMemberCount = 0, totalGroupMembers = 0, updateLoadingStatus = /* @__PURE__ */ __name(() => {
        if (!membersTitleElement) return;
        let pct = totalGroupMembers > 0 ? Math.round(loadedMemberCount / totalGroupMembers * 100) : 0;
        membersTitleElement.innerHTML = purify.sanitize(`
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span>Scanned: ${loadedMemberCount} (${pct}%) | Analyzed: ${processedImageCount}</span>
                    </div>`);
      }, "updateLoadingStatus"), imageProcessingTasks = [], processBatch2 = /* @__PURE__ */ __name(async (members) => {
        try {
          let ids = members.map((m2) => m2.user.userId), thumbnails = await getThumbnailsWithCache(ids, signal);
          if (signal.aborted) return;
          let hashes = await calculateAllHashes(thumbnails);
          if (signal.aborted) return;
          hashes.forEach((h) => {
            h && h.hash && (antiBotState.hashesCache[h.id] = h);
          }), processedImageCount += members.length, updateLoadingStatus();
        } catch (e) {
          console.warn("Batch processing error", e);
        }
      }, "processBatch");
      try {
        let groupId = getGroupIdFromUrl();
        membersTitleElement && (membersTitleElement.textContent = "Initializing Scan..."), totalGroupMembers = (await getGroupDetails(groupId)).memberCount || 1;
        let defaultRole = (await fetchGroupRoles(groupId)).find((r) => r.rank === 1), cursor = null, more = !0;
        for (antiBotState.allMembersCache = []; more; ) {
          if (signal.aborted) throw new Error("Aborted");
          await new Promise((r) => setTimeout(r, 200));
          try {
            let data = await fetchMemberPageWithRetry(groupId, cursor);
            if (!data || !data.data) {
              console.warn("Empty data received, stopping scan.");
              break;
            }
            let pageMembers = data.data;
            antiBotState.allMembersCache = antiBotState.allMembersCache.concat(pageMembers), loadedMemberCount = antiBotState.allMembersCache.length, updateLoadingStatus();
            let candidates = pageMembers.filter((m2) => m2.role.id === defaultRole?.id);
            if (candidates.length > 0) {
              let task = processBatch2(candidates);
              imageProcessingTasks.push(task), imageProcessingTasks.length > 10 && await imageProcessingTasks.shift();
            }
            cursor = data.nextPageCursor, more = !!cursor;
          } catch (err) {
            console.error("Error fetching page:", err);
            break;
          }
        }
        if (membersTitleElement && (membersTitleElement.innerHTML = '<span class="spinner spinner-dots" style="width:24px;height:24px;"></span> Finalizing analysis...'), await Promise.all(imageProcessingTasks), signal.aborted) throw new Error("Aborted");
        let potentialBots = antiBotState.allMembersCache.filter((m2) => m2.role.id === defaultRole?.id), hashList = potentialBots.map((m2) => antiBotState.hashesCache[m2.user.userId]).filter(Boolean), groups = findSimilarAvatars(hashList);
        if (antiBotState.likelyBotsCache = analyzeMembersForBotScore(potentialBots, groups), !isBotDetectionActive) return;
        membersTitleElement && (membersTitleElement.textContent = antiBotState.likelyBotsCache.length > 0 ? `${antiBotState.likelyBotsCache.length} Likely Bots Found` : "No Likely Bots Found"), antiBotState.likelyBotsCache.length > 0 ? (banByScoreButton.style.display = "", antiBotSelectAllButton.style.display = "", antiBotSelectAllButton.textContent = "Select All", antiBotConfirmButton.style.display = "", antiBotConfirmButton.disabled = !0, antiBotState.renderCursor = 0, renderNextBotBatch(), antiBotState.scrollListener = () => {
          isBotDetectionActive && window.innerHeight + window.scrollY >= document.body.offsetHeight - 500 && renderNextBotBatch();
        }, window.addEventListener("scroll", antiBotState.scrollListener)) : botMemberListContainer.innerHTML = purify.sanitize('<div style="text-align: center; padding: 20px;">No bots detected.</div>');
      } catch (e) {
        e.message !== "Aborted" ? (antiBotsButton.textContent = "Error - Retry", console.error(e), membersTitleElement && (membersTitleElement.textContent = "Error during scan.")) : resetUiState();
      }
    }), banByScoreButton && (banByScoreButton.onclick = () => {
      if (antiBotState.likelyBotsCache.length === 0) return;
      let bodyContainer = document.createElement("div");
      bodyContainer.innerHTML = purify.sanitize(`
                <div class="rovalra-score-selector-container">
                    <label>Minimum Bot Score: <span id="rovalra-score-value">50</span></label>
                    <input type="range" id="rovalra-score-slider" class="rovalra-slider" min="20" max="100" value="50">
                    <div class="rovalra-score-impact-text">
                        This will select approximately <span id="rovalra-score-ban-count">0</span> members.
                    </div>
                </div>
            `);
      let btnConfirm = createBtn("Confirm", "btn-alert-md"), btnCancel = createBtn("Cancel", "btn-secondary-md"), overlayInstance = createOverlay({
        title: "Ban/Kick by Score",
        bodyContent: bodyContainer,
        actions: [btnConfirm, btnCancel]
      }), slider = bodyContainer.querySelector("#rovalra-score-slider"), valDisplay = bodyContainer.querySelector("#rovalra-score-value"), countDisplay = bodyContainer.querySelector("#rovalra-score-ban-count"), update = /* @__PURE__ */ __name(() => {
        let min = parseInt(slider.value, 10);
        valDisplay.textContent = min;
        let matches = antiBotState.likelyBotsCache.filter((m2) => m2.score >= min);
        countDisplay.textContent = matches.length, btnConfirm.textContent = `Confirm (${matches.length})`, btnConfirm.disabled = matches.length === 0, overlayInstance._tempMatches = matches;
      }, "update");
      slider.oninput = update, update(), btnConfirm.onclick = () => {
        let matches = overlayInstance._tempMatches || [];
        matches.length > 0 && (overlayInstance.close(), showActionOverlay(matches, !0));
      }, btnCancel.onclick = () => overlayInstance.close();
    });
  }
  __name(addFeatureButtons, "addFeatureButtons");
  function getGroupIdFromUrl() {
    let match = window.location.href.match(/id=(\d+)/);
    return match ? match[1] : null;
  }
  __name(getGroupIdFromUrl, "getGroupIdFromUrl");
  async function fetchMemberPageWithRetry(groupId, cursor, retries = 3) {
    let params = new URLSearchParams({
      limit: "100",
      sortOrder: "Desc"
    });
    cursor && params.append("cursor", cursor);
    let endpoint = `/v1/groups/${groupId}/users?${params.toString()}`;
    for (let i = 0; i < retries; i++)
      try {
        return await callRobloxApiJson({
          subdomain: "groups",
          endpoint
        });
      } catch (error) {
        if (i === retries - 1) throw error;
        await new Promise((r) => setTimeout(r, 1e3));
      }
  }
  __name(fetchMemberPageWithRetry, "fetchMemberPageWithRetry");
  async function fetchGroupRoles(groupId) {
    return (await callRobloxApiJson({ subdomain: "groups", endpoint: `/v1/groups/${groupId}/roles` })).roles || [];
  }
  __name(fetchGroupRoles, "fetchGroupRoles");
  async function getThumbnailsWithCache(userIds, signal) {
    let missingIds = userIds.filter((id) => !antiBotState.thumbnailCache[id]);
    if (missingIds.length > 0) {
      let items = missingIds.map((id) => ({ id }));
      (await fetchThumbnails(items, "AvatarHeadshot", "150x150", !1, signal)).forEach((data, id) => {
        antiBotState.thumbnailCache[id] = data;
      });
    }
    return userIds.map((id) => antiBotState.thumbnailCache[id]).filter(Boolean);
  }
  __name(getThumbnailsWithCache, "getThumbnailsWithCache");
  async function calculateAllHashes(thumbnails) {
    return await Promise.all(thumbnails.map((t) => t?.imageUrl && t.state !== "Blocked" ? calculateImageHash(t.imageUrl).then((h) => ({ id: t.targetId, hash: h })) : Promise.resolve({ id: t?.targetId, hash: null })));
  }
  __name(calculateAllHashes, "calculateAllHashes");
  async function calculateImageHash(url) {
    try {
      let img = new Image();
      return img.crossOrigin = "Anonymous", new Promise((res) => {
        img.onload = () => {
          let c = document.createElement("canvas");
          c.width = 9, c.height = 8;
          let ctx = c.getContext("2d");
          ctx.drawImage(img, 0, 0, 9, 8);
          let d = ctx.getImageData(0, 0, 9, 8).data, gray = [];
          for (let i = 0; i < d.length; i += 4) gray.push(0.299 * d[i] + 0.587 * d[i + 1] + 0.114 * d[i + 2]);
          let h = "";
          for (let y2 = 0; y2 < 8; y2++) for (let x2 = 0; x2 < 8; x2++) h += gray[y2 * 9 + x2] < gray[y2 * 9 + x2 + 1] ? "1" : "0";
          res(h);
        }, img.onerror = () => res(null), img.src = url;
      });
    } catch {
      return null;
    }
  }
  __name(calculateImageHash, "calculateImageHash");
  function findSimilarAvatars(hashes) {
    let valid = hashes.filter((h) => h?.hash), groups = [], processed = /* @__PURE__ */ new Set();
    for (let i = 0; i < valid.length; i++) {
      if (processed.has(i)) continue;
      let group = [valid[i]];
      processed.add(i);
      for (let j2 = i + 1; j2 < valid.length; j2++)
        if (!processed.has(j2)) {
          let dist = 0, h1 = valid[i].hash, h2 = valid[j2].hash;
          for (let k2 = 0; k2 < Math.min(h1.length, h2.length); k2++) h1[k2] !== h2[k2] && dist++;
          dist <= 5 && (group.push(valid[j2]), processed.add(j2));
        }
      group.length > 1 && groups.push(group);
    }
    return groups;
  }
  __name(findSimilarAvatars, "findSimilarAvatars");
  function analyzeMembersForBotScore(members, groups) {
    let names = /* @__PURE__ */ new Map();
    members.forEach((m2) => names.set(m2.user.displayName, (names.get(m2.user.displayName) || 0) + 1));
    let grpData = /* @__PURE__ */ new Map();
    return groups.forEach((g2) => g2.forEach((m2) => grpData.set(m2.id, { size: g2.length }))), members.map((m2) => {
      let nc = names.get(m2.user.displayName) || 0, gs = grpData.get(m2.user.userId)?.size || 0, ns = nc >= 25 ? 60 : nc >= 10 ? 50 : nc >= 4 ? 35 : nc >= 2 ? 20 : 0, as = gs >= 10 ? 40 : gs >= 5 ? 30 : gs >= 3 ? 15 : gs >= 2 ? 10 : 0;
      return { ...m2, score: Math.min(ns + as, 100), scoreBreakdown: { nameCount: nc, avatarGroupSize: gs } };
    }).filter((m2) => m2.score >= 20).sort((a, b2) => b2.score - a.score);
  }
  __name(analyzeMembersForBotScore, "analyzeMembersForBotScore");
  function equalizeCardHeights2(container) {
    let cards = container.querySelectorAll(".list-item.avatar-card");
    cards.length < 2 || (cards.forEach((c) => c.style.height = "auto"), requestAnimationFrame(() => {
      let max = 0;
      cards.forEach((c) => max = Math.max(max, c.offsetHeight)), max > 0 && cards.forEach((c) => c.style.height = `${max}px`);
    }));
  }
  __name(equalizeCardHeights2, "equalizeCardHeights");
  var isAntiBotScriptActive = !1;
  function handleContainerRemoval() {
    document.getElementById("rovalra-button-container")?.remove(), document.getElementById("rovalra-button-spacer")?.remove();
  }
  __name(handleContainerRemoval, "handleContainerRemoval");
  function antiBotsFullCleanup() {
    handleContainerRemoval(), document.querySelectorAll(".rovalra-global-overlay").forEach((o) => o.remove()), document.getElementById("rovalra-quick-ban-list")?.remove(), document.getElementById("rovalra-bot-list")?.remove(), quickActionState.scrollListener && window.removeEventListener("scroll", quickActionState.scrollListener), quickActionState.abortController && quickActionState.abortController.abort(), antiBotState.abortController && antiBotState.abortController.abort(), antiBotState.scrollListener && window.removeEventListener("scroll", antiBotState.scrollListener), isAntiBotScriptActive = !1;
  }
  __name(antiBotsFullCleanup, "antiBotsFullCleanup");
  async function checkUrlAndManageState() {
    let settings = await getFeatureSettings(), active = /^https:\/\/www\.roblox\.com\/(?:[a-z]{2}\/)?communities\/configure\?id=\d+#!(\/)?members/.test(window.location.href) && (settings.antibotsEnabled || settings.QuickActionsEnabled);
    active && !isAntiBotScriptActive ? (isAntiBotScriptActive = !0, observeElement(".input-group.search-container", (el2) => addFeatureButtons(el2), { onRemove: handleContainerRemoval })) : !active && isAntiBotScriptActive && antiBotsFullCleanup();
  }
  __name(checkUrlAndManageState, "checkUrlAndManageState");
  function init39() {
    isInitialized5 || (isInitialized5 = !0, window.rovalra || (window.rovalra = {}), window.rovalra.ui || (window.rovalra.ui = {}), window.addEventListener("hashchange", checkUrlAndManageState), checkUrlAndManageState());
  }
  __name(init39, "init");

  // src/content/features/groups/pendingRobux.js
  var API_LIMIT2 = 100, MAX_PAGES_TO_FETCH_FOR_INFERENCE2 = 2e3, MAX_PAGES_WITHOUT_PENDING_SALES2 = 5, API_CALL_DELAY_MS2 = 50, TARGET_ELEMENT_SELECTOR2 = 'span[ng-bind="$ctrl.revenueSummary.pendingRobux | number"]', state2 = {
    groupId: null,
    cachedResults: null
  }, sleep4 = /* @__PURE__ */ __name((ms) => new Promise((resolve) => setTimeout(resolve, ms)), "sleep"), parseTimestamp2 = /* @__PURE__ */ __name((timestampStr) => {
    if (!timestampStr) return null;
    try {
      let dt = new Date(timestampStr);
      return isNaN(dt.getTime()) ? null : dt;
    } catch {
      return null;
    }
  }, "parseTimestamp");
  async function fetchTransactions2(groupId) {
    let allTransactionsData = [], currentCursor3 = "", pagesFetched = 0, consecutivePagesWithoutPendingSales = 0;
    transactionLoop: for (; pagesFetched < MAX_PAGES_TO_FETCH_FOR_INFERENCE2; ) {
      pagesFetched++;
      let endpoint = `/v2/groups/${groupId}/transactions?limit=${API_LIMIT2}&transactionType=Sale`;
      currentCursor3 && (endpoint += `&cursor=${currentCursor3}`);
      let data;
      try {
        for (; ; ) {
          let response = await callRobloxApi({
            subdomain: "economy",
            endpoint
          });
          if (response.ok) {
            data = await response.json();
            break;
          } else if (response.status === 429) {
            await sleep4(2e3);
            continue;
          } else
            break;
        }
        if (data && data.data) {
          let currentPageTransactions = data.data;
          if (!currentPageTransactions || currentPageTransactions.length === 0)
            break transactionLoop;
          allTransactionsData.push(...currentPageTransactions);
          let foundPendingSale = !1;
          for (let transaction of currentPageTransactions)
            if (Object.prototype.hasOwnProperty.call(transaction, "isPending") && transaction.isPending) {
              foundPendingSale = !0;
              break;
            }
          if (foundPendingSale)
            consecutivePagesWithoutPendingSales = 0;
          else if (consecutivePagesWithoutPendingSales++, consecutivePagesWithoutPendingSales >= MAX_PAGES_WITHOUT_PENDING_SALES2)
            break transactionLoop;
          let nextCursor = data.nextPageCursor;
          if (!nextCursor)
            break transactionLoop;
          currentCursor3 = nextCursor, await sleep4(API_CALL_DELAY_MS2);
        } else
          break transactionLoop;
      } catch {
        break transactionLoop;
      }
    }
    return allTransactionsData;
  }
  __name(fetchTransactions2, "fetchTransactions");
  function inferPendingDuration2(transactionsList) {
    if (!transactionsList || transactionsList.length === 0)
      return null;
    let minDaysObserved = 1 / 0, foundCompleted = !1, completedCount = 0, now = /* @__PURE__ */ new Date();
    for (let transaction of transactionsList)
      if (Object.prototype.hasOwnProperty.call(transaction, "isPending") && !transaction.isPending) {
        let createdStr = transaction.created;
        if (!createdStr) continue;
        let createdDt = parseTimestamp2(createdStr);
        if (!createdDt) continue;
        let daysDifference = (now.getTime() - createdDt.getTime()) / (1e3 * 60 * 60 * 24), daysRoundedUp = Math.ceil(daysDifference);
        daysRoundedUp >= 1 && (minDaysObserved = Math.min(minDaysObserved, daysRoundedUp), foundCompleted = !0, completedCount++);
      }
    return foundCompleted && minDaysObserved !== 1 / 0 && completedCount >= 2 ? minDaysObserved : null;
  }
  __name(inferPendingDuration2, "inferPendingDuration");
  function calculateUnpendingRobux2(transactionsList, pendingDaysToUse) {
    if (!transactionsList || transactionsList.length === 0)
      return { amount: 0, hasEnoughData: !1 };
    if (!transactionsList.some((t) => t.isPending))
      return { amount: 0, hasEnoughData: !0 };
    if (pendingDaysToUse === null)
      return { amount: 0, hasEnoughData: !1 };
    let totalUnpendingTomorrow = 0, now = /* @__PURE__ */ new Date(), tomorrow = new Date(now);
    tomorrow.setUTCDate(now.getUTCDate() + 1);
    let tomorrowUTCDateString = tomorrow.toISOString().split("T")[0];
    for (let transaction of transactionsList)
      if (!Object.prototype.hasOwnProperty.call(transaction, "isPending") || transaction.isPending) {
        let createdStr = transaction.created, amount = transaction.currency?.amount;
        if (!createdStr || amount === void 0 || amount === 0)
          continue;
        let createdDt = parseTimestamp2(createdStr);
        if (!createdDt)
          continue;
        let estimatedUnpendingDt = new Date(createdDt);
        estimatedUnpendingDt.setUTCDate(createdDt.getUTCDate() + pendingDaysToUse), estimatedUnpendingDt.toISOString().split("T")[0] === tomorrowUTCDateString && (totalUnpendingTomorrow += amount);
      }
    return { amount: totalUnpendingTomorrow, hasEnoughData: !0 };
  }
  __name(calculateUnpendingRobux2, "calculateUnpendingRobux");
  function storeResults2(groupId, results) {
    state2.cachedResults = {
      timestamp: Date.now(),
      groupId,
      estimatedRobux: {
        amount: results.amount,
        hasEnoughData: results.hasEnoughData
      },
      pendingDays: results.pendingDays,
      lastCalculation: results.lastCalculation
    };
  }
  __name(storeResults2, "storeResults");
  function getStoredResults2() {
    return state2.cachedResults && Date.now() - state2.cachedResults.timestamp < 1440 * 60 * 1e3 && state2.cachedResults.groupId === state2.groupId ? state2.cachedResults : null;
  }
  __name(getStoredResults2, "getStoredResults");
  function injectResultElement2(targetElement, result) {
    if (!document.body.contains(targetElement)) return;
    let pendingRow = targetElement.closest("tr");
    if (!pendingRow || !pendingRow.parentNode) return;
    let estimatorRow = pendingRow.parentNode.querySelector(".rovalra-estimator-row"), amountHtml = "", tooltipText = "This is an estimate of how many Robux from your pending balance will become available tomorrow, based on your transaction data. The actual amount may vary. And this may be inaccurate.";
    if (result.isLoading ? amountHtml = '<span style="color: var(--rovalra-main-text-color); font-weight: 400; font-size: 13px;">Loading...</span>' : result.errorMessage ? amountHtml = `<span style="color: red; font-weight: 400; font-size: 13px;">Error: ${result.errorMessage}</span>` : result.hasEnoughData ? amountHtml = `
            <span class="icon-robux-16x16"></span>
            <span class="text-robux" style="color: var(--rovalra-main-text-color); font-weight: 400;">${result.amount.toLocaleString()}~</span>
        ` : (amountHtml = '<span style="color: var(--rovalra-main-text-color); font-weight: 400; font-size: 13px;">Insufficient data</span>', tooltipText = "Not enough transaction history to make an accurate estimate. Please wait for more transactions to complete."), estimatorRow) {
      let amountCell = estimatorRow.querySelector(".amount-cell");
      amountCell && (amountCell.innerHTML = amountHtml);
      let infoIcon = estimatorRow.querySelector(".icon-moreinfo");
      if (infoIcon && infoIcon.dataset.tooltipText !== tooltipText) {
        let newIcon = infoIcon.cloneNode(!0);
        infoIcon.parentNode.replaceChild(newIcon, infoIcon), addTooltip(newIcon, tooltipText), newIcon.dataset.tooltipText = tooltipText;
      }
    } else {
      estimatorRow = document.createElement("tr"), estimatorRow.className = "rovalra-estimator-row", estimatorRow.innerHTML = `
            <td>
                <div style="display: flex; align-items: center; color: var(--rovalra-main-text-color);">
                    <span>Unpending tomorrow</span>
                    <span class="icon-moreinfo" style="margin-left: 4px; font-size: 12px; display: inline-flex; align-items: center; cursor: pointer;"></span>
                </div>
            </td>
            <td class="icon-robux-container amount-cell">
                ${amountHtml}
            </td>
        `;
      let infoIcon = estimatorRow.querySelector(".icon-moreinfo");
      infoIcon && (addTooltip(infoIcon, tooltipText), infoIcon.dataset.tooltipText = tooltipText), pendingRow.parentNode.insertBefore(estimatorRow, pendingRow);
    }
  }
  __name(injectResultElement2, "injectResultElement");
  async function onElementFound4(targetElement) {
    if (targetElement.dataset.rovalraProcessed) return;
    targetElement.dataset.rovalraProcessed = "true";
    let urlParams = new URLSearchParams(window.location.search);
    if (state2.groupId = urlParams.get("id"), !state2.groupId) return;
    injectResultElement2(targetElement, { isLoading: !0 });
    let storedResults = getStoredResults2();
    if (storedResults && storedResults.groupId === state2.groupId) {
      injectResultElement2(targetElement, {
        amount: storedResults.estimatedRobux.amount,
        hasEnoughData: storedResults.estimatedRobux.hasEnoughData,
        pendingDays: storedResults.pendingDays,
        lastCalculation: storedResults.lastCalculation
      });
      return;
    }
    let transactions = await fetchTransactions2(state2.groupId), pendingDaysToUse = inferPendingDuration2(transactions), unpendingResult = calculateUnpendingRobux2(transactions, pendingDaysToUse), finalResults = {
      amount: unpendingResult.amount,
      hasEnoughData: unpendingResult.hasEnoughData,
      pendingDays: pendingDaysToUse,
      lastCalculation: Date.now()
    };
    storeResults2(state2.groupId, finalResults), injectResultElement2(targetElement, finalResults);
  }
  __name(onElementFound4, "onElementFound");
  function init40() {
    chrome.storage.local.get({ pendingRobuxEnabled: !0 }, (settings) => {
      settings.pendingRobuxEnabled && window.location.pathname.includes("communities/configure") && observeElement(TARGET_ELEMENT_SELECTOR2, onElementFound4);
    });
  }
  __name(init40, "init");

  // src/content/features/groups/draggableGroups.js
  var STORAGE_KEY2 = "rovalra_groups_order", HOLD_THRESHOLD = 200, MOVE_THRESHOLD = 5, dragState = {
    active: !1,
    element: null,
    clone: null,
    startX: 0,
    startY: 0,
    offsetX: 0,
    offsetY: 0,
    holdTimer: null,
    preventClick: !1
  }, dropIndicator = null, isEnabled = !1;
  function init41() {
    chrome.storage.local.get(["draggableGroupsEnabled"], (result) => {
      isEnabled = result.draggableGroupsEnabled !== !1, isEnabled && (startObserving(), initializeDragSystem());
    }), chrome.storage.onChanged.addListener((changes) => {
      changes.draggableGroupsEnabled && (isEnabled = changes.draggableGroupsEnabled.newValue !== !1, isEnabled ? initializeDragSystem() : destroyDragSystem());
    });
  }
  __name(init41, "init");
  function initializeDragSystem() {
    observeElement("a.groups-list-item", (link) => {
      if (link.closest(".pending-join-requests"))
        return;
      let container = link.closest(".groups-list-items-container");
      container && (container.hasAttribute("data-rovalra-drag") || (container.setAttribute("data-rovalra-drag", "true"), setTimeout(() => {
        restoreSavedOrder(container), setupDragHandlers(container);
      }, 100)));
    }, { multiple: !0 });
  }
  __name(initializeDragSystem, "initializeDragSystem");
  function setupDragHandlers(container) {
    container.querySelectorAll("a.groups-list-item").forEach((link) => {
      link.addEventListener("mousedown", onMouseDown), link.addEventListener("click", onClick, !0), link.setAttribute("draggable", "false");
    });
  }
  __name(setupDragHandlers, "setupDragHandlers");
  function onClick(e) {
    if (dragState.preventClick)
      return e.preventDefault(), e.stopPropagation(), dragState.preventClick = !1, !1;
  }
  __name(onClick, "onClick");
  function onMouseDown(e) {
    if (!isEnabled || e.button !== 0 || e.target.closest(".leave-group-btn")) return;
    let link = e.currentTarget, rect = link.getBoundingClientRect();
    dragState.element = link, dragState.startX = e.clientX, dragState.startY = e.clientY, dragState.offsetX = e.clientX - rect.left, dragState.offsetY = e.clientY - rect.top, dragState.active = !1, dragState.preventClick = !1, dragState.holdTimer && clearTimeout(dragState.holdTimer), dragState.holdTimer = setTimeout(() => {
      dragState.active || beginDrag(e);
    }, HOLD_THRESHOLD), document.addEventListener("mousemove", onMouseMove), document.addEventListener("mouseup", onMouseUp);
  }
  __name(onMouseDown, "onMouseDown");
  function beginDrag(e) {
    if (!dragState.element) return;
    dragState.active = !0, dragState.preventClick = !0;
    let original = dragState.element, rect = original.getBoundingClientRect(), clone2 = original.cloneNode(!0);
    clone2.style.position = "fixed", clone2.style.left = rect.left + "px", clone2.style.top = rect.top + "px", clone2.style.width = rect.width + "px", clone2.style.height = rect.height + "px", clone2.style.margin = "0", clone2.style.zIndex = "99999", clone2.style.pointerEvents = "none", clone2.style.opacity = "0.8", clone2.style.transition = "none", clone2.style.boxShadow = "0 8px 24px rgba(0,0,0,0.3)", document.body.appendChild(clone2), dragState.clone = clone2, original.style.opacity = "0.3", original.style.transform = "scale(0.95)", original.style.transition = "all 0.15s ease", createDropIndicator(), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none";
  }
  __name(beginDrag, "beginDrag");
  function createDropIndicator() {
    dropIndicator = document.createElement("div"), dropIndicator.style.position = "absolute", dropIndicator.style.height = "2px", dropIndicator.style.backgroundColor = "var(--rovalra-playbutton-color)", dropIndicator.style.borderRadius = "1px", dropIndicator.style.pointerEvents = "none", dropIndicator.style.zIndex = "99998", dropIndicator.style.display = "none", dropIndicator.style.transition = "all 0.15s ease", document.body.appendChild(dropIndicator);
  }
  __name(createDropIndicator, "createDropIndicator");
  function onMouseMove(e) {
    let deltaX = Math.abs(e.clientX - dragState.startX), deltaY = Math.abs(e.clientY - dragState.startY);
    if (!dragState.active)
      if (deltaX > MOVE_THRESHOLD || deltaY > MOVE_THRESHOLD)
        clearTimeout(dragState.holdTimer), beginDrag(e);
      else
        return;
    e.preventDefault();
    let x2 = e.clientX - dragState.offsetX, y2 = e.clientY - dragState.offsetY;
    dragState.clone && (dragState.clone.style.left = x2 + "px", dragState.clone.style.top = y2 + "px"), updateDropPosition(e.clientY);
  }
  __name(onMouseMove, "onMouseMove");
  function updateDropPosition(mouseY) {
    if (!dragState.element.closest(".groups-list-items-container")) return;
    let section = dragState.element.parentElement?.closest("div.padding-bottom-small");
    if (!section) return;
    let links = Array.from(section.querySelectorAll("a.groups-list-item")).filter((l) => l !== dragState.element), targetElement = null, insertBefore = !0;
    for (let link of links) {
      let rect = link.getBoundingClientRect(), midY = rect.top + rect.height / 2;
      if (mouseY < midY) {
        targetElement = link, insertBefore = !0;
        break;
      }
    }
    !targetElement && links.length > 0 && (targetElement = links[links.length - 1], insertBefore = !1), targetElement ? showDropIndicator(targetElement, insertBefore) : hideDropIndicator();
  }
  __name(updateDropPosition, "updateDropPosition");
  function showDropIndicator(targetElement, before) {
    if (!dropIndicator) return;
    let rect = targetElement.getBoundingClientRect(), y2 = before ? rect.top : rect.bottom;
    dropIndicator.style.left = rect.left + "px", dropIndicator.style.top = y2 - 1 + "px", dropIndicator.style.width = rect.width + "px", dropIndicator.style.display = "block";
  }
  __name(showDropIndicator, "showDropIndicator");
  function hideDropIndicator() {
    dropIndicator && (dropIndicator.style.display = "none");
  }
  __name(hideDropIndicator, "hideDropIndicator");
  function onMouseUp(e) {
    document.removeEventListener("mousemove", onMouseMove), document.removeEventListener("mouseup", onMouseUp), dragState.holdTimer && (clearTimeout(dragState.holdTimer), dragState.holdTimer = null), dragState.active ? (finalizeDrop(e.clientY), dragState.clone && dragState.clone.remove(), dragState.element && (dragState.element.style.opacity = "", dragState.element.style.transform = ""), hideDropIndicator(), setTimeout(() => {
      dragState.active = !1, dragState.element = null, dragState.preventClick = !1;
    }, 50)) : (dragState.active = !1, dragState.element = null, dragState.preventClick = !1), document.body.style.cursor = "", document.body.style.userSelect = "";
  }
  __name(onMouseUp, "onMouseUp");
  function finalizeDrop(mouseY) {
    let container = dragState.element.closest(".groups-list-items-container");
    if (!container) return;
    let section = dragState.element.parentElement?.closest("div.padding-bottom-small");
    if (!section) return;
    let wrapper = section.querySelector("div:not(.text-caption-large)");
    if (!wrapper) return;
    let links = Array.from(wrapper.querySelectorAll("a.groups-list-item")).filter((l) => l !== dragState.element), targetElement = null, insertBefore = !0;
    for (let link of links) {
      let rect = link.getBoundingClientRect(), midY = rect.top + rect.height / 2;
      if (mouseY < midY) {
        targetElement = link, insertBefore = !0;
        break;
      }
    }
    targetElement ? insertBefore ? wrapper.insertBefore(dragState.element, targetElement) : targetElement.nextSibling ? wrapper.insertBefore(dragState.element, targetElement.nextSibling) : wrapper.appendChild(dragState.element) : links.length > 0 && wrapper.appendChild(dragState.element), persistOrder(container);
  }
  __name(finalizeDrop, "finalizeDrop");
  function persistOrder(container) {
    let links = container.querySelectorAll("a.groups-list-item"), order = [];
    links.forEach((link, idx) => {
      let match = link.getAttribute("href")?.match(/\/communities\/(\d+)/);
      match && order.push({ groupId: match[1], position: idx });
    }), chrome.storage.local.set({ [STORAGE_KEY2]: order });
  }
  __name(persistOrder, "persistOrder");
  function restoreSavedOrder(container) {
    chrome.storage.local.get([STORAGE_KEY2], (result) => {
      let savedOrder = result[STORAGE_KEY2];
      if (!savedOrder || !savedOrder.length) return;
      let orderMap = new Map(savedOrder.map((o) => [o.groupId, o.position]));
      container.querySelectorAll("div.padding-bottom-small").forEach((section) => {
        let wrapper = section.querySelector("div");
        if (!wrapper) return;
        let links = Array.from(wrapper.querySelectorAll("a.groups-list-item"));
        links.length !== 0 && (links.sort((a, b2) => {
          let aMatch = a.getAttribute("href")?.match(/\/communities\/(\d+)/), bMatch = b2.getAttribute("href")?.match(/\/communities\/(\d+)/);
          if (!aMatch || !bMatch) return 0;
          let aPos = orderMap.has(aMatch[1]) ? orderMap.get(aMatch[1]) : 9999, bPos = orderMap.has(bMatch[1]) ? orderMap.get(bMatch[1]) : 9999;
          return aPos - bPos;
        }), links.forEach((link) => wrapper.appendChild(link)));
      });
    });
  }
  __name(restoreSavedOrder, "restoreSavedOrder");
  function destroyDragSystem() {
    document.querySelectorAll(".groups-list-items-container[data-rovalra-drag]").forEach((container) => {
      container.removeAttribute("data-rovalra-drag"), container.querySelectorAll("a.groups-list-item").forEach((link) => {
        link.removeEventListener("mousedown", onMouseDown), link.removeEventListener("click", onClick, !0);
      });
    });
  }
  __name(destroyDragSystem, "destroyDragSystem");

  // src/content/core/ui/profile/header/button.js
  function createProfileHeaderButton({
    content,
    id,
    onClick: onClick2,
    disabled = !1,
    backgroundColor
  }) {
    let button = document.createElement("button");
    button.type = "button";
    let classNames = "relative clip group/interactable focus-visible:outline-focus disabled:outline-none flex justify-center items-center radius-circle stroke-none padding-left-medium padding-right-medium height-800 text-label-medium content-action-utility";
    backgroundColor || (classNames += " bg-shift-300"), button.className = classNames, id && (button.id = id), button.disabled = disabled, backgroundColor && (button.style.backgroundColor = backgroundColor);
    let presentationDiv = document.createElement("div");
    presentationDiv.setAttribute("role", "presentation"), presentationDiv.className = "absolute inset-[0] transition-colors group-hover/interactable:bg-[var()] group-active/interactable:bg-[var()] group-disabled/interactable:bg-none";
    let contentSpan = document.createElement("span");
    return contentSpan.className = "text-no-wrap text-truncate-end flex items-center", contentSpan.append(...Array.isArray(content) ? content : [content]), button.append(presentationDiv, contentSpan), onClick2 && button.addEventListener("click", onClick2), button;
  }
  __name(createProfileHeaderButton, "createProfileHeaderButton");

  // src/content/features/profile/header/rap.js
  var userCollectiblesCache = /* @__PURE__ */ new Map(), itemThumbnailCache = /* @__PURE__ */ new Map(), rapDisplayIdentifier = "rovalra-user-rap-display";
  function getOrCreateRovalraContainer(observedElement) {
    let CONTAINER_ID = "rovalra-profile-button-container", isNewLayout = observedElement.classList.contains("profile-header-names"), rovalraContainer = (isNewLayout ? observedElement : observedElement.parentElement).querySelector(`.${CONTAINER_ID}`);
    return rovalraContainer || (rovalraContainer = document.createElement("div"), rovalraContainer.className = CONTAINER_ID, isNewLayout ? (Object.assign(rovalraContainer.style, {
      display: "flex",
      gap: "8px",
      justifyContent: "flex-start",
      marginTop: "12px"
    }), observedElement.appendChild(rovalraContainer)) : (Object.assign(rovalraContainer.style, {
      display: "flex",
      gap: "8px",
      justifyContent: "flex-start"
    }), observedElement.insertAdjacentElement("afterend", rovalraContainer))), rovalraContainer;
  }
  __name(getOrCreateRovalraContainer, "getOrCreateRovalraContainer");
  async function fetchUserCollectibles(userId) {
    if (userCollectiblesCache.has(userId)) return userCollectiblesCache.get(userId);
    let totalRap = 0, allItems = [], cursor = "", limit = 100, retries = 0, maxRetries = 1 / 0;
    try {
      do {
        let response;
        try {
          response = await callRobloxApi({
            subdomain: "inventory",
            endpoint: `/v1/users/${userId}/assets/collectibles?sortOrder=Asc&limit=${limit}&cursor=${cursor}`,
            method: "GET"
          });
        } catch (e) {
          if (retries < maxRetries) {
            retries++, await new Promise((resolve) => setTimeout(resolve, 1e3 * retries));
            continue;
          }
          throw e;
        }
        if (response.status === 429) {
          let retryAfter = parseInt(response.headers.get("retry-after") || "5", 10);
          console.warn(`RoValra (RAP): Rate limited. Retrying after ${retryAfter} seconds.`), await new Promise((resolve) => setTimeout(resolve, retryAfter * 1e3));
          continue;
        }
        if (response.status === 403) return "Private";
        if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
        let currentPageData = await response.json();
        currentPageData.data.forEach((item) => {
          typeof item.recentAveragePrice == "number" && (totalRap += item.recentAveragePrice), allItems.push(item);
        }), cursor = currentPageData.nextPageCursor;
      } while (cursor);
      let result = { totalRap, items: allItems };
      return userCollectiblesCache.set(userId, result), result;
    } catch (error) {
      return console.error("RoValra: Failed to fetch user collectibles:", error), null;
    }
  }
  __name(fetchUserCollectibles, "fetchUserCollectibles");
  async function fetchItemThumbnails(items, thumbnailCache, signal) {
    let itemsToFetch = items.filter((item) => !thumbnailCache.has(item.assetId));
    if (itemsToFetch.length === 0) return;
    let itemsForBatch = itemsToFetch.map((item) => ({ id: item.assetId }));
    (await fetchThumbnails(itemsForBatch, "Asset", "150x150", !1, signal)).forEach((thumbData, id) => {
      thumbnailCache.set(id, thumbData);
    });
  }
  __name(fetchItemThumbnails, "fetchItemThumbnails");
  async function showInventoryOverlay(userId, items, totalRapString, hideSerial) {
    let displayName = await getDisplayNameFromPageData() || "User", allItems = items.sort((a, b2) => (b2.recentAveragePrice || 0) - (a.recentAveragePrice || 0)), filteredItems = [...allItems], currentLoadController = null, isPaginating = !1, loadMoreItems = /* @__PURE__ */ __name(async () => {
      if (isPaginating || currentLoadController?.signal.aborted) return;
      let itemsToLoad = filteredItems.splice(0, 50);
      if (itemsToLoad.length === 0) return;
      isPaginating = !0;
      let loadingMessage = document.createElement("p");
      loadingMessage.textContent = "Loading more items...", loadingMessage.className = "loading-message text-secondary", loadingMessage.style.gridColumn = "1 / -1", loadingMessage.style.textAlign = "center", itemListContainer.appendChild(loadingMessage), currentLoadController = new AbortController();
      try {
        if (await fetchItemThumbnails(itemsToLoad, itemThumbnailCache, currentLoadController.signal), currentLoadController.signal.aborted) return;
        itemsToLoad.forEach((item) => {
          let card = createItemCard(item, itemThumbnailCache, { showSerial: !0, hideSerial });
          itemListContainer.appendChild(card);
        });
      } catch (error) {
        error.name !== "AbortError" && console.error("RoValra: Failed to fetch item thumbnails.", error);
      } finally {
        loadingMessage.remove(), isPaginating = !1;
      }
    }, "loadMoreItems"), handleSearch2 = /* @__PURE__ */ __name(() => {
      currentLoadController && currentLoadController.abort(), itemListContainer.innerHTML = "";
      let term = searchInput.input.value.toLowerCase().trim();
      filteredItems = allItems.filter((item) => item.name.toLowerCase().includes(term)), filteredItems.length > 0 ? loadMoreItems() : setEmpty("No items match your search.");
    }, "handleSearch"), bodyContent = document.createElement("div");
    bodyContent.style.cssText = "display: flex; flex-direction: column; min-height: 0; gap: 16px;";
    let searchInput = createStyledInput({
      id: "rovalra-rap-search",
      label: "Search by item name",
      placeholder: " "
    }), itemListContainer = document.createElement("div");
    itemListContainer.className = "rovalra-inventory-list", itemListContainer.style.cssText = "display:grid; grid-template-columns:repeat(auto-fill,minmax(150px,1fr)); grid-auto-rows:max-content; gap:8px; margin-bottom:10px;", bodyContent.append(searchInput.container, itemListContainer);
    let rolimonsLink = document.createElement("a");
    rolimonsLink.href = `https://www.rolimons.com/player/${userId}`, rolimonsLink.target = "_blank", rolimonsLink.rel = "noopener noreferrer", rolimonsLink.className = "rolimons-link", rolimonsLink.style.cssText = "display: inline-flex; align-items: center; margin-left: 12px; color: var(--rovalra-secondary-text-color);", rolimonsLink.innerHTML = '<svg focusable="false" aria-hidden="true" viewBox="0 0 24 24" style="width:20px;height:20px;fill:currentColor;"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"></path></svg>';
    let overlayTitleText = `${displayName}'s Collectibles (${totalRapString} RAP)`, { overlay, close } = createOverlay({
      title: overlayTitleText,
      bodyContent,
      maxWidth: "1000px",
      maxHeight: "85vh"
    }), actualTitleElement = overlay.querySelector(".rovalra-overlay-header");
    actualTitleElement && (actualTitleElement.append(rolimonsLink), addTooltip(rolimonsLink, "Open in Rolimon's", { position: "top", container: overlay })), searchInput.input.addEventListener("input", handleSearch2);
    let scrollTarget = overlay.querySelector(".rovalra-overlay-body");
    scrollTarget.addEventListener("scroll", () => {
      scrollTarget.scrollTop + scrollTarget.clientHeight >= scrollTarget.scrollHeight - 250 && !isPaginating && filteredItems.length > 0 && loadMoreItems();
    });
    let setEmpty = /* @__PURE__ */ __name((message) => {
      itemListContainer.innerHTML = purify.sanitize(`<p class="text-secondary" style="grid-column:1/-1;text-align:center;">${message}</p>`);
    }, "setEmpty");
    allItems.length > 0 ? loadMoreItems() : setEmpty("This user's inventory is private or has no limiteds.");
  }
  __name(showInventoryOverlay, "showInventoryOverlay");
  async function addUserRapDisplay(observedElement) {
    let targetContainer = getOrCreateRovalraContainer(observedElement);
    if (!targetContainer || targetContainer.querySelector(`.${rapDisplayIdentifier}`)) return;
    let userId = getUserIdFromUrl();
    if (!userId) return;
    let robuxIcon = document.createElement("span");
    robuxIcon.className = "icon-robux-16x16 rovalra-dynamic-icon";
    let rapText = document.createElement("span");
    rapText.innerText = "...";
    let rapDisplay = createProfileHeaderButton({
      id: rapDisplayIdentifier,
      content: [robuxIcon, rapText],
      backgroundColor: "#02aa51",
      textColor: "var(--rovalra-main-text-color)"
    });
    targetContainer.appendChild(rapDisplay);
    let collectibleResult = await fetchUserCollectibles(userId);
    if (collectibleResult === null) {
      rapText.innerText = "Error";
      return;
    }
    if (collectibleResult === "Private")
      rapText.innerText = "Private", addTooltip(rapDisplay, "Open in Rolimon's", { position: "top" }), rapDisplay.addEventListener("click", async () => {
        let username = await getUsernameFromPageData() || "this user", bodyContent = document.createElement("div");
        bodyContent.innerHTML = purify.sanitize(`You are about to be redirected to ${username}'s profile on Rolimon's, an external website for trading and item values.<br><br>Do you want to continue?`);
        let { close } = createOverlay({
          title: "Continue to Rolimon's",
          bodyContent,
          actions: [
            (() => {
              let continueButton = document.createElement("button");
              return continueButton.className = "btn-primary-md", continueButton.innerText = "Continue to Rolimon's", continueButton.onclick = () => {
                window.open(`https://www.rolimons.com/player/${userId}`, "_blank"), close();
              }, continueButton;
            })()
          ],
          showLogo: "rolimonsIcon"
        });
      });
    else {
      let rapString = collectibleResult.totalRap.toLocaleString();
      rapText.innerText = rapString, rapDisplay.addEventListener("click", async () => {
        let settings = await new Promise((resolve) => chrome.storage.local.get({ HideSerial: !1 }, resolve)), cachedData = userCollectiblesCache.get(userId), items = cachedData ? cachedData.items : [];
        showInventoryOverlay(userId, items, rapString, settings.HideSerial);
      });
    }
  }
  __name(addUserRapDisplay, "addUserRapDisplay");
  function init42() {
    chrome.storage.local.get({ userRapEnabled: !0 }, function(data) {
      data.userRapEnabled && observeElement(".flex-nowrap.gap-small.flex, .profile-header-names", addUserRapDisplay, { multiple: !0 });
    });
  }
  __name(init42, "init");

  // src/content/features/profile/header/donationlink.js
  async function addDonationButton(observedElement) {
    let autheduser = await getAuthenticatedUsername(), username = await getUsernameFromPageData(), buttonIdentifier = "rovalra-donation-button", targetContainer = getOrCreateRovalraContainer(observedElement);
    if (!targetContainer || targetContainer.querySelector(`.${buttonIdentifier}`)) return;
    function showDonationOverlay() {
      if (!username) {
        console.error("Could not get the username for the donation button.");
        return;
      }
      let bodyContent = document.createElement("div");
      bodyContent.innerHTML = purify.sanitize(`
            <p style="line-height: 1.6; white-space: pre-line; font-size: 14px; font-weight: 600;">
                This will launch "PLS DONATE" where you can give an offline donation.

                Due to fees from Roblox (30%) and the game (10%), the user receives 60% of the donated amount.

                Upon joining, the "Offline Donations" UI will appear with their username pre-filled. Simply click the gift button to open their stand and purchase a gamepass to donate.
            </p>
        `);
      let continueButton = document.createElement("button");
      continueButton.innerText = "Join Pls Donate", Object.assign(continueButton.style, { padding: "10px 20px", border: "none", borderRadius: "8px", backgroundColor: "#04ff00ff", color: "#181818ff", fontWeight: "600", cursor: "pointer", transition: "background-color 0.2s", fontSize: "14px" }), continueButton.addEventListener("mouseenter", () => continueButton.style.backgroundColor = "#00e600"), continueButton.addEventListener("mouseleave", () => continueButton.style.backgroundColor = "#04ff00ff");
      let goBackButton = document.createElement("button");
      goBackButton.innerText = "Go Back", goBackButton.className = "btn-control-md rovalra-btn-cancel";
      let { close } = createOverlay({
        title: "Pls Donate",
        bodyContent,
        actions: [goBackButton, continueButton],
        maxWidth: "480px"
      });
      continueButton.addEventListener("click", () => {
        close();
        let PLS_DONATE_PLACE_ID = 8737602449, giftData = JSON.stringify({ giftTarget: username });
        launchMultiplayerGame(PLS_DONATE_PLACE_ID, giftData);
      }), goBackButton.onclick = close;
    }
    __name(showDonationOverlay, "showDonationOverlay");
    let robuxIcon = document.createElement("span");
    robuxIcon.className = "icon-robux-16x16", Object.assign(robuxIcon.style, {
      filter: "brightness(0)"
    });
    let buttonText = document.createElement("span");
    buttonText.innerText = "Donate", buttonText.style.color = "#181818ff";
    let donationButton = createProfileHeaderButton({
      id: buttonIdentifier,
      content: [robuxIcon, buttonText],
      backgroundColor: "#04ff00ff",
      onClick: /* @__PURE__ */ __name((event) => {
        event.preventDefault(), showDonationOverlay();
      }, "onClick")
    });
    autheduser != username && targetContainer.appendChild(donationButton);
  }
  __name(addDonationButton, "addDonationButton");
  function init43() {
    chrome.storage.local.get({ donationbuttonEnable: !0 }, function(data) {
      data.donationbuttonEnable && observeElement(".flex-nowrap.gap-small.flex, .profile-header-names", addDonationButton, { multiple: !0 });
    });
  }
  __name(init43, "init");

  // src/content/core/gameSearch/gameSearch.js
  var searchAbortController = new AbortController();
  async function searchGames(query, sessionId) {
    searchAbortController.abort(), searchAbortController = new AbortController();
    let signal = searchAbortController.signal;
    try {
      let response = await callRobloxApi({
        subdomain: "apis",
        endpoint: `/search-api/omni-search?searchQuery=${encodeURIComponent(query)}&pageType=Game&sessionId=${sessionId}`,
        signal
      });
      if (!response.ok)
        throw new Error(`API request failed with status ${response.status}`);
      let results = await response.json();
      if (signal.aborted) return [];
      let topGames = (results.searchResults?.flatMap((group) => group.contentGroupType === "Game" ? group.contents : []) || []).slice(0, 3);
      if (topGames.length > 0) {
        let thumbnailItems = topGames.map((game) => ({ id: game.universeId })), thumbnails = await fetchThumbnails(thumbnailItems, "GameIcon", "50x50", !1, signal);
        topGames.forEach((game) => {
          game.thumbnail = thumbnails.get(game.universeId);
        });
      }
      return topGames;
    } catch (error) {
      return error.name !== "AbortError" && console.error("RoValra Game Search: Search failed.", error), [];
    }
  }
  __name(searchGames, "searchGames");

  // src/content/core/games/gameDetails.js
  async function getGameDetailsFromPlaceId(placeId) {
    try {
      let assetDetailsResponse = await callRobloxApi({
        subdomain: "economy",
        endpoint: `/v2/assets/${placeId}/details`
      });
      if (!assetDetailsResponse.ok) return null;
      let assetDetails = await assetDetailsResponse.json();
      if (assetDetails.AssetTypeId !== 9)
        return null;
      let universeResponse = await callRobloxApi({
        subdomain: "apis",
        endpoint: `/universes/v1/places/${placeId}/universe`
      });
      if (!universeResponse.ok) return null;
      let { universeId } = await universeResponse.json();
      if (!universeId) return null;
      let gameDetailsResponse = await callRobloxApi({
        subdomain: "games",
        endpoint: `/v1/games?universeIds=${universeId}`
      });
      if (!gameDetailsResponse.ok) return null;
      let gameData = (await gameDetailsResponse.json()).data[0], thumbnails = await fetchThumbnails([{ id: universeId }], "GameIcon", "50x50");
      return {
        id: universeId,
        name: assetDetails.Name,
        playerCount: gameData?.playing || 0,
        thumbnail: thumbnails.get(universeId)
      };
    } catch (error) {
      return console.error(`RoValra Game Details: Failed to fetch details for Place ID ${placeId}.`, error), null;
    }
  }
  __name(getGameDetailsFromPlaceId, "getGameDetailsFromPlaceId");

  // src/content/core/ui/general/gameInput.js
  function debounce(func, wait) {
    let timeout;
    return /* @__PURE__ */ __name(function(...args) {
      let later = /* @__PURE__ */ __name(() => {
        clearTimeout(timeout), func(...args);
      }, "later");
      clearTimeout(timeout), timeout = setTimeout(later, wait);
    }, "executedFunction");
  }
  __name(debounce, "debounce");
  function createSearchInput({
    placeholder = "Search",
    onResultSelect,
    style = {}
  }) {
    let selectedGameName = null, currentIcon = null, outerContainer = document.createElement("div");
    outerContainer.className = "rovalra-game-input";
    let container = document.createElement("div");
    container.className = "form-group game-search-container", Object.assign(container.style, style), outerContainer.appendChild(container);
    let input = document.createElement("input");
    input.type = "text", input.className = "form-control input-field search-input input-rounded game-search-input", input.placeholder = placeholder, input.maxLength = 50, input.autocomplete = "off", input.autocorrect = "off", input.spellcheck = !1;
    let searchIcon = document.createElement("span");
    searchIcon.className = "icon-search game-search-icon";
    let dropdown = document.createElement("div");
    dropdown.className = "foundation-web-menu bg-surface-100 stroke-standard stroke-default shadow-transient-high radius-large game-search-dropdown";
    let dropdownContent = document.createElement("div");
    dropdownContent.className = "padding-small flex-dropdown-menu", dropdown.appendChild(dropdownContent), container.append(input, searchIcon, dropdown);
    let performSearch = /* @__PURE__ */ __name(async () => {
      let query = input.value, isPlaceId = /^\d+$/.test(query);
      if (currentIcon && query !== selectedGameName) {
        let originalSearchIcon = createSearchIcon();
        currentIcon.replaceWith(originalSearchIcon), currentIcon = originalSearchIcon, selectedGameName = null;
      }
      if (query.length < 2 && !isPlaceId) {
        clearDropdown();
        return;
      }
      let games = [];
      if (isPlaceId) {
        let gameFromId = await getGameDetailsFromPlaceId(query);
        gameFromId && games.push(gameFromId);
      } else {
        let userDataEl = document.querySelector('meta[name="user-data"]'), sessionId = userDataEl ? userDataEl.dataset.userid : "0";
        games = await searchGames(query, sessionId);
      }
      let dropdownItems = games.map((game) => {
        if (!game) {
          let errorItem = document.createElement("div");
          return errorItem.className = "foundation-web-menu-item text-body-medium padding-x-medium padding-y-small text-secondary game-search-error-item", errorItem.textContent = "Unable to find experience.", errorItem;
        }
        let thumbUrl = game.thumbnail?.imageUrl, item = document.createElement("button");
        item.type = "button", item.className = "relative clip group/interactable focus-visible:outline-focus disabled:outline-none foundation-web-menu-item flex items-center content-default text-truncate-split focus-visible:hover:outline-none cursor-pointer stroke-none bg-none text-align-x-left width-full text-body-medium padding-x-medium padding-y-small gap-x-medium radius-medium";
        let presentationDiv = document.createElement("div");
        presentationDiv.setAttribute("role", "presentation"), presentationDiv.className = "absolute inset-[0] transition-colors group-hover/interactable:bg-[var()] group-active/interactable:bg-[var()] group-disabled/interactable:bg-none";
        let img = document.createElement("img");
        img.src = thumbUrl, img.className = "game-search-result-img", img.style.borderRadius = "4px";
        let textContainer = document.createElement("div");
        textContainer.className = "grow-1 text-truncate-split flex flex-col gap-y-xsmall";
        let titleSpan = document.createElement("span");
        titleSpan.className = "foundation-web-menu-item-title text-no-wrap text-truncate-split content-emphasis", titleSpan.textContent = game.name;
        let playerCountContainer = document.createElement("div");
        playerCountContainer.className = "game-card-info game-search-player-count";
        let playingIcon = document.createElement("span");
        playingIcon.className = "info-label icon-playing-counts-gray";
        let playingCountLabel = document.createElement("span");
        return playingCountLabel.className = "info-label playing-counts-label", playingCountLabel.style.marginLeft = "4px", playingCountLabel.textContent = formatPlayerCount(game.playerCount), playerCountContainer.append(playingIcon, playingCountLabel), textContainer.append(titleSpan, playerCountContainer), item.append(presentationDiv, img, textContainer), item.addEventListener("click", () => {
          onResultSelect && (onResultSelect(game), selectedGameName = game.name);
          let gameIcon = document.createElement("img");
          gameIcon.src = thumbUrl, gameIcon.className = "game-search-selected-icon", (currentIcon && currentIcon.parentNode ? currentIcon : searchIcon).replaceWith(gameIcon), currentIcon = gameIcon;
        }), item;
      });
      updateDropdown(dropdownItems);
    }, "performSearch"), debouncedSearch = debounce(performSearch, 171);
    input.addEventListener("input", debouncedSearch), input.addEventListener("focus", performSearch), document.addEventListener("click", (e) => {
      container.contains(e.target) || (dropdown.style.display = "none");
    });
    let clearDropdown = /* @__PURE__ */ __name(() => {
      dropdownContent.innerHTML = "", dropdown.style.display = "none";
    }, "clearDropdown"), updateDropdown = /* @__PURE__ */ __name((items) => {
      dropdownContent.innerHTML = "", items.forEach((item) => dropdownContent.appendChild(item)), dropdown.style.display = items.length > 0 ? "block" : "none";
    }, "updateDropdown");
    return {
      element: outerContainer,
      input,
      clearDropdown,
      updateDropdown,
      hideDropdown: /* @__PURE__ */ __name(() => dropdown.style.display = "none", "hideDropdown"),
      getSelectedGameName: /* @__PURE__ */ __name(() => selectedGameName, "getSelectedGameName")
    };
  }
  __name(createSearchInput, "createSearchInput");
  function createSearchIcon() {
    let icon = document.createElement("span");
    return icon.className = "icon-search game-search-icon", icon;
  }
  __name(createSearchIcon, "createSearchIcon");

  // src/content/core/ui/profile/header/squarebutton.js
  function createSquareButton({
    content,
    id,
    backgroundColor,
    textColor,
    hoverBackgroundColor,
    pressBackgroundColor,
    onClick: onClick2,
    disabled = !1,
    width = "100%",
    height = "height-1000",
    paddingX = "padding-x-medium",
    paddingY = "padding-y-none",
    disableTextTruncation = !1,
    radius = "radius-medium",
    fontSize
  }) {
    let button = document.createElement("button");
    button.type = "button", button.setAttribute("aria-disabled", String(disabled)), id && (button.id = id);
    let classNames = `foundation-web-button relative clip group/interactable focus-visible:outline-focus disabled:outline-none cursor-pointer flex items-center justify-center stroke-none select-none text-label-medium ${height} ${paddingX} ${paddingY} ${radius}`;
    classNames += " bg-action-standard content-action-standard", button.className = classNames, Object.assign(button.style, {
      textDecoration: "none",
      width,
      backgroundColor: backgroundColor || "",
      fontSize: fontSize || "",
      color: textColor || ""
    }), button.disabled = disabled;
    let presentationDiv = document.createElement("div");
    presentationDiv.setAttribute("role", "presentation");
    let presentationDivClass = "absolute inset-[0] transition-colors";
    hoverBackgroundColor ? presentationDivClass += ` group-hover/interactable:bg-[${hoverBackgroundColor}]` : presentationDivClass += " group-hover/interactable:bg-[var(--color-state-hover)]", pressBackgroundColor ? presentationDivClass += ` group-active/interactable:bg-[${pressBackgroundColor}]` : presentationDivClass += " group-active/interactable:bg-[var(--color-state-press)]", presentationDivClass += " group-disabled/interactable:bg-none", presentationDiv.className = presentationDivClass;
    let contentSpan = document.createElement("span"), contentSpanClass = "padding-y-xsmall padding-x-xsmall";
    return disableTextTruncation ? contentSpanClass += " text-no-wrap" : contentSpanClass += " text-truncate-end text-no-wrap", contentSpan.className = contentSpanClass, Array.isArray(content) ? content.forEach((item) => {
      typeof item == "string" ? contentSpan.appendChild(document.createTextNode(item)) : item instanceof HTMLElement && contentSpan.appendChild(item);
    }) : typeof content == "string" ? contentSpan.textContent = content : content instanceof HTMLElement && contentSpan.appendChild(content), button.append(presentationDiv, contentSpan), onClick2 && button.addEventListener("click", onClick2), button;
  }
  __name(createSquareButton, "createSquareButton");

  // src/content/features/profile/header/instantjoiner.js
  function init44() {
    chrome.storage.local.get({ userSniperEnabled: !1, deeplinkEnabled: !0 }, function(settings) {
      if (!settings.userSniperEnabled)
        return;
      let useDeeplinks = settings.deeplinkEnabled, isRunning = !1, intervalId, isRateLimited = !1, lastRequestTime = 0, requestDelay = 10, hasJoinedGame = !1, canMakeRequest = !0;
      function getUserIdFromUrl2() {
        let path = window.location.pathname, regex = /^\/(?:[a-z]{2}\/)?users\/(\d+)/, match = path.match(regex);
        return match ? parseInt(match[1], 10) : null;
      }
      __name(getUserIdFromUrl2, "getUserIdFromUrl");
      async function sendQueueReservationRequests(userId) {
        let payload = { userIdToFollow: parseInt(userId, 10) };
        for (let i = 0; i < 10; i++)
          callRobloxApi({
            subdomain: "gamejoin",
            endpoint: "/v1/play-with-user",
            method: "POST",
            body: payload
          }).catch(() => {
          }), i < 9 && await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      __name(sendQueueReservationRequests, "sendQueueReservationRequests");
      async function sendPresenceRequest(userId, specificPlaceId = null) {
        if (!(isRateLimited || !canMakeRequest)) {
          canMakeRequest = !1;
          try {
            let response = await callRobloxApi({
              subdomain: "presence",
              endpoint: "/v1/presence/users",
              method: "POST",
              body: { userIds: [userId] }
            });
            if (response.status === 429) {
              isRateLimited = !0, setTimeout(() => {
                isRateLimited = !1;
              }, 3e3), canMakeRequest = !0;
              return;
            }
            response.ok && (canMakeRequest = !0);
            let data = await response.json();
            if (data && data.userPresences && data.userPresences.length > 0) {
              let presence = data.userPresences[0];
              if ((specificPlaceId ? presence.placeId == specificPlaceId : !!presence.placeId) && presence.gameId && presence.userPresenceType === 2) {
                if (!hasJoinedGame) {
                  if (sendQueueReservationRequests(userId), useDeeplinks) {
                    let joinURL = `roblox://experiences/start?placeId=${presence.placeId}&gameInstanceId=${presence.gameId}`;
                    window.location.href = joinURL;
                  } else
                    launchGame(presence.placeId, presence.gameId);
                  hasJoinedGame = !0, stopPresenceCheck();
                }
                canMakeRequest = !0;
                return;
              }
            }
            return canMakeRequest = !0, data;
          } catch {
            canMakeRequest = !0;
          }
        }
      }
      __name(sendPresenceRequest, "sendPresenceRequest");
      function enableForcedHeaders() {
        typeof chrome < "u" && chrome.runtime && chrome.runtime.sendMessage && chrome.runtime.sendMessage({ action: "enableServerJoinHeaders" });
      }
      __name(enableForcedHeaders, "enableForcedHeaders");
      function disableForcedHeaders() {
        typeof chrome < "u" && chrome.runtime && chrome.runtime.sendMessage && chrome.runtime.sendMessage({ action: "disableServerJoinHeaders" });
      }
      __name(disableForcedHeaders, "disableForcedHeaders");
      function stopPresenceCheck() {
        disableForcedHeaders(), document.querySelectorAll(".rovalra-instant-join-button").forEach((btn) => {
          btn.querySelector("span").textContent = "Instant Join";
        }), clearInterval(intervalId), isRunning = !1, hasJoinedGame = !1;
      }
      __name(stopPresenceCheck, "stopPresenceCheck");
      function showConfirmationOverlay(callback) {
        let bodyContent = document.createElement("div");
        bodyContent.style.display = "flex", bodyContent.style.flexDirection = "column", bodyContent.style.gap = "16px";
        let description = document.createElement("p");
        description.className = "text-body", description.innerHTML = purify.sanitize(`
                This will automatically attempts to join the user as soon as they get into an experience.
                <br><br>
                This requires the user to have their joins enabled for everyone or for you to be friends with them.
            `);
        let selectedGame = null, searchInputComponent = createSearchInput({
          placeholder: "Search for an experience or enter a Place ID (Optional)",
          style: { width: "100%" },
          onResultSelect: /* @__PURE__ */ __name((game) => {
            selectedGame = game, searchInputComponent.input.value = game.name, searchInputComponent.hideDropdown(), continueButton.disabled = !1;
          }, "onResultSelect")
        });
        bodyContent.append(description, searchInputComponent.element);
        let continueButton = document.createElement("button");
        continueButton.innerText = "Continue", continueButton.className = "btn-primary-md";
        let goBackButton = document.createElement("button");
        goBackButton.innerText = "Cancel", goBackButton.className = "btn-control-md";
        let cleanupDropdown = null, { close } = createOverlay({
          title: "Confirm Action",
          bodyContent,
          actions: [goBackButton, continueButton],
          maxWidth: "480px",
          onClose: /* @__PURE__ */ __name(() => {
            cleanupDropdown && cleanupDropdown();
          }, "onClose")
        }), dropdown = searchInputComponent.element.querySelector(".game-search-dropdown");
        if (dropdown) {
          document.body.appendChild(dropdown), dropdown.style.zIndex = "10005", dropdown.addEventListener("click", (e) => e.stopPropagation());
          let updatePosition = /* @__PURE__ */ __name(() => {
            let rect = searchInputComponent.input.getBoundingClientRect();
            dropdown.style.position = "absolute", dropdown.style.top = `${rect.bottom + window.scrollY + 5}px`, dropdown.style.left = `${rect.left + window.scrollX}px`, dropdown.style.width = `${rect.width}px`;
          }, "updatePosition"), observer = observeAttributes(dropdown, () => {
            dropdown.style.display !== "none" && updatePosition();
          }, ["style"]);
          window.addEventListener("resize", updatePosition), window.addEventListener("scroll", updatePosition, { capture: !0 }), cleanupDropdown = /* @__PURE__ */ __name(() => {
            dropdown.remove(), window.removeEventListener("resize", updatePosition), window.removeEventListener("scroll", updatePosition, { capture: !0 }), observer.disconnect();
          }, "cleanupDropdown");
        }
        continueButton.onclick = () => {
          let specificPlaceId = null, thumbnailUrl = null;
          selectedGame && searchInputComponent.input.value === searchInputComponent.getSelectedGameName() && (specificPlaceId = selectedGame.rootPlaceId, thumbnailUrl = selectedGame.thumbnail?.imageUrl), close(), callback({ confirmed: !0, placeId: specificPlaceId, thumbnailUrl });
        }, goBackButton.onclick = () => {
          close(), callback(!1);
        };
      }
      __name(showConfirmationOverlay, "showConfirmationOverlay");
      function addInstantJoinButton(observedElement) {
        let button = createSquareButton({
          content: "Instant Join",
          id: "rovalra-instant-join-button",
          textColor: "var(--rovalra-main-text-color)",
          width: "auto",
          height: "height-1000",
          paddingX: "padding-x-small",
          disableTextTruncation: !0
        });
        if (button.addEventListener("click", async () => {
          let userId = getUserIdFromUrl2();
          if (isRunning) {
            stopPresenceCheck();
            return;
          }
          showConfirmationOverlay(async (result) => {
            if (!result.confirmed)
              return;
            isRunning = !0;
            let specificPlaceId = result.placeId, thumbnailUrl = result.thumbnailUrl;
            enableForcedHeaders(), document.querySelectorAll(".rovalra-instant-join-button").forEach((btn) => {
              let contentSpan = btn.querySelector("span");
              if (contentSpan.innerHTML = "", thumbnailUrl) {
                Object.assign(contentSpan.style, {
                  display: "flex",
                  alignItems: "center",
                  gap: "5px"
                });
                let thumbImg = document.createElement("img");
                thumbImg.src = thumbnailUrl, Object.assign(thumbImg.style, { width: "36px", height: "36px", borderRadius: "4px" }), contentSpan.appendChild(thumbImg), contentSpan.appendChild(document.createTextNode("Stop Joining"));
              } else
                contentSpan.textContent = "Stop Joining";
              btn.setAttribute("aria-disabled", "false");
            }), intervalId = setInterval(async () => {
              let currentTime = Date.now();
              currentTime - lastRequestTime >= requestDelay && (await sendPresenceRequest(userId, specificPlaceId), lastRequestTime = currentTime);
            }, 50);
          });
        }), observedElement.querySelector(".rovalra-instant-join-button"))
          return;
        let loggedInUserIdMeta = document.querySelector('meta[name="user-data"]');
        if (!loggedInUserIdMeta) return;
        let loggedInUserId = parseInt(loggedInUserIdMeta.getAttribute("data-userid"), 10), profileUserId = getUserIdFromUrl2();
        !profileUserId || loggedInUserId === profileUserId || (button.classList.add("rovalra-instant-join-button"), button.style.flexGrow = "0", button.style.flexShrink = "0", button.style.marginRight = "5px", observedElement.prepend(button));
      }
      __name(addInstantJoinButton, "addInstantJoinButton"), observeElement(".profile-header-buttons, .buttons-show-on-desktop, .buttons-show-on-mobile", addInstantJoinButton, { multiple: !0 });
    });
  }
  __name(init44, "init");

  // src/content/features/profile/outfits.js
  function init45() {
    chrome.storage.local.get("useroutfitsEnabled", function(data) {
      if (data.useroutfitsEnabled !== !0)
        return;
      async function fetchAllOutfits2(userId, onChunkFetched, loadingControl) {
        let paginationToken = null, hasMore = !0;
        for (; hasMore && !(loadingControl && loadingControl.cancelled); ) {
          let url = `https://avatar.roblox.com/v2/avatar/users/${userId}/outfits?outfitType=1&page=1&itemsPerPage=50&isEditable=true`;
          paginationToken && (url = `https://avatar.roblox.com/v2/avatar/users/${userId}/outfits?paginationToken=${paginationToken}&outfitType=1&page=1&itemsPerPage=50&isEditable=true`);
          let response = await callRobloxApi({
            subdomain: "avatar",
            endpoint: url.replace("https://avatar.roblox.com", "")
          });
          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);
          let result = await response.json();
          if (loadingControl && loadingControl.cancelled)
            break;
          onChunkFetched && result.data.length > 0 && await onChunkFetched(result.data), paginationToken = result.paginationToken, hasMore = !!paginationToken;
        }
      }
      __name(fetchAllOutfits2, "fetchAllOutfits");
      async function checkCanViewInventory(userId) {
        try {
          let response = await callRobloxApi({
            subdomain: "inventory",
            endpoint: `/v1/users/${userId}/can-view-inventory`
          });
          return response.ok ? !!(await response.json()).canView : !1;
        } catch {
          return !1;
        }
      }
      __name(checkCanViewInventory, "checkCanViewInventory");
      async function fetchOutfitThumbnails(outfitIds) {
        if (outfitIds.length === 0) return /* @__PURE__ */ new Map();
        let items = outfitIds.map((id) => ({ id }));
        return await fetchThumbnails(items, "UserOutfit", "150x150");
      }
      __name(fetchOutfitThumbnails, "fetchOutfitThumbnails");
      function createOutfitsOverlay(initialOutfits, initialThumbnails, loadingControl, displayName) {
        let selectedOutfitId = null, selectedListItem = null, outfitDetailsCache = /* @__PURE__ */ new Map(), panelsWrapper = document.createElement("div");
        Object.assign(panelsWrapper.style, {
          display: "flex",
          flexDirection: "row",
          height: "70vh",
          width: "100%"
        });
        let mainPanel = document.createElement("div");
        Object.assign(mainPanel.style, {
          display: "flex",
          flexDirection: "column",
          width: "100%"
        });
        let listContainer = document.createElement("div");
        Object.assign(listContainer.style, {
          overflowY: "auto",
          flexGrow: "1",
          padding: "8px"
        });
        let list = document.createElement("ul");
        Object.assign(list.style, {
          listStyle: "none",
          padding: "0",
          margin: "0",
          display: "flex",
          flexWrap: "wrap",
          justifyContent: "center",
          gap: "10px"
        });
        let detailsPanel = document.createElement("div");
        detailsPanel.className = "rovalra-outfit-details-panel", Object.assign(detailsPanel.style, {
          width: "100%",
          display: "none",
          flexDirection: "column",
          alignItems: "center"
        });
        let backButtonWrapper = document.createElement("div");
        Object.assign(backButtonWrapper.style, {
          width: "100%",
          padding: "10px 20px 0",
          display: "flex",
          justifyContent: "flex-start"
        });
        let backButton = createButton("Back", "secondary", {
          onClick: /* @__PURE__ */ __name(() => {
            detailsPanel.style.display = "none", mainPanel.style.display = "flex";
          }, "onClick")
        });
        backButtonWrapper.appendChild(backButton), detailsPanel.appendChild(backButtonWrapper);
        let detailsContentWrapper = document.createElement("div");
        Object.assign(detailsContentWrapper.style, {
          padding: "20px 20px 0 20px",
          display: "flex",
          flexDirection: "column",
          alignItems: "center"
        });
        let detailsImageContainer = document.createElement("div");
        Object.assign(detailsImageContainer.style, {
          width: "200px",
          height: "200px",
          maxWidth: "200px",
          maxHeight: "200px",
          position: "relative",
          marginBottom: "0px",
          flexShrink: "0"
        });
        let detailsName = document.createElement("h3");
        Object.assign(detailsName.style, {
          fontSize: "22px",
          marginBottom: "0px",
          wordBreak: "break-word",
          textAlign: "center",
          color: "var(--rovalra-main-text-color)"
        });
        let separator = document.createElement("div"), totalPriceElement2 = document.createElement("div");
        totalPriceElement2.id = "rovalra-outfit-total-price", Object.assign(totalPriceElement2.style, {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          marginTop: "0px",
          fontSize: "16px",
          fontWeight: "600",
          color: "var(--rovalra-secondary-text-color)"
        }), Object.assign(separator.style, {
          height: "1px",
          width: "90%",
          backgroundColor: "var(--rovalra-border-color)",
          margin: "10px auto"
        });
        let itemsContainer = document.createElement("div");
        itemsContainer.className = "rovalra-outfit-items-container", Object.assign(itemsContainer.style, {
          width: "100%",
          flexGrow: "0",
          padding: "0px 0px 20px",
          overflowY: "hidden",
          height: "100%"
        });
        let paginationContainer = document.createElement("div");
        paginationContainer.className = "rovalra-outfit-pagination-container", Object.assign(paginationContainer.style, {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          padding: "10px 0",
          visibility: "hidden",
          flexShrink: "0"
        }), detailsContentWrapper.appendChild(detailsImageContainer), detailsContentWrapper.appendChild(detailsName), detailsContentWrapper.appendChild(totalPriceElement2), detailsPanel.appendChild(detailsContentWrapper), detailsPanel.appendChild(separator), detailsPanel.appendChild(itemsContainer), detailsPanel.appendChild(paginationContainer);
        let noOutfitsMessage = document.createElement("li");
        noOutfitsMessage.textContent = "Loading outfits...", Object.assign(noOutfitsMessage.style, {
          padding: "20px",
          fontSize: "16px",
          textAlign: "center",
          color: "var(--rovalra-secondary-text-color)"
        }), list.appendChild(noOutfitsMessage);
        let handleKeydown = /* @__PURE__ */ __name((e) => {
          e.key === "Escape" && close();
        }, "handleKeydown"), { close } = createOverlay({
          title: displayName ? `${displayName}'s Outfits` : "User Outfits",
          bodyContent: panelsWrapper,
          maxWidth: "1000px",
          maxHeight: "85vh",
          showLogo: !0,
          onClose: /* @__PURE__ */ __name(() => {
            loadingControl && (loadingControl.cancelled = !0), window.removeEventListener("keydown", handleKeydown);
          }, "onClose")
        });
        window.addEventListener("keydown", handleKeydown);
        let resizeObserver = null, selectOutfit = /* @__PURE__ */ __name(async (outfit, listItem) => {
          if (selectedOutfitId === outfit.id) {
            mainPanel.style.display = "none", detailsPanel.style.display = "flex";
            return;
          }
          selectedListItem && (selectedListItem.style.backgroundColor = "transparent"), listItem.style.backgroundColor = "var(--rovalra-button-background-color)", selectedListItem = listItem, selectedOutfitId = outfit.id, resizeObserver && resizeObserver.disconnect(), mainPanel.style.display = "none", detailsPanel.style.display = "flex", detailsName.textContent = outfit.name;
          let totalPriceDisplay = document.getElementById(
            "rovalra-outfit-total-price"
          );
          for (totalPriceDisplay && (totalPriceDisplay.innerHTML = ""); detailsImageContainer.firstChild; )
            detailsImageContainer.firstChild.remove();
          let shimmerPlaceholder = document.createElement("div");
          shimmerPlaceholder.className = "thumbnail-2d-container shimmer", Object.assign(shimmerPlaceholder.style, {
            width: "100%",
            height: "100%",
            position: "absolute",
            borderRadius: "8px",
            backgroundColor: "var(--rovalra-button-background-color)"
          }), detailsImageContainer.prepend(shimmerPlaceholder);
          let calculatePlaceholders = /* @__PURE__ */ __name(() => {
            let containerWidth = itemsContainer.clientWidth, containerHeight = itemsContainer.clientHeight, itemWidth = 150, itemHeight = 220, gap = 20;
            if (containerWidth <= 0 || containerHeight <= 0) return 8;
            let scrollbarTolerance = 1, itemsPerRow = Math.floor(
              (containerWidth - scrollbarTolerance + gap) / (itemWidth + gap)
            ), rowsPerPage = Math.floor(
              (containerHeight - scrollbarTolerance + gap) / (itemHeight + gap)
            );
            return Math.max(1, itemsPerRow * rowsPerPage);
          }, "calculatePlaceholders");
          itemsContainer.innerHTML = safeHtml('<p style="color: var(--rovalra-secondary-text-color); font-style: italic; text-align: center;">Loading items...</p>'), itemsContainer.style.display = "flex", itemsContainer.style.flexWrap = "wrap", itemsContainer.style.justifyContent = "center", itemsContainer.style.alignContent = "flex-start", itemsContainer.style.gap = "20px", paginationContainer.style.visibility = "hidden";
          let createItemPlaceholder = /* @__PURE__ */ __name(() => {
            let itemCardContainer = document.createElement("div");
            itemCardContainer.className = "item-card-container", Object.assign(itemCardContainer.style, {
              width: "150px",
              height: "auto",
              maxHeight: "220px",
              display: "flex",
              flexDirection: "column"
            });
            let thumbContainer = document.createElement("div");
            Object.assign(thumbContainer.style, {
              width: "150px",
              height: "150px",
              backgroundColor: "var(--rovalra-button-background-color)",
              borderRadius: "8px",
              overflow: "hidden"
            });
            let shimmerEffect = document.createElement("div");
            shimmerEffect.className = "thumbnail-2d-container shimmer", Object.assign(shimmerEffect.style, {
              width: "100%",
              height: "100%"
            }), thumbContainer.appendChild(shimmerEffect);
            let namePlaceholder = document.createElement("div");
            return Object.assign(namePlaceholder.style, {
              width: "90%",
              height: "14px",
              backgroundColor: "var(--rovalra-button-background-color)",
              marginTop: "8px",
              borderRadius: "4px"
            }), itemCardContainer.appendChild(thumbContainer), itemCardContainer.appendChild(namePlaceholder), itemCardContainer;
          }, "createItemPlaceholder");
          itemsContainer.innerHTML = "";
          let placeholderCount = calculatePlaceholders();
          for (let i = 0; i < placeholderCount; i++)
            itemsContainer.appendChild(createItemPlaceholder());
          let renderOutfitDetails = /* @__PURE__ */ __name((outfitData) => {
            if (selectedOutfitId !== outfit.id) return;
            let {
              largeThumbData,
              assets: assets3,
              thumbnailMap,
              catalogDetailsMap
            } = outfitData, totalOutfitPrice = 0, processedBundleIds2 = /* @__PURE__ */ new Set();
            assets3 && catalogDetailsMap && assets3.forEach((asset) => {
              let details = catalogDetailsMap[asset.id];
              details && details.isPurchasable && details.priceInRobux > 0 && (details.itemType === "Bundle" ? processedBundleIds2.has(details.id) || (totalOutfitPrice += details.priceInRobux, processedBundleIds2.add(details.id)) : totalOutfitPrice += details.priceInRobux);
            });
            let totalPriceDisplay2 = document.getElementById(
              "rovalra-outfit-total-price"
            );
            if (totalPriceDisplay2) {
              totalPriceDisplay2.innerHTML = "";
              let robuxIcon = document.createElement("span");
              robuxIcon.className = "icon-robux-16x16", robuxIcon.style.margin = "0 4px 0 8px", totalPriceDisplay2.append(
                "Total Price:",
                robuxIcon,
                totalOutfitPrice.toLocaleString()
              );
            }
            if (largeThumbData) {
              detailsImageContainer.innerHTML = "";
              let largeThumbEl = createThumbnailElement(
                largeThumbData,
                outfit.name,
                "",
                {
                  width: "100%",
                  height: "100%",
                  borderRadius: "8px",
                  objectFit: "cover"
                }
              );
              detailsImageContainer.appendChild(largeThumbEl);
            }
            if (!assets3 || assets3.length === 0) {
              itemsContainer.innerHTML = safeHtml(
                '<p style="font-style: italic; text-align: center;">This outfit has no items.</p>'
              ), itemsContainer.style.display = "block", paginationContainer.style.visibility = "hidden";
              return;
            }
            let calculateItemsPerPage = /* @__PURE__ */ __name(() => {
              let containerWidth = itemsContainer.clientWidth, containerHeight = itemsContainer.clientHeight, itemWidth = 150, itemHeight = 220, gap = 20;
              if (containerWidth <= 0 || containerHeight <= 0)
                return 8;
              let itemsPerRow = Math.floor(
                (containerWidth + gap) / (itemWidth + gap)
              ), rowsPerPage = Math.floor(
                (containerHeight + gap) / (itemHeight + gap)
              );
              return Math.max(1, itemsPerRow * rowsPerPage);
            }, "calculateItemsPerPage"), currentPage = 0, itemsPerPage = calculateItemsPerPage(), totalPages = assets3.length > 0 ? Math.ceil(assets3.length / itemsPerPage) : 0, resizeTimeout, handleResize = /* @__PURE__ */ __name(() => {
              clearTimeout(resizeTimeout), resizeTimeout = setTimeout(() => {
                let newItemsPerPage = calculateItemsPerPage();
                if (newItemsPerPage !== itemsPerPage) {
                  let firstItemIndex = currentPage * itemsPerPage;
                  itemsPerPage = newItemsPerPage, totalPages = assets3.length > 0 ? Math.ceil(
                    assets3.length / itemsPerPage
                  ) : 0, currentPage = Math.floor(
                    firstItemIndex / itemsPerPage
                  ), renderItemsPage(currentPage), updatePaginationControls();
                }
              }, 50);
            }, "handleResize");
            resizeObserver = new ResizeObserver(handleResize), resizeObserver.observe(itemsContainer);
            let renderItemsPage = /* @__PURE__ */ __name((page) => {
              itemsContainer.innerHTML = "", Object.assign(itemsContainer.style, {
                display: "flex",
                flexWrap: "wrap",
                justifyContent: "center",
                alignContent: "flex-start",
                gap: "20px"
              });
              let startIndex = page * itemsPerPage;
              assets3.slice(
                startIndex,
                startIndex + itemsPerPage
              ).forEach((asset) => {
                let assetDetails = catalogDetailsMap[asset.id], priceText = "", itemRestrictions = [], price = null, bundleId = null;
                assetDetails && (itemRestrictions = assetDetails.itemRestrictions || [], assetDetails.isPurchasable ? (price = assetDetails.priceInRobux, assetDetails.itemType === "Bundle" && (bundleId = assetDetails.id), assetDetails.priceInRobux > 0 ? priceText = `<span class="icon-robux-16x16" style="margin-right: 4px; vertical-align: middle;"></span>${assetDetails.priceInRobux.toLocaleString()}` : priceText = "Free") : priceText = "Off Sale");
                let itemData = {
                  assetId: asset.id,
                  name: asset.name,
                  itemType: "Asset",
                  priceText,
                  itemRestrictions,
                  price,
                  bundleId
                }, card = createItemCard(itemData, thumbnailMap, { showSerial: !1 });
                itemsContainer.appendChild(card);
              });
            }, "renderItemsPage"), updatePaginationControls = /* @__PURE__ */ __name(() => {
              if (paginationContainer.innerHTML = "", totalPages <= 1) {
                paginationContainer.style.visibility = "hidden";
                return;
              }
              let { leftButton, rightButton } = createScrollButtons(
                {
                  onLeftClick: /* @__PURE__ */ __name(() => {
                    currentPage > 0 && (currentPage--, renderItemsPage(currentPage), updatePaginationControls());
                  }, "onLeftClick"),
                  onRightClick: /* @__PURE__ */ __name(() => {
                    currentPage < totalPages - 1 && (currentPage++, renderItemsPage(currentPage), updatePaginationControls());
                  }, "onRightClick")
                }
              );
              currentPage === 0 && (leftButton.classList.add("disabled"), leftButton.disabled = !0, leftButton.style.opacity = "0.5"), currentPage >= totalPages - 1 && (rightButton.classList.add("disabled"), rightButton.disabled = !0, rightButton.style.opacity = "0.5"), paginationContainer.append(leftButton, rightButton), paginationContainer.style.visibility = "visible";
            }, "updatePaginationControls");
            renderItemsPage(0), updatePaginationControls();
          }, "renderOutfitDetails");
          if (outfitDetailsCache.has(outfit.id))
            renderOutfitDetails(outfitDetailsCache.get(outfit.id));
          else
            try {
              let largeThumbData = (await fetchThumbnails(
                [{ id: outfit.id }],
                "UserOutfit",
                "420x420"
              )).get(outfit.id), detailsResponse = await callRobloxApi({
                subdomain: "avatar",
                endpoint: `/v1/outfits/${outfit.id}/details`
              });
              if (!detailsResponse.ok)
                throw new Error(
                  `HTTP Error: ${detailsResponse.status}`
                );
              let assets3 = (await detailsResponse.json()).assets, thumbnailMap = /* @__PURE__ */ new Map(), catalogDetailsMap = {};
              if (assets3 && assets3.length > 0) {
                let assetIds = assets3.map((asset) => asset.id), fetchPromises = [];
                fetchPromises.push(
                  (async () => {
                    let items = assetIds.map((id) => ({
                      id
                    }));
                    thumbnailMap = await fetchThumbnails(
                      items,
                      "Asset",
                      "150x150"
                    );
                  })()
                );
                let BATCH_SIZE2 = 50;
                for (let i = 0; i < assetIds.length; i += BATCH_SIZE2) {
                  let payload = {
                    assets: assetIds.slice(
                      i,
                      i + BATCH_SIZE2
                    ).map((id) => ({ id }))
                  };
                  fetchPromises.push(
                    (async () => {
                      let catalogResponse = await callRobloxApi({
                        subdomain: "apis",
                        endpoint: "/look-api/v1/looks/purchase-details",
                        method: "POST",
                        body: payload
                      });
                      if (!catalogResponse.ok)
                        throw new Error(
                          `HTTP Error fetching catalog details: ${catalogResponse.status}`
                        );
                      let catalogData = await catalogResponse.json();
                      catalogData.look && catalogData.look.items && catalogData.look.items.forEach(
                        (item) => {
                          item.itemType === "Bundle" && item.assetsInBundle ? item.assetsInBundle.forEach(
                            (bundleAsset) => {
                              catalogDetailsMap[bundleAsset.id] = item;
                            }
                          ) : catalogDetailsMap[item.id] = item;
                        }
                      );
                    })()
                  );
                }
                await Promise.all(fetchPromises);
              }
              let newOutfitData = {
                largeThumbData,
                assets: assets3,
                thumbnailMap,
                catalogDetailsMap
              };
              if (outfitDetailsCache.set(outfit.id, newOutfitData), selectedOutfitId !== outfit.id) return;
              renderOutfitDetails(newOutfitData);
            } catch {
              itemsContainer.innerHTML = purify.sanitize(
                '<p style="color: var(--rovalra-secondary-text-color); font-style: italic; text-align: center; margin-right: auto; margin-left: auto;">Could not load items.</p>'
              );
            }
          shimmerPlaceholder.parentNode && shimmerPlaceholder.remove();
        }, "selectOutfit"), renderOutfitListItem = /* @__PURE__ */ __name((outfit, thumbnails) => {
          let listItem = document.createElement("li");
          Object.assign(listItem.style, {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            padding: "8px",
            borderRadius: "6px",
            cursor: "pointer",
            transition: "background-color 0.2s ease",
            width: "170px"
          }), listItem.addEventListener("mouseenter", () => {
            listItem !== selectedListItem && (listItem.style.backgroundColor = "var(--rovalra-container-background-color)");
          }), listItem.addEventListener("mouseleave", () => {
            listItem !== selectedListItem && (listItem.style.backgroundColor = "transparent");
          }), listItem.addEventListener(
            "click",
            () => selectOutfit(outfit, listItem)
          );
          let thumbnailData = thumbnails.get(outfit.id), thumbnailContainer = document.createElement("div");
          Object.assign(thumbnailContainer.style, {
            width: "150px",
            height: "150px",
            marginBottom: "8px",
            borderRadius: "6px",
            flexShrink: "0",
            backgroundColor: "var(--rovalra-button-background-color)",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            overflow: "hidden"
          });
          let thumbnailElement = createThumbnailElement(
            thumbnailData,
            outfit.name,
            "",
            { width: "100%", height: "100%" }
          );
          thumbnailContainer.appendChild(thumbnailElement), listItem.appendChild(thumbnailContainer);
          let nameSpan = document.createElement("span");
          return nameSpan.textContent = outfit.name, Object.assign(nameSpan.style, {
            fontSize: "14px",
            fontWeight: "500",
            textAlign: "center",
            wordBreak: "break-word",
            lineHeight: "1.2",
            maxHeight: "2.4em",
            overflow: "hidden"
          }), listItem.appendChild(nameSpan), listItem;
        }, "renderOutfitListItem");
        mainPanel.appendChild(listContainer), listContainer.appendChild(list), panelsWrapper.appendChild(mainPanel), panelsWrapper.appendChild(detailsPanel);
        let outfitsLoaded = !1;
        return {
          addOutfits: /* @__PURE__ */ __name((outfits, thumbnails) => {
            outfitsLoaded || (list.innerHTML = "", outfitsLoaded = !0), outfits.forEach((outfit, index) => {
              let listItem = renderOutfitListItem(
                outfit,
                thumbnails
              );
              list.appendChild(listItem);
            });
          }, "addOutfits"),
          setNoOutfits: /* @__PURE__ */ __name((message) => {
            outfitsLoaded || (noOutfitsMessage.textContent = message || "This user has no outfits.", outfitsLoaded = !0);
          }, "setNoOutfits")
        };
      }
      __name(createOutfitsOverlay, "createOutfitsOverlay");
      function addShowOutfitsButton(element) {
        let container = null, buttonStyle = null, avatarToggleButton = element.classList.contains(
          "avatar-toggle-button"
        ) ? element : element.querySelector(".avatar-toggle-button");
        if (avatarToggleButton && (container = avatarToggleButton, buttonStyle = "toggle"), !container || container.querySelector(".rovalra-show-outfits-btn"))
          return;
        window.getComputedStyle(container).position === "static" && (container.style.position = "relative");
        let clickHandler = /* @__PURE__ */ __name(async (event) => {
          showReviewPopup("outfits");
          let displayNameElement = document.querySelector(
            "#profile-header-title-container-name"
          ), displayName = displayNameElement ? displayNameElement.textContent.trim() : "User", loadingControl = { cancelled: !1 }, outfitsOverlay = createOutfitsOverlay(
            [],
            /* @__PURE__ */ new Map(),
            loadingControl,
            displayName
          );
          try {
            let userId = getUserIdFromUrl();
            if (userId) {
              let outfitsFound = !1;
              if (await fetchAllOutfits2(
                userId,
                async (outfitsChunk) => {
                  if (loadingControl.cancelled) return;
                  outfitsFound = !0;
                  let outfitIds = outfitsChunk.map((o) => o.id), thumbnails = await fetchOutfitThumbnails(outfitIds);
                  outfitsOverlay.addOutfits(
                    outfitsChunk,
                    thumbnails
                  );
                },
                loadingControl
              ), !outfitsFound && !loadingControl.cancelled) {
                let canView = await checkCanViewInventory(userId);
                if (loadingControl.cancelled) return;
                outfitsOverlay.setNoOutfits(
                  canView ? "This user has no outfits." : "User's inventory is private."
                );
              }
            } else
              alert("Could not determine the User ID from the page.");
          } catch {
            loadingControl.cancelled || alert("Could not fetch outfits.");
          }
        }, "clickHandler"), button;
        buttonStyle === "square" ? (button = createSquareButton({
          content: "Show Outfits",
          onClick: clickHandler,
          width: "auto",
          paddingX: "padding-x-medium",
          disableTextTruncation: !0,
          fontSize: "16px"
        }), Object.assign(button.style, {
          position: "absolute",
          height: "48px",
          top: "12px",
          left: "5px",
          zIndex: "10"
        })) : buttonStyle === "toggle" ? (button = createSquareButton({
          content: "Show Outfits",
          onClick: clickHandler,
          width: "auto",
          height: "height-1200",
          paddingX: "padding-x-medium",
          disableTextTruncation: !0
        }), button.classList.replace(
          "text-label-medium",
          "text-label-large"
        ), container.style.display = "flex", container.style.gap = "10px") : (button = createButton("Show Outfits", "secondary", {
          onClick: clickHandler
        }), Object.assign(button.style, {
          position: "absolute",
          bottom: "5px",
          left: "5px",
          zIndex: "10"
        })), button.classList.add("rovalra-show-outfits-btn"), buttonStyle === "toggle" ? container.prepend(button) : container.appendChild(button);
      }
      __name(addShowOutfitsButton, "addShowOutfitsButton"), observeElement(
        ".btn-open-outfits",
        (button) => {
          button.style.display = "none";
        },
        { multiple: !0 }
      ), observeElement(
        ".avatar-toggle-button",
        addShowOutfitsButton,
        {
          multiple: !0
        }
      );
    });
  }
  __name(init45, "init");

  // src/content/features/profile/privateserver.js
  var INACTIVE_MAIN_BUTTON_ID = "rovalra-bulk-inactivate-btn", SET_INACTIVE_BTN_ID = "rovalra-set-inactive-btn", ACTIVE_MAIN_BUTTON_ID = "rovalra-bulk-activate-btn", SET_ACTIVE_BTN_ID = "rovalra-set-active-btn", SELECT_ALL_BTN_ID = "rovalra-select-all-btn", FILTERED_LIST_ID = "rovalra-filtered-assets-list", PROGRESS_TEXT_ID = "rovalra-progress-text", PROGRESS_RESULTS_ID = "rovalra-progress-results", LOADING_SPINNER_ID = "rovalra-loading-spinner", isFilteredInactive = !1, isFilteredActive = !1;
  async function processServerRequest(selectedItems, isActive) {
    let isCancelled = !1, bodyContent = document.createElement("div");
    bodyContent.style.textAlign = "center", bodyContent.innerHTML = `
        <div id="${PROGRESS_TEXT_ID}">Starting...</div>
        <div id="${LOADING_SPINNER_ID}"></div>
        <div id="${PROGRESS_RESULTS_ID}" style="display: none;"></div>
    `;
    let cancelButton = createButton("Cancel", "primary-destructive", {
      onClick: /* @__PURE__ */ __name(() => {
        isCancelled = !0, progressText.textContent = "Cancelling...", cancelButton.disabled = !0;
      }, "onClick")
    }), { overlay, close } = createOverlay({
      title: "Processing Servers",
      bodyContent,
      actions: [cancelButton],
      maxWidth: "500px"
    }), progressText = bodyContent.querySelector(`#${PROGRESS_TEXT_ID}`), resultsContainer = bodyContent.querySelector(
      `#${PROGRESS_RESULTS_ID}`
    ), spinner = bodyContent.querySelector(`#${LOADING_SPINNER_ID}`), footer = overlay.querySelector(".flex.justify-end");
    cancelButton.onclick = () => {
      isCancelled = !0, progressText.textContent = "Cancelling...", cancelButton.disabled = !0;
    };
    let totalServers = selectedItems.length, actionText = isActive ? "Activating" : "Inactivating", errorLog = [], i = 0;
    for (i = 0; i < totalServers && !isCancelled; i++) {
      let serverItem = selectedItems[i], serverId = serverItem.dataset.serverId, placeId = serverItem.dataset.placeId;
      progressText.textContent = `${actionText} server ${i + 1} of ${totalServers}...`;
      let serverName = serverItem.closest(".selectable-item-card").querySelector(".item-card-name").title;
      try {
        let response = await callRobloxApi({
          subdomain: "games",
          endpoint: `/v1/vip-servers/${serverId}`,
          method: "PATCH",
          body: { active: isActive }
        });
        if (response.ok)
          serverItem.closest("li").remove();
        else {
          let errorData = await response.json(), errorMessage = errorData.errors && errorData.errors[0] ? errorData.errors[0].message : "An unknown API error occurred.";
          errorLog.push({
            placeId,
            name: serverName,
            reason: errorMessage
          });
        }
      } catch (error) {
        console.error(error);
      }
      i < totalServers - 1 && await new Promise((res) => setTimeout(res, 500));
    }
    spinner.style.display = "none", resultsContainer.style.display = "flex", resultsContainer.innerHTML = "", footer && (footer.innerHTML = "");
    let successCount = i - errorLog.length;
    isCancelled ? progressText.innerHTML = safeHtml`Process Cancelled. <span class="success-text">${successCount} server(s) processed.</span>` : progressText.innerHTML = safeHtml`Completed: <span class="success-text">${successCount} succeeded</span>, <span class="error-text">${errorLog.length} failed</span>.`;
    let resultBody = document.createElement("div");
    if (errorLog.length > 0) {
      let errorList = document.createElement("ul");
      errorLog.forEach((err) => {
        let errorItem = document.createElement("li"), gameUrl = `https://www.roblox.com/games/${err.placeId}`;
        errorItem.innerHTML = safeHtml`<a href="${gameUrl}" target="_blank" rel="noopener noreferrer">${err.name}</a>: ${err.reason}`, errorList.appendChild(errorItem);
      }), resultBody.appendChild(errorList);
    }
    let iconUrl = getAssets().rovalraIcon, successImage = document.createElement("img");
    successImage.src = iconUrl, successImage.style.width = "64px", successImage.style.height = "64px", successImage.style.margin = "15px auto 5px auto", successImage.style.display = "block", resultBody.appendChild(successImage);
    let titleElement = overlay.querySelector(
      ".group-description-dialog-body-header"
    );
    titleElement && (titleElement.textContent = "Processing Complete"), resultsContainer.appendChild(resultBody), setTimeout(() => {
      close(), updateButtonStates();
    }, 5e3);
  }
  __name(processServerRequest, "processServerRequest");
  function showConfirmationModal(selectedItems, isActive) {
    let action = isActive ? "active" : "inactive", bodyContent = document.createElement("div");
    bodyContent.innerHTML = safeHtml`
        <p>You are about to set ${selectedItems.length} private server(s) as ${action}.</p>
        <p>${isActive ? "This will make the private server joinable." : "This will make the private server unjoinable."}</p>
        <p>You can always change this back later.</p>
    `;
    let confirmButton = createButton(
      "Confirm",
      isActive ? "primary-confirm" : "primary-destructive",
      {
        onClick: /* @__PURE__ */ __name(() => {
          close(), processServerRequest(selectedItems, isActive);
        }, "onClick")
      }
    ), cancelButton = createButton("Cancel", "secondary"), { close } = createOverlay({
      title: "Confirm Action",
      bodyContent,
      actions: [cancelButton, confirmButton]
    });
  }
  __name(showConfirmationModal, "showConfirmationModal");
  function updateButtonStates() {
    let selectAllButton = document.getElementById(SELECT_ALL_BTN_ID), checkboxes = document.querySelectorAll(
      `#${FILTERED_LIST_ID} button[role="checkbox"]`
    ), selectedCount = Array.from(checkboxes).filter(
      (cb) => cb.getAttribute("aria-checked") === "true"
    ).length, setInactiveButton = document.getElementById(SET_INACTIVE_BTN_ID), setActiveButton = document.getElementById(SET_ACTIVE_BTN_ID);
    setInactiveButton && (setInactiveButton.disabled = selectedCount === 0), setActiveButton && (setActiveButton.disabled = selectedCount === 0), selectAllButton && selectAllButton.style.display !== "none" && (checkboxes.length > 0 && selectedCount === checkboxes.length ? selectAllButton.textContent = "Deselect All" : selectAllButton.textContent = "Select All");
  }
  __name(updateButtonStates, "updateButtonStates");
  function handleSelectAll() {
    let checkboxes = document.querySelectorAll(
      `#${FILTERED_LIST_ID} button[role="checkbox"]`
    );
    if (checkboxes.length === 0) return;
    let shouldSelectAll = Array.from(checkboxes).some(
      (cb) => cb.getAttribute("aria-checked") !== "true"
    );
    checkboxes.forEach((checkbox) => {
      checkbox.getAttribute("aria-checked") === "true" !== shouldSelectAll && (checkbox.setChecked(shouldSelectAll), checkbox.dispatchEvent(new Event("change", { bubbles: !0 })));
    }), updateButtonStates();
  }
  __name(handleSelectAll, "handleSelectAll");
  function cleanupUI() {
    [
      INACTIVE_MAIN_BUTTON_ID,
      SET_INACTIVE_BTN_ID,
      ACTIVE_MAIN_BUTTON_ID,
      SET_ACTIVE_BTN_ID,
      SELECT_ALL_BTN_ID,
      FILTERED_LIST_ID
    ].forEach((id) => {
      document.getElementById(id)?.remove();
    });
    let originalAssetsList = document.getElementById("assetsItems");
    originalAssetsList && (originalAssetsList.style.display = ""), isFilteredInactive = !1, isFilteredActive = !1;
  }
  __name(cleanupUI, "cleanupUI");
  function handleBulkAction(isActive) {
    let originalAssetsList = document.getElementById("assetsItems");
    if (!originalAssetsList) return;
    let mainButtonInactive = document.getElementById(INACTIVE_MAIN_BUTTON_ID), mainButtonActive = document.getElementById(ACTIVE_MAIN_BUTTON_ID), setInactiveButton = document.getElementById(SET_INACTIVE_BTN_ID), setActiveButton = document.getElementById(SET_ACTIVE_BTN_ID), selectAllButton = document.getElementById(SELECT_ALL_BTN_ID), fetchAllServers = /* @__PURE__ */ __name(async (url) => {
      let allData = [], nextCursor = "", initialUrl = new URL(url);
      do {
        let currentUrl = new URL(initialUrl);
        nextCursor && currentUrl.searchParams.set("cursor", nextCursor);
        let response = await callRobloxApi({
          subdomain: "games",
          endpoint: `${currentUrl.pathname}${currentUrl.search}`
        });
        if (!response.ok)
          throw new Error(`HTTP error! status: ${response.status}`);
        let body = await response.json();
        body.data && (allData = allData.concat(body.data)), nextCursor = body.nextPageCursor;
      } while (nextCursor);
      return allData;
    }, "fetchAllServers");
    if (isActive && isFilteredActive || !isActive && isFilteredInactive) {
      originalAssetsList.style.display = "", document.getElementById(FILTERED_LIST_ID)?.remove(), mainButtonInactive && (mainButtonInactive.textContent = "Bulk Inactivate", mainButtonInactive.style.display = "block", mainButtonInactive.style.right = "130px"), mainButtonActive && (mainButtonActive.textContent = "Bulk Activate", mainButtonActive.style.display = "block", mainButtonActive.style.right = "0px"), setInactiveButton && (setInactiveButton.style.right = "285px", setInactiveButton.style.display = "none"), setActiveButton && (setActiveButton.style.right = "155px", setActiveButton.style.display = "none"), selectAllButton && (selectAllButton.style.display = "none"), isFilteredInactive = !1, isFilteredActive = !1;
      return;
    }
    isFilteredInactive = !isActive, isFilteredActive = isActive, originalAssetsList.style.display = "none", selectAllButton && (selectAllButton.style.display = "block"), updateButtonStates(), isActive ? (mainButtonActive && (mainButtonActive.textContent = "Cancel", mainButtonActive.style.right = "0px"), setActiveButton && (setActiveButton.style.right = "85px", setActiveButton.style.display = "block"), selectAllButton && (selectAllButton.style.right = "190px"), mainButtonInactive && (mainButtonInactive.style.display = "none")) : (mainButtonInactive && (mainButtonInactive.textContent = "Cancel", mainButtonInactive.style.right = "0px"), setInactiveButton && (setInactiveButton.style.right = "85px", setInactiveButton.style.display = "block"), selectAllButton && (selectAllButton.style.right = "195px"), mainButtonActive && (mainButtonActive.style.display = "none")), document.getElementById(FILTERED_LIST_ID)?.remove();
    let newFilteredList = document.createElement("ul");
    newFilteredList.id = FILTERED_LIST_ID, newFilteredList.className = originalAssetsList.className, originalAssetsList.parentNode.insertBefore(
      newFilteredList,
      originalAssetsList.nextSibling
    ), fetchAllServers("https://games.roblox.com/v1/private-servers/my-private-servers?itemsPerPage=100&privateServersTab=MyPrivateServers").then((allServers) => {
      let filteredServers = allServers.filter(
        (server) => server.active === !isActive && new Date(server.expirationDate) > /* @__PURE__ */ new Date()
      );
      if (filteredServers.length === 0) {
        newFilteredList.innerHTML = safeHtml`<li><div class="btr-no-servers-message">No ${isActive ? "inactive" : "active"} private servers found.</div></li>`, selectAllButton && (selectAllButton.style.display = "none");
        return;
      }
      let thumbnailItems = filteredServers.map((server) => ({
        id: server.universeId
      }));
      return fetchThumbnails(thumbnailItems, "GameIcon", "150x150").then(
        (thumbnailMap) => {
          newFilteredList.innerHTML = "", filteredServers.forEach((server) => {
            let thumbnailUrl = thumbnailMap.get(
              server.universeId
            )?.imageUrl || "", listItem = document.createElement("li");
            listItem.className = "list-item item-card ng-scope place-item selectable-item-card";
            let itemCardContainer = document.createElement("div");
            itemCardContainer.className = "item-card-container";
            let itemCardLink = document.createElement("div");
            itemCardLink.className = "item-card-link";
            let itemCardThumbContainer = document.createElement("div");
            itemCardThumbContainer.className = "item-card-thumb-container";
            let thumbnail2dContainer = document.createElement("span");
            thumbnail2dContainer.className = "thumbnail-2d-container";
            let img = document.createElement("img");
            img.src = thumbnailUrl, img.alt = server.name, img.title = server.name, thumbnail2dContainer.appendChild(img), itemCardThumbContainer.appendChild(
              thumbnail2dContainer
            );
            let itemCardName = document.createElement("div");
            itemCardName.className = "item-card-name", itemCardName.title = server.name;
            let nameSpan = document.createElement("span");
            nameSpan.className = "ng-binding", nameSpan.textContent = server.name, itemCardName.appendChild(nameSpan), itemCardLink.appendChild(itemCardThumbContainer), itemCardLink.appendChild(itemCardName);
            let itemCardLabel = document.createElement("div");
            itemCardLabel.className = "text-overflow item-card-label ng-scope";
            let bySpan = document.createElement("span");
            bySpan.className = "ng-binding", bySpan.textContent = "By ";
            let creatorLink = document.createElement("a");
            creatorLink.className = "creator-name text-overflow text-link ng-binding", creatorLink.href = `https://www.roblox.com/users/${server.ownerId}/profile`, creatorLink.target = "_blank", creatorLink.rel = "noopener noreferrer", creatorLink.textContent = `@${server.ownerName}`, itemCardLabel.appendChild(bySpan), itemCardLabel.appendChild(creatorLink);
            let itemCardPrice = document.createElement("div");
            if (itemCardPrice.className = "text-overflow item-card-price ng-scope", server.priceInRobux) {
              let iconSpan = document.createElement("span");
              iconSpan.className = "icon-robux-16x16";
              let priceSpan = document.createElement("span");
              priceSpan.className = "text-robux-tile ng-binding", priceSpan.textContent = server.priceInRobux, itemCardPrice.appendChild(iconSpan), itemCardPrice.appendChild(priceSpan);
            } else {
              let freeSpan = document.createElement("span");
              freeSpan.className = "text-overflow font-caption-body ng-binding ng-scope text-robux-tile", freeSpan.textContent = "Free", itemCardPrice.appendChild(freeSpan);
            }
            itemCardContainer.appendChild(itemCardLink), itemCardContainer.appendChild(itemCardLabel), itemCardContainer.appendChild(itemCardPrice), listItem.appendChild(itemCardContainer);
            let radio = createRadioButton();
            radio.dataset.serverId = server.privateServerId, radio.dataset.placeId = server.placeId, Object.assign(radio.style, {
              position: "absolute",
              top: "8px",
              left: "8px",
              zIndex: "5"
            }), listItem.prepend(radio), newFilteredList.appendChild(listItem);
          }), newFilteredList.querySelectorAll(".list-item.item-card").forEach((item) => {
            let checkbox = item.querySelector(
              'button[role="checkbox"]'
            );
            item.addEventListener("click", (event) => {
              if (event.target.closest("a") || event.target === checkbox)
                return;
              let isChecked = checkbox.getAttribute("aria-checked") === "true";
              checkbox.setChecked(!isChecked), checkbox.dispatchEvent(
                new Event("change", { bubbles: !0 })
              );
            }), checkbox.addEventListener("change", () => {
              let isChecked = checkbox.getAttribute("aria-checked") === "true";
              item.classList.toggle("selected", isChecked), updateButtonStates();
            });
          }), updateButtonStates();
        }
      );
    }).catch(() => {
      cleanupUI();
    });
  }
  __name(handleBulkAction, "handleBulkAction");
  function handlePageUpdate() {
    let currentUrl = window.location.href;
    if (!((currentUrl.includes("private-servers") || currentUrl.includes("my-private-servers")) && !currentUrl.includes("other-private-servers"))) {
      cleanupUI();
      return;
    }
    let headerContainer = document.querySelector(".container-header"), assetsListElement = document.getElementById("assetsItems");
    if (!headerContainer || !assetsListElement || document.getElementById(INACTIVE_MAIN_BUTTON_ID))
      return;
    let buttonWrapper = document.createElement("div");
    buttonWrapper.style.display = "flex", buttonWrapper.style.justifyContent = "flex-end", buttonWrapper.style.gap = "8px", buttonWrapper.style.bottom = "5px", buttonWrapper.style.left = "-8px", buttonWrapper.style.position = "relative", headerContainer.appendChild(buttonWrapper);
    let mainButtonInactive = createButton("Bulk Inactivate", "secondary", {
      id: INACTIVE_MAIN_BUTTON_ID
    });
    buttonWrapper.appendChild(mainButtonInactive);
    let setInactiveButton = createButton(
      "Set Inactive",
      "primary-destructive",
      { id: SET_INACTIVE_BTN_ID }
    );
    setInactiveButton.style.display = "none", buttonWrapper.appendChild(setInactiveButton);
    let mainButtonActive = createButton("Bulk Activate", "secondary", {
      id: ACTIVE_MAIN_BUTTON_ID
    });
    buttonWrapper.appendChild(mainButtonActive);
    let setActiveButton = createButton("Set Active", "primary-confirm", {
      id: SET_ACTIVE_BTN_ID
    });
    setActiveButton.style.display = "none", buttonWrapper.appendChild(setActiveButton);
    let selectAllButton = createButton("Select All", "secondary", {
      id: SELECT_ALL_BTN_ID
    });
    selectAllButton.style.display = "none", buttonWrapper.appendChild(selectAllButton), [
      mainButtonInactive,
      setInactiveButton,
      mainButtonActive,
      setActiveButton,
      selectAllButton
    ].forEach((btn) => {
      btn.style.position = "static", btn.style.top = "auto", btn.style.right = "auto", btn.style.height = "32px";
    }), setInactiveButton.addEventListener("click", () => {
      let selected = Array.from(
        document.querySelectorAll(
          'button[role="checkbox"][aria-checked="true"]'
        )
      );
      selected.length > 0 && showConfirmationModal(selected, !1);
    }), setActiveButton.addEventListener("click", () => {
      let selected = Array.from(
        document.querySelectorAll(
          'button[role="checkbox"][aria-checked="true"]'
        )
      );
      selected.length > 0 && showConfirmationModal(selected, !0);
    }), selectAllButton.addEventListener("click", handleSelectAll), mainButtonInactive.addEventListener("click", () => handleBulkAction(!1)), mainButtonActive.addEventListener("click", () => handleBulkAction(!0)), updateButtonStates();
  }
  __name(handlePageUpdate, "handlePageUpdate");
  function init46() {
    chrome.storage.local.get({ PrivateServerBulkEnabled: !0 }, (data) => {
      if (data.PrivateServerBulkEnabled === !0) {
        let wrapHistory = /* @__PURE__ */ __name((type) => {
          let original = history[type];
          return function() {
            let result = original.apply(this, arguments);
            return window.dispatchEvent(new Event(type)), result;
          };
        }, "wrapHistory");
        history.pushState = wrapHistory("pushState"), history.replaceState = wrapHistory("replaceState"), window.addEventListener("popstate", handlePageUpdate), window.addEventListener("hashchange", handlePageUpdate), window.addEventListener("pushState", handlePageUpdate), window.addEventListener("replaceState", handlePageUpdate), observeElement(".container-header", handlePageUpdate), handlePageUpdate();
      }
    });
  }
  __name(init46, "init");

  // src/content/core/fun/confetti.js
  function createConfetti(element, imageUrl) {
    let rect = element.getBoundingClientRect(), confettiContainer = document.createElement("div");
    Object.assign(confettiContainer.style, {
      position: "fixed",
      left: `${rect.left + rect.width / 2}px`,
      top: `${rect.top + rect.height / 2}px`,
      width: "1px",
      height: "1px",
      zIndex: "1000",
      pointerEvents: "none"
    }), document.body.appendChild(confettiContainer);
    for (let i = 0; i < 50; i++) {
      let confetti = document.createElement("img");
      confetti.src = imageUrl, Object.assign(confetti.style, { position: "absolute", width: "15px", height: "15px", opacity: "0" });
      let angle = Math.random() * 2 * Math.PI, distance = Math.random() * 100 + 50, duration = Math.random() * 1500 + 1e3;
      confetti.animate([
        { transform: "translate(-50%, -50%) rotate(0deg)", opacity: 1 },
        { transform: `translate(calc(-50% + ${Math.cos(angle) * distance}px), calc(-50% + ${Math.sin(angle) * distance}px)) rotate(720deg)`, opacity: 0 }
      ], { duration, easing: "ease-out", fill: "forwards" }), confettiContainer.appendChild(confetti);
    }
    setTimeout(() => {
      document.body.contains(confettiContainer) && document.body.removeChild(confettiContainer);
    }, 3e3);
  }
  __name(createConfetti, "createConfetti");

  // src/content/core/configs/userIds.js
  var CREATOR_USER_ID = "447170745", CONTRIBUTOR_USER_IDS = [
    "1337447242",
    "109176680",
    "795922138",
    "8345351117",
    //Zed128
    "546872490",
    //Kanibal02
    "48255812",
    //aliceenight
    "7982684834"
    //qborder
  ], RAT_BADGE_USER_ID = "477516666", BLAHAJ_BADGE_USER_ID = "96786935", CAM_BADGE_USER_ID = "4866259395";

  // src/content/core/configs/badges.js
  var assets = getAssets(), BADGE_CONFIG = {
    creator: {
      type: "header",
      userIds: [CREATOR_USER_ID],
      icon: assets.rovalraIcon,
      tooltip: "Creator of RoValra",
      confetti: assets.rovalraIcon,
      style: {},
      alwaysShow: !0
    },
    contributor: {
      type: "header",
      userIds: CONTRIBUTOR_USER_IDS,
      icon: assets.rovalraIcon,
      tooltip: "RoValra Contributor",
      confetti: assets.rovalraIcon,
      style: { filter: "sepia(80%) saturate(300%) brightness(90%) hue-rotate(-20deg)" }
    },
    gilbert: {
      type: "badge",
      userIds: [CREATOR_USER_ID],
      icon: assets.rovalraIcon,
      name: "Gilbert",
      tooltip: "Creator of RoValra",
      confetti: assets.rovalraIcon,
      alwaysShow: !0
    },
    rat: {
      type: "badge",
      userIds: [RAT_BADGE_USER_ID],
      icon: assets.ratBadgeIcon,
      name: "I make rats",
      tooltip: "I make rats",
      confetti: assets.fishConfetti
    },
    blahaj: {
      type: "badge",
      userIds: [BLAHAJ_BADGE_USER_ID],
      icon: assets.blahaj,
      name: "BLAHAJ :3",
      tooltip: "BLAHAJ :3",
      confetti: assets.blahaj
    },
    cam: {
      type: "header",
      userIds: [CAM_BADGE_USER_ID],
      icon: assets.blahaj,
      name: "BLAHAJ :3",
      tooltip: "BLAHAJ :3",
      confetti: assets.blahaj
    },
    camEasterEgg: {
      type: "badge",
      userIds: [CAM_BADGE_USER_ID],
      icon: assets.blahaj,
      name: "BLAHAJ :3",
      tooltip: "BLAHAJ :3",
      confetti: assets.blahaj
    },
    legacy_donator: {
      type: "header",
      userIds: [],
      icon: assets.rovalraIcon,
      tooltip: "Legacy Donator. Earned by donating to RoValra before donator badges were a thing.",
      confetti: assets.rovalraIcon,
      style: { filter: "sepia(100%) saturate(600%) brightness(90%) hue-rotate(5deg)" }
    },
    donator_1: {
      type: "header",
      userIds: [],
      icon: assets.rovalraIcon,
      tooltip: "Donated any amount of Robux to help Support RoValra's development.",
      url: "https://www.roblox.com/games/store-section/9452973012",
      style: { filter: "sepia(1) saturate(1.8) hue-rotate(-35deg) brightness(0.8) contrast(1.2)" }
    },
    donator_2: {
      type: "header",
      userIds: [],
      icon: assets.rovalraIcon,
      tooltip: "Donated 200 or more Robux to help Support RoValra's development.",
      url: "https://www.roblox.com/games/store-section/9452973012",
      style: { filter: "grayscale(1) brightness(1.3) contrast(1.2)" }
    },
    donator_3: {
      type: "header",
      userIds: [],
      icon: assets.rovalraIcon,
      tooltip: "Donated 500 or more Robux to help Support RoValra's development.",
      url: "https://www.roblox.com/games/store-section/9452973012",
      style: { filter: "sepia(1) saturate(3) hue-rotate(5deg) brightness(1.1)" }
    }
  };

  // src/content/features/profile/header/RoValraBadges.js
  function createHeaderBadge(parentContainer, badge) {
    let iconContainer = document.createElement("div");
    iconContainer.className = "rovalra-header-badge", Object.assign(iconContainer.style, {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      marginLeft: "8px",
      verticalAlign: "middle"
    });
    let icon = document.createElement("img");
    icon.src = badge.icon, Object.assign(icon.style, {
      width: "var(--icon-size-large)",
      height: "var(--icon-size-large)",
      // Just to make it more consistent with Roblox
      cursor: "pointer",
      ...badge.style
    }), badge.confetti && icon.addEventListener("click", () => createConfetti(icon, badge.confetti)), badge.url && icon.addEventListener("click", () => {
      window.location.href = badge.url;
    }), badge.tooltip && addTooltip(iconContainer, badge.tooltip, { position: "bottom" }), parentContainer.appendChild(iconContainer), iconContainer.appendChild(icon);
  }
  __name(createHeaderBadge, "createHeaderBadge");
  function createTextHeaderBadge(parentContainer, badgeName, isHiddenInitially = !1) {
    let badgeElement = document.createElement("span");
    badgeElement.textContent = badgeName.replace(/_/g, " "), badgeElement.className = "rovalra-text-badge";
    let isHidden = isHiddenInitially;
    (/* @__PURE__ */ __name(() => {
      isHidden ? (Object.assign(badgeElement.style, {
        backgroundColor: "var(--surface-neutral-tertiary)",
        color: "var(--text-muted)",
        padding: "2px 8px",
        borderRadius: "12px",
        fontSize: "12px",
        fontWeight: "500",
        marginLeft: "8px",
        verticalAlign: "middle",
        cursor: "default",
        textTransform: "capitalize",
        opacity: "0.6",
        border: "1px dashed var(--text-muted)"
      }), addTooltip(badgeElement, "This badge is hidden. Manage in settings.", { position: "bottom" })) : Object.assign(badgeElement.style, {
        backgroundColor: "var(--surface-neutral-tertiary)",
        color: "var(--text-default)",
        padding: "2px 8px",
        borderRadius: "12px",
        fontSize: "12px",
        fontWeight: "500",
        marginLeft: "8px",
        verticalAlign: "middle",
        cursor: "default",
        textTransform: "capitalize",
        opacity: "1",
        border: "none"
      });
    }, "applyVisualState"))(), parentContainer.appendChild(badgeElement);
  }
  __name(createTextHeaderBadge, "createTextHeaderBadge");
  function createRain(imageUrl) {
    let container = document.createElement("div");
    container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: none;
        z-index: 100000;
        overflow: hidden;
    `, document.body.appendChild(container);
    let interval = setInterval(() => {
      let drop = document.createElement("img");
      drop.src = imageUrl;
      let size = Math.random() * 500 + 50, startLeft = Math.random() * 100, duration = Math.random() * 2 + 2;
      drop.style.cssText = `
            position: absolute;
            top: -100px;
            left: ${startLeft}vw;
            width: ${size}px;
            height: auto;
            transition: top ${duration}s linear, transform ${duration}s linear;
        `, container.appendChild(drop), drop.offsetWidth, drop.style.top = "110vh", drop.style.transform = `rotate(${Math.random() * 360}deg)`, setTimeout(() => {
        drop.remove();
      }, duration * 1e3);
    }, 50);
    setTimeout(() => {
      clearInterval(interval), setTimeout(() => {
        container.remove();
      }, 5e3);
    }, 1e4);
  }
  __name(createRain, "createRain");
  async function addHeaderBadges(nameContainer) {
    if (nameContainer.dataset.rovalraHeaderObserverAttached) return;
    nameContainer.dataset.rovalraHeaderObserverAttached = "true";
    let parentContainer = nameContainer.parentElement;
    if (!parentContainer) return;
    let uniqueId = `rovalra-badges-${Date.now()}-${Math.random()}`;
    nameContainer.dataset.rovalraId = uniqueId;
    let reapplyBadges = /* @__PURE__ */ __name(async () => {
      parentContainer.querySelectorAll(".rovalra-header-badge, .rovalra-text-badge").forEach((badge) => badge.remove());
      let currentUserId = getUserIdFromUrl();
      if (currentUserId) {
        for (let key in BADGE_CONFIG) {
          let badge = BADGE_CONFIG[key];
          badge.type === "header" && badge.userIds.includes(currentUserId) && createHeaderBadge(nameContainer, badge);
        }
        try {
          let apiBadgesData = await callRobloxApiJson({
            isRovalraApi: !0,
            subdomain: "apis",
            endpoint: `/v1/users/${currentUserId}/badges`,
            method: "GET"
          });
          apiBadgesData && apiBadgesData.status === "success" && Array.isArray(apiBadgesData.badges) && apiBadgesData.badges.forEach((badgeName) => {
            BADGE_CONFIG[badgeName] ? createHeaderBadge(nameContainer, BADGE_CONFIG[badgeName]) : createTextHeaderBadge(nameContainer, badgeName, !1);
          });
        } catch {
        }
      }
    }, "reapplyBadges");
    await reapplyBadges(), observeElement(`[data-rovalra-id="${uniqueId}"] .rovalra-header-badge, [data-rovalra-id="${uniqueId}"] .rovalra-text-badge`, () => {
    }, {
      onRemove: /* @__PURE__ */ __name(() => {
        !nameContainer.querySelector(".rovalra-header-badge") && !nameContainer.querySelector(".rovalra-text-badge") && reapplyBadges();
      }, "onRemove")
    });
  }
  __name(addHeaderBadges, "addHeaderBadges");
  async function addProfileBadgeButtons(buttonContainer) {
    if (buttonContainer.dataset.rovalraProfileBadgesProcessed) return;
    buttonContainer.dataset.rovalraProfileBadgesProcessed = "true";
    let currentUserId = getUserIdFromUrl();
    if (!currentUserId) return;
    let settings = await new Promise((resolve) => chrome.storage.local.get({ ShowBadgesEverywhere: !1 }, resolve));
    for (let key in BADGE_CONFIG) {
      let badge = BADGE_CONFIG[key];
      if (badge.type === "badge" && (badge.alwaysShow || settings.ShowBadgesEverywhere || badge.userIds.includes(currentUserId)) && badge.userIds.includes(currentUserId)) {
        let badgeButton = createSquareButton({
          content: "\u{1F95A}",
          fontSize: "14px",
          width: "auto",
          height: "height-1000",
          paddingX: "padding-x-small",
          disableTextTruncation: !0,
          onClick: /* @__PURE__ */ __name((event) => {
            badge.confetti && (createConfetti(event.currentTarget, badge.confetti), createRain(badge.icon));
          }, "onClick")
        });
        badge.tooltip && addTooltip(badgeButton, badge.tooltip), badgeButton.style.marginRight = "5px", buttonContainer.prepend(badgeButton);
      }
    }
  }
  __name(addProfileBadgeButtons, "addProfileBadgeButtons");
  function init47() {
    chrome.storage.local.get({ RoValraBadgesEnable: !0 }, (settings) => {
      settings.RoValraBadgesEnable && (observeElement("#profile-header-title-container-name", addHeaderBadges), observeElement(".profile-header-title-container", addHeaderBadges), observeElement(".flex.gap-small.buttons-show-on-desktop", addProfileBadgeButtons, { multiple: !0 }));
    });
  }
  __name(init47, "init");

  // src/content/features/profile/hiddengames.js
  var CONFIG = {
    PAGE_SIZE: 50,
    ACCESS_FILTER: 2,
    RETRY: {
      MAX_ATTEMPTS: 5,
      DELAY_MS: 3e3
    }
  }, ENDPOINTS = {
    INVENTORY_CHECK: /* @__PURE__ */ __name((userId) => `/v1/users/${userId}/can-view-inventory`, "INVENTORY_CHECK"),
    INVENTORY_GAMES: /* @__PURE__ */ __name((userId, cursor = "") => `/v1/users/${userId}/places/inventory?cursor=${cursor}&itemsPerPage=100&placesTab=Created`, "INVENTORY_GAMES"),
    GAMES_V2: /* @__PURE__ */ __name((userId, cursor = "") => `/v2/users/${userId}/games?accessFilter=${CONFIG.ACCESS_FILTER}&limit=50&sortOrder=Asc&cursor=${cursor}`, "GAMES_V2"),
    VOTES_V1: /* @__PURE__ */ __name((ids) => `/v1/games/votes?universeIds=${ids}`, "VOTES_V1"),
    GAMES_V1: /* @__PURE__ */ __name((ids) => `/v1/games?universeIds=${ids}`, "GAMES_V1"),
    GAME_LINK: /* @__PURE__ */ __name((placeId) => `https://www.roblox.com/games/${placeId}/unnamed`, "GAME_LINK")
    // adding an extra parameter after placeid adds support for btroblox's copy placeid context menu item
  }, userListCache = /* @__PURE__ */ new Map(), sharedStatsCache2 = {
    likes: /* @__PURE__ */ new Map(),
    players: /* @__PURE__ */ new Map(),
    updated: /* @__PURE__ */ new Map(),
    thumbnails: /* @__PURE__ */ new Map()
  }, Api = {
    async fetchWithRetry(options) {
      let delay = CONFIG.RETRY.DELAY_MS;
      for (let i = 0; i <= CONFIG.RETRY.MAX_ATTEMPTS; i++)
        try {
          let response = await callRobloxApi(options);
          if (response.status === 429) {
            if (i === CONFIG.RETRY.MAX_ATTEMPTS)
              throw new Error("Rate limit exceeded");
            await new Promise((r) => setTimeout(r, delay)), delay *= 2;
            continue;
          }
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          return response;
        } catch {
          if (i >= CONFIG.RETRY.MAX_ATTEMPTS) return null;
          await new Promise((r) => setTimeout(r, delay)), delay *= 2;
        }
      return null;
    },
    async checkInventoryPublic(userId) {
      let res = await this.fetchWithRetry({
        subdomain: "inventory",
        endpoint: ENDPOINTS.INVENTORY_CHECK(userId)
      });
      return (res ? await res.json().catch(() => null) : null)?.canView === !0;
    },
    async getGamesFromInventory(userId) {
      let games = [], nextCursor = "";
      do {
        let res = await this.fetchWithRetry({
          subdomain: "inventory",
          endpoint: ENDPOINTS.INVENTORY_GAMES(userId, nextCursor)
        }), data = res ? await res.json().catch(() => null) : null;
        if (data?.data) {
          let formattedGames = data.data.filter((item) => item.universeId != null).map((item) => ({
            id: item.universeId,
            name: item.name,
            rootPlaceId: item.placeId
          }));
          games = games.concat(formattedGames), nextCursor = data.nextPageCursor;
        } else
          nextCursor = null;
      } while (nextCursor);
      return games;
    },
    async getGamesFromV2(userId) {
      let games = [], nextCursor = null;
      do {
        let endpoint = ENDPOINTS.GAMES_V2(userId, nextCursor || ""), res = await this.fetchWithRetry({
          subdomain: "games",
          endpoint
        }), data = res ? await res.json().catch(() => null) : null;
        data?.data ? (games = games.concat(data.data), nextCursor = data.nextPageCursor) : nextCursor = null;
      } while (nextCursor);
      return games;
    },
    async getUserGames(userId) {
      if (userListCache.has(userId))
        return userListCache.get(userId).catch((err) => (console.error(err), []));
      let fetchPromise = (async () => await this.checkInventoryPublic(userId) ? await this.getGamesFromInventory(userId) : await this.getGamesFromV2(userId))();
      return userListCache.set(userId, fetchPromise), fetchPromise.catch(() => userListCache.delete(userId)), fetchPromise.catch((err) => (console.error(err), []));
    },
    async enrichGameData(games, state3) {
      let batch = games.filter((g2) => g2 && !state3.likes.has(g2.id));
      if (!batch.length) return;
      let playerResList = [], voteResList = [];
      for (let i = 0; i < batch.length; i += 50) {
        let chunkIds = batch.slice(i, i + 50).map((g2) => g2.id).join(",");
        i > 0 && await new Promise((r) => setTimeout(r, 250));
        let [gamesRes, votesRes] = await Promise.all([
          this.fetchWithRetry({
            subdomain: "games",
            endpoint: ENDPOINTS.GAMES_V1(chunkIds)
          }).then((r) => r?.json()),
          this.fetchWithRetry({
            subdomain: "games",
            endpoint: ENDPOINTS.VOTES_V1(chunkIds)
          }).then((r) => r?.json())
        ]);
        playerResList.push(gamesRes), voteResList.push(votesRes);
      }
      voteResList.forEach((likeRes) => {
        likeRes?.data && likeRes.data.forEach((item) => {
          let total = item.upVotes + item.downVotes, ratio = total > 0 ? Math.round(item.upVotes / total * 100) : 0;
          state3.likes.set(item.id, {
            ratio,
            total,
            upVotes: item.upVotes,
            downVotes: item.downVotes
          });
        });
      }), playerResList.forEach((playerRes) => {
        playerRes?.data && playerRes.data.forEach((item) => {
          state3.players.set(item.id, item.playing || 0), state3.updated.set(item.id, item.updated || 0);
        });
      }), (await fetchThumbnails(
        batch,
        "GameIcon",
        "256x256"
      )).forEach((data, id) => state3.thumbnails.set(id, data));
    }
  }, UI = {
    createFilterPanel(onFilterChange2) {
      let container = document.createElement("div");
      container.className = "rovalra-filters-container";
      let createFilterSection = /* @__PURE__ */ __name((label, element) => {
        let div = document.createElement("div");
        return div.className = "rovalra-filter-section", div.innerHTML = safeHtml`<label>${label}</label>`, div.appendChild(element), div;
      }, "createFilterSection"), sortDropdown = createDropdown({
        items: [
          { value: "default", label: "Default" },
          { value: "like-ratio", label: "Like Ratio" },
          { value: "likes", label: "Likes" },
          { value: "dislikes", label: "Dislikes" },
          { value: "players", label: "Players" },
          { value: "name", label: "Name (Z-A)" }
        ],
        initialValue: "default",
        onValueChange: /* @__PURE__ */ __name((v2) => onFilterChange2("sort", v2), "onValueChange")
      }), orderDropdown = createDropdown({
        items: [
          { value: "desc", label: "Descending" },
          { value: "asc", label: "Ascending" }
        ],
        initialValue: "desc",
        onValueChange: /* @__PURE__ */ __name((v2) => onFilterChange2("order", v2), "onValueChange")
      });
      return container.append(
        createFilterSection("Sort", sortDropdown.element),
        createFilterSection("Order", orderDropdown.element)
      ), container;
    },
    injectButton(header, onClick2) {
      if (!header || header.querySelector(".hidden-games-button") || header.querySelector("social-link-icon-list") || header.querySelector("h2")) return;
      let btn = createButton("Hidden Experiences", "secondary");
      btn.classList.add("hidden-games-button"), btn.style.marginLeft = "5px", btn.addEventListener("click", onClick2), header.appendChild(btn);
    },
    createEmptyState(onClick2) {
      let container = document.createElement("div");
      container.className = "rovalra-empty-state section";
      let text2 = document.createElement("p");
      text2.className = "text-label", text2.textContent = "User has no public experiences";
      let btn = createButton("Hidden Experiences", "secondary");
      return btn.classList.add("hidden-games-button"), btn.addEventListener("click", onClick2), container.append(text2, btn), container;
    }
  }, HiddenGamesManager2 = class {
    static {
      __name(this, "HiddenGamesManager");
    }
    constructor(allGames) {
      this.allGames = allGames, this.cache = sharedStatsCache2, this.filters = { sort: "default", order: "desc" }, this.processedGames = [], this.visibleCount = 0, this.isLoading = !1, this.elements = {};
    }
    openOverlay() {
      let body = document.createElement("div"), filterPanel = UI.createFilterPanel(
        this.handleFilterChange.bind(this)
      ), list = document.createElement("div");
      list.className = "hidden-games-list", list.classList.add("rovalra-hidden-games-list");
      let loader = document.createElement("div");
      loader.className = "rovalra-load-more-container", body.append(filterPanel, list, loader), this.elements = { list, loader, filterPanel };
      let { overlay } = createOverlay({
        title: "Hidden Experiences (Might show not hidden experiences)",
        bodyContent: body,
        maxWidth: "1200px",
        maxHeight: "85vh"
      });
      if (this.allGames.length === 0) {
        this.elements.list.innerHTML = '<p class="no-hidden-games-message">This user has no hidden experiences.</p>', this.elements.filterPanel.style.display = "none";
        return;
      }
      let scrollContainer = overlay.querySelector(".rovalra-overlay-body");
      scrollContainer && scrollContainer.addEventListener("scroll", () => {
        let { scrollTop, clientHeight, scrollHeight } = scrollContainer;
        scrollTop + clientHeight >= scrollHeight - 150 && this.loadMore();
      }), this.applyFilters();
    }
    handleFilterChange(key, value) {
      this.filters[key] = value, this.applyFilters();
    }
    async applyFilters() {
      if (this.isLoading) return;
      this.isLoading = !0, this.elements.list.innerHTML = "", this.elements.list.appendChild(
        createShimmerGrid(12, { width: "150px", height: "240px" })
      ), this.visibleCount = 0, ["default", "like-ratio", "likes", "dislikes", "players"].includes(
        this.filters.sort
      ) && await Api.enrichGameData(this.allGames, this.cache);
      let { sort, order } = this.filters, orderMultiplier = order === "desc" ? -1 : 1, sorted = [...this.allGames];
      sort === "default" ? sorted.sort(
        (a, b2) => (new Date(this.cache.updated.get(a.id) || 0) - new Date(this.cache.updated.get(b2.id) || 0)) * orderMultiplier
      ) : sort === "like-ratio" ? sorted.sort(
        (a, b2) => ((this.cache.likes.get(a.id)?.ratio || 0) - (this.cache.likes.get(b2.id)?.ratio || 0)) * orderMultiplier
      ) : sort === "likes" ? sorted.sort(
        (a, b2) => ((this.cache.likes.get(a.id)?.upVotes || 0) - (this.cache.likes.get(b2.id)?.upVotes || 0)) * orderMultiplier
      ) : sort === "dislikes" ? sorted.sort(
        (a, b2) => ((this.cache.likes.get(a.id)?.downVotes || 0) - (this.cache.likes.get(b2.id)?.downVotes || 0)) * orderMultiplier
      ) : sort === "players" ? sorted.sort(
        (a, b2) => ((this.cache.players.get(a.id) || 0) - (this.cache.players.get(b2.id) || 0)) * orderMultiplier
      ) : sort === "name" ? sorted.sort(
        (a, b2) => a.name.localeCompare(b2.name) * orderMultiplier
      ) : order === "asc" && sorted.reverse(), this.processedGames = sorted, this.isLoading = !1, this.elements.list.innerHTML = "", this.processedGames.length === 0 ? this.elements.list.innerHTML = '<p class="no-hidden-games-message">No experiences match filters.</p>' : await this.loadMore();
    }
    async loadMore() {
      if (!(this.visibleCount >= this.processedGames.length || this.elements.loader.innerHTML !== "")) {
        this.elements.loader.innerHTML = '<p class="rovalra-loading-text">Loading...</p>';
        try {
          let nextBatch = this.processedGames.slice(
            this.visibleCount,
            this.visibleCount + CONFIG.PAGE_SIZE
          );
          nextBatch.length > 0 && (await Api.enrichGameData(nextBatch, this.cache), nextBatch.forEach((game) => {
            this.elements.list.appendChild(
              createGameCard({ game, stats: this.cache })
            );
          }), this.visibleCount += nextBatch.length);
        } catch (err) {
          console.warn("RoValra: Error loading more games", err);
        } finally {
          this.elements.loader.innerHTML = "";
        }
      }
    }
  };
  function getUserId() {
    let match = window.location.href.match(/users\/(\d+)\/profile/);
    return match ? match[1] : null;
  }
  __name(getUserId, "getUserId");
  function init48() {
    chrome.storage.local.get(["userGamesEnabled"], (result) => {
      if (result.userGamesEnabled !== !0) return;
      let userId = getUserId();
      if (!userId) return;
      let handleButtonClick = /* @__PURE__ */ __name(async () => {
        let games = await Api.getUserGames(userId);
        new HiddenGamesManager2(games).openOverlay();
      }, "handleButtonClick");
      observeElement(
        ".btr-profile-right .profile-game .container-header, .profile-tab-content .container-header, .placeholder-games .container-header",
        (header) => {
          UI.injectButton(header, handleButtonClick);
        }
      );
      let checkEmptyState = /* @__PURE__ */ __name(() => {
        if (!window.location.hash.includes("#creations")) return;
        document.querySelectorAll(".profile-tab-content").forEach((content) => {
          if (!content.classList.contains("ng-hide") && content.children.length === 1) {
            let inner = content.children[0];
            if (inner.tagName === "DIV" && inner.children.length === 0 && inner.textContent.trim() === "") {
              if (content.querySelector(".rovalra-empty-state")) return;
              content.innerHTML = "", content.appendChild(UI.createEmptyState(handleButtonClick));
            }
          }
        });
      }, "checkEmptyState");
      window.addEventListener("hashchange", checkEmptyState), observeElement(".profile-tab-content", checkEmptyState);
    });
  }
  __name(init48, "init");

  // src/content/features/games/privateserver.js
  var privateServerContext = {
    serverLocations: {},
    serverUptimes: {},
    serverPerformanceCache: {},
    vipStatusCache: {},
    uptimeBatch: /* @__PURE__ */ new Set(),
    serverIpMap: {},
    processUptimeBatch: /* @__PURE__ */ __name(async () => {
    }, "processUptimeBatch")
  };
  async function init49() {
    let userId = await getAuthenticatedUserId();
    if (userId) {
      try {
        await loadDatacenterMap();
        let result = await new Promise((resolve) => chrome.storage.local.get("rovalraDatacenters", resolve));
        result?.rovalraDatacenters && result.rovalraDatacenters.forEach((dc) => {
          dc.location && dc.dataCenterIds && dc.dataCenterIds.forEach((id) => privateServerContext.serverIpMap[id] = dc.location);
        });
      } catch {
      }
      chrome.storage.local.get({ PrivateQuickLinkCopy: !0, ServerlistmodificationsEnabled: !0 }, (settings) => {
        let enableControls = settings.PrivateQuickLinkCopy, enableDetails = settings.ServerlistmodificationsEnabled;
        observeElement(".rbx-private-game-server-item", (serverItem) => {
          if (serverItem.dataset.rovalraPrivateEnhanced) return;
          serverItem.dataset.rovalraPrivateEnhanced = "true";
          let detailsDiv = serverItem.querySelector(".rbx-private-game-server-details"), ownerLink = serverItem.querySelector(".rbx-private-owner .avatar-card-fullbody");
          if (!ownerLink) return;
          enableDetails && enhanceServer(serverItem, privateServerContext);
          let href = ownerLink.getAttribute("href");
          if (!href) return;
          let match = href.match(/users\/(\d+)\/profile/);
          if (!match) return;
          if (parseInt(match[1], 10) === userId && enableControls)
            if (serverItem.dataset.privateServerId)
              addOwnerControls(serverItem, serverItem.dataset.privateServerId);
            else {
              let observer = observeAttributes(serverItem, () => {
                serverItem.dataset.privateServerId && (observer.disconnect(), addOwnerControls(serverItem, serverItem.dataset.privateServerId));
              }, ["data-private-server-id"]);
            }
        }, { multiple: !0 });
      });
    }
  }
  __name(init49, "init");
  async function addOwnerControls(serverItem, privateServerId) {
    let detailsDiv = serverItem.querySelector(".rbx-private-game-server-details");
    if (!detailsDiv || detailsDiv.querySelector(".rovalra-private-server-controls") || serverItem.querySelector(".rbx-private-game-server-copy-link") || serverItem.querySelector(".rbx-private-game-server-regenerate-link")) return;
    let initialData = null;
    try {
      let res = await callRobloxApi({
        subdomain: "games",
        endpoint: `/v1/vip-servers/${privateServerId}`,
        method: "GET"
      });
      res.ok && (initialData = await res.json());
    } catch (e) {
      console.warn(e);
    }
    if (initialData?.subscription?.expired) return;
    let container = document.createElement("div");
    container.className = "rovalra-private-server-controls", container.style.marginTop = "5px", container.style.display = "flex", container.style.gap = "5px";
    let copyLinkBtn = createButton("Copy Link", "secondary");
    copyLinkBtn.classList.add("btn-control-xs"), copyLinkBtn.style.flex = "1", copyLinkBtn.style.fontSize = "11px", copyLinkBtn.style.minWidth = "0";
    let generateLinkBtn = createButton("Regenerate Link", "secondary");
    generateLinkBtn.classList.add("btn-control-xs"), generateLinkBtn.style.flex = "1", generateLinkBtn.style.fontSize = "11px", generateLinkBtn.style.minWidth = "0", container.appendChild(copyLinkBtn), container.appendChild(generateLinkBtn);
    let joinBtnSpan = detailsDiv.querySelector("span[data-placeid]");
    joinBtnSpan ? joinBtnSpan.after(container) : detailsDiv.appendChild(container), initialData && (copyLinkBtn.disabled = !initialData.link, initialData.active === !1 && (generateLinkBtn.disabled = !0));
    let checkLink = /* @__PURE__ */ __name(async () => {
      try {
        let res = await callRobloxApi({
          subdomain: "games",
          endpoint: `/v1/vip-servers/${privateServerId}`,
          method: "GET"
        });
        if (res.ok) {
          let data = await res.json();
          return copyLinkBtn.disabled = !data.link, data.active === !1 && (generateLinkBtn.disabled = !0), data.link;
        }
      } catch (e) {
        console.warn(e);
      }
      return null;
    }, "checkLink");
    copyLinkBtn.onclick = async () => {
      if (copyLinkBtn.disabled) return;
      let originalText = copyLinkBtn.textContent, link = await checkLink();
      link ? (navigator.clipboard.writeText(link), copyLinkBtn.textContent = "Copied!") : copyLinkBtn.textContent = "Error", setTimeout(() => copyLinkBtn.textContent = originalText, 1500);
    }, generateLinkBtn.onclick = async () => {
      let originalText = generateLinkBtn.textContent;
      generateLinkBtn.disabled = !0;
      try {
        (await callRobloxApi({
          subdomain: "games",
          endpoint: `/v1/vip-servers/${privateServerId}`,
          method: "PATCH",
          body: { newJoinCode: !0 }
        })).ok ? (generateLinkBtn.textContent = "Regenerated!", copyLinkBtn.disabled = !1) : generateLinkBtn.textContent = "Error";
      } catch {
        generateLinkBtn.textContent = "Error";
      }
      setTimeout(() => {
        generateLinkBtn.textContent = originalText, generateLinkBtn.disabled = !1;
      }, 1500);
    };
  }
  __name(addOwnerControls, "addOwnerControls");

  // src/content/features/sitewide/PreviousPrice.js
  var itemPrices = /* @__PURE__ */ new Map(), itemIsOffSale = /* @__PURE__ */ new Map(), pendingCards = /* @__PURE__ */ new Map(), listenersAttached = !1;
  function addPriceIconToCard(card, assetId) {
    let price = itemPrices.get(assetId);
    if (itemIsOffSale.get(assetId) && price !== void 0 && price > 1) {
      if (card.matches(".price-container-text")) {
        addTextPrice(card, price);
        return;
      }
      let container;
      if (container = card.querySelector(".text-overflow.item-card-price, .rovalra-item-rap"), !container) {
        let caption = card.querySelector(".item-card-caption");
        if (caption) {
          let newContainer = document.createElement("div");
          newContainer.className = "text-overflow item-card-price font-header-2 text-subheader margin-top-none";
          let offSaleSpan = document.createElement("span");
          offSaleSpan.className = "text text-label text-robux-tile", offSaleSpan.textContent = "Off Sale", newContainer.appendChild(offSaleSpan), caption.appendChild(newContainer), container = newContainer;
        }
      }
      container && !container.querySelector(".rovalra-offsale-price-icon") && addIcon(container, price);
    }
  }
  __name(addPriceIconToCard, "addPriceIconToCard");
  function init50() {
    chrome.storage.local.get("PreviousPriceEnabled", (result) => {
      result.PreviousPriceEnabled === !0 && (listenersAttached || (listenersAttached = !0, window.addEventListener("rovalra-catalog-details", async (e) => {
        let data = e.detail;
        if (!data || !data.data || !Array.isArray(data.data))
          return;
        let updatedAssetIds = /* @__PURE__ */ new Set();
        data.data.forEach((item) => {
          item.id && (itemPrices.set(item.id, item.price), itemIsOffSale.set(item.id, item.isOffSale || item.priceStatus === "Off Sale"), updatedAssetIds.add(item.id));
        });
        let assetsToCheck = [], pageId = getPlaceIdFromUrl();
        if (data.data.forEach((item) => {
          let isOffSale = itemIsOffSale.get(item.id), price = itemPrices.get(item.id);
          isOffSale && price == null && item.itemType !== "Bundle" && !(window.location.pathname.includes("/bundles/") && item.id == pageId) && assetsToCheck.push({ id: item.id });
        }), assetsToCheck.length > 0)
          try {
            let purchaseRes = await callRobloxApi({
              subdomain: "apis",
              endpoint: "/look-api/v1/looks/purchase-details",
              method: "POST",
              body: {
                assets: assetsToCheck
              }
            });
            if (purchaseRes.ok) {
              let purchaseData = await purchaseRes.json(), bundleIds = /* @__PURE__ */ new Set(), assetToBundle = /* @__PURE__ */ new Map();
              if (purchaseData.look && purchaseData.look.items && purchaseData.look.items.forEach((item) => {
                item.itemType === "Bundle" && (bundleIds.add(item.id), item.assetsInBundle && item.assetsInBundle.forEach((asset) => {
                  assetToBundle.set(asset.id, item.id);
                }));
              }), bundleIds.size > 0) {
                let bundleDetailsRes = await callRobloxApi({
                  subdomain: "catalog",
                  endpoint: "/v1/catalog/items/details",
                  method: "POST",
                  body: {
                    items: Array.from(bundleIds).map((id) => ({ itemType: "Bundle", id }))
                  }
                });
                if (bundleDetailsRes.ok) {
                  let bundleDetails = await bundleDetailsRes.json();
                  bundleDetails.data && bundleDetails.data.forEach((bundle) => {
                    (bundle.isOffSale || bundle.priceStatus === "Off Sale") && bundle.price !== void 0 && (assetToBundle.forEach((bId, assetId) => {
                      bId === bundle.id && (itemIsOffSale.set(assetId, !0), itemPrices.set(assetId, bundle.price), updatedAssetIds.add(assetId));
                    }), itemPrices.has(bundle.id) && (itemIsOffSale.set(bundle.id, !0), itemPrices.set(bundle.id, bundle.price), updatedAssetIds.add(bundle.id)));
                  });
                }
              }
            }
          } catch {
          }
        updatedAssetIds.forEach((assetId) => {
          pendingCards.has(assetId) && (pendingCards.get(assetId).forEach((card) => {
            addPriceIconToCard(card, assetId);
          }), pendingCards.delete(assetId));
        });
      }), observeElement("#collection-carousel-item .item-card", (card) => {
        handleItemCard(card);
      }, { multiple: !0 }), observeElement(".roseal-currently-wearing .item-card", (card) => {
        handleItemCard(card);
      }, { multiple: !0 }), observeElement(".rovalra-item-card", (card) => {
        handleItemCard(card);
      }, { multiple: !0 }), observeElement(".price-container-text", (container) => {
        handleOffsalePriceContainer(container);
      }, { multiple: !0 })));
    });
  }
  __name(init50, "init");
  function handleItemCard(card) {
    if (!card.isConnected) return;
    let link = card.querySelector(".item-card-link") || card.querySelector(".rovalra-item-card-link");
    if (!link) return;
    let match = link.getAttribute("href").match(/\/catalog\/(\d+)\//);
    if (!match) return;
    let assetId = parseInt(match[1]), priceLabelContainer = card.querySelector(".text-overflow.item-card-price, .rovalra-item-rap"), shouldProcess = !1;
    if (!priceLabelContainer)
      shouldProcess = !0;
    else {
      let textContent = priceLabelContainer.textContent.trim().toLowerCase();
      (!priceLabelContainer.querySelector(".icon-robux-tile") || textContent.includes("off sale") || textContent.includes("offsale")) && (shouldProcess = !0);
    }
    shouldProcess && (itemPrices.has(assetId) && addPriceIconToCard(card, assetId), card.querySelector(".rovalra-offsale-price-icon") || (pendingCards.has(assetId) || pendingCards.set(assetId, []), pendingCards.get(assetId).includes(card) || pendingCards.get(assetId).push(card)));
  }
  __name(handleItemCard, "handleItemCard");
  function handleOffsalePriceContainer(container) {
    if (container.dataset.rovalraPreviousPrice) return;
    container.dataset.rovalraPreviousPrice = "true";
    let assetId = getPlaceIdFromUrl();
    if (!assetId) return;
    let numericAssetId = parseInt(assetId);
    if (itemPrices.has(numericAssetId))
      addPriceIconToCard(container, numericAssetId);
    else {
      pendingCards.has(numericAssetId) || pendingCards.set(numericAssetId, []);
      let pendingForAsset = pendingCards.get(numericAssetId);
      pendingForAsset.includes(container) || pendingForAsset.push(container);
    }
  }
  __name(handleOffsalePriceContainer, "handleOffsalePriceContainer");
  function addIcon(container, price) {
    if (container.querySelector(".rovalra-offsale-price-icon")) return;
    let assets3 = getAssets(), icon = document.createElement("div");
    icon.className = "rovalra-offsale-price-icon", Object.assign(icon.style, {
      width: "16px",
      height: "16px",
      marginLeft: "4px",
      verticalAlign: "text-bottom",
      cursor: "help",
      display: "inline-block",
      backgroundColor: "var(--rovalra-secondary-text-color)",
      webkitMask: `url("${assets3.priceFloorIcon}") no-repeat center / contain`,
      mask: `url("${assets3.priceFloorIcon}") no-repeat center / contain`
    }), addTooltip(icon, `Previous Price: <span class="icon-robux-16x16" style="vertical-align: middle; margin: 0 2px;"></span>${price.toLocaleString()}`), container.appendChild(icon);
  }
  __name(addIcon, "addIcon");
  function addTextPrice(container, price) {
    if (container.querySelector(".rovalra-previous-price-text")) return;
    let div = document.createElement("div");
    div.className = "rovalra-previous-price-text", div.style.marginTop = "5px", div.style.fontSize = "12px", div.style.color = "var(--rovalra-secondary-text-color)", div.innerHTML = `Previous Price: <span class="icon-robux-16x16" style="vertical-align: middle; margin: 0 2px;"></span>${price.toLocaleString()}`, container.appendChild(div);
  }
  __name(addTextPrice, "addTextPrice");

  // src/content/features/profile/categorizeWearing.js
  var totalPrice2 = 0, processedBundleIds = /* @__PURE__ */ new Set(), totalPriceElement = null;
  function debounce2(func, wait) {
    let timeout;
    return /* @__PURE__ */ __name(function(...args) {
      let later = /* @__PURE__ */ __name(() => {
        clearTimeout(timeout), func(...args);
      }, "later");
      clearTimeout(timeout), timeout = setTimeout(later, wait);
    }, "executedFunction");
  }
  __name(debounce2, "debounce");
  var CONSTANT_IDS = {
    ANIMATIONS: [48, 50, 51, 52, 53, 54, 55],
    EMOTES: [61],
    BODY_PARTS: [17, 27, 28, 29, 30, 31, 78, 79]
  }, ASSET_TYPE_IDS = {
    WEARABLES: /* @__PURE__ */ new Set(),
    EMOTES: new Set(CONSTANT_IDS.EMOTES),
    ANIMATIONS: new Set(CONSTANT_IDS.ANIMATIONS),
    BODY_PARTS: new Set(CONSTANT_IDS.BODY_PARTS)
  }, accessoriesGrid = null, emotesGrid = null, animationsGrid = null, bodyPartsGrid = null, currentFilter = "Items", discoveredCategories = /* @__PURE__ */ new Set(), pillToggleWrapper = null, isBodyPartsCategoryEnabled = !0, isAnimationsCategoryEnabled = !0, isEmotesCategoryEnabled = !0;
  async function loadAssetTypeIds() {
    try {
      (await getAllCategories()).forEach((cat) => {
        let catName = (cat.category || cat.name || "").replace(/\s+/g, "").toLowerCase();
        catName.includes("animation") && (cat.subcategories && cat.subcategories.forEach((sub) => {
          sub.subcategory.toLowerCase().includes("emote") ? sub.assetTypeIds?.forEach((id) => ASSET_TYPE_IDS.EMOTES.add(id)) : sub.assetTypeIds?.forEach((id) => ASSET_TYPE_IDS.ANIMATIONS.add(id));
        }), cat.assetTypeIds?.forEach((id) => ASSET_TYPE_IDS.ANIMATIONS.add(id))), ["accessories", "clothing", "classicclothing", "bundles"].some((n) => catName.includes(n)) && (cat.assetTypeIds?.forEach((id) => ASSET_TYPE_IDS.WEARABLES.add(id)), cat.subcategories?.forEach((sub) => {
          sub.assetTypeIds?.forEach((id) => ASSET_TYPE_IDS.WEARABLES.add(id));
        }));
      });
    } catch (e) {
      console.error("RoValra: Failed to load dynamic asset type IDs", e);
    }
  }
  __name(loadAssetTypeIds, "loadAssetTypeIds");
  var assetInfoCache = /* @__PURE__ */ new Map(), pendingItems = /* @__PURE__ */ new Map();
  function updateTotalDisplay() {
    totalPriceElement || (totalPriceElement = document.getElementById("rovalra-wearing-total-price")), totalPriceElement && (totalPrice2 > 0 ? totalPriceElement.innerHTML = safeHtml`
                <span class="icon-robux-16x16" style="vertical-align: middle; margin: 0 4px 0 8px;"></span>
                <span style="font-weight: 600;">${totalPrice2.toLocaleString()}</span>
            ` : totalPriceElement.innerHTML = "");
  }
  __name(updateTotalDisplay, "updateTotalDisplay");
  function recalculateTotalPrice() {
    totalPrice2 = 0, processedBundleIds.clear(), document.querySelectorAll(".rovalra-category-grid .rovalra-item-card").forEach((card) => {
      if (card.classList.contains("shimmer")) return;
      let link = card.querySelector("a.rovalra-item-card-link");
      if (!link) return;
      let match = link.href.match(/\/(catalog|bundles)\/(\d+)\//);
      if (!match) return;
      let assetId = parseInt(match[2]), info = assetInfoCache.get(assetId);
      if (!info || !info.assetType || !info.assetType.id || ASSET_TYPE_IDS.EMOTES.has(info.assetType.id))
        return;
      let price = parseFloat(card.dataset.rovalraPrice);
      if (isNaN(price) || price === 0)
        return;
      let bundleId = card.dataset.rovalraBundleId, isBundle = link.href.includes("/bundles/");
      bundleId ? processedBundleIds.has(bundleId) || (totalPrice2 += price, processedBundleIds.add(bundleId)) : totalPrice2 += price;
    }), updateTotalDisplay();
  }
  __name(recalculateTotalPrice, "recalculateTotalPrice");
  function updateScrollButtonStates(container, leftBtn, rightBtn) {
    if (!container || !leftBtn || !rightBtn) return;
    let { scrollLeft, scrollWidth, clientWidth } = container, isScrollable = scrollWidth > clientWidth + 5;
    leftBtn.style.display = isScrollable ? "flex" : "none", rightBtn.style.display = isScrollable ? "flex" : "none", leftBtn.classList.toggle("rovalra-btn-disabled", scrollLeft <= 5);
    let isAtEnd = scrollLeft + clientWidth >= scrollWidth - 5;
    rightBtn.classList.toggle("rovalra-btn-disabled", isAtEnd);
  }
  __name(updateScrollButtonStates, "updateScrollButtonStates");
  function getCategoryName(assetTypeId) {
    let id = parseInt(assetTypeId);
    return isEmotesCategoryEnabled && ASSET_TYPE_IDS.EMOTES.has(id) ? "Emotes" : isAnimationsCategoryEnabled && ASSET_TYPE_IDS.ANIMATIONS.has(id) ? "Animations" : isBodyPartsCategoryEnabled && ASSET_TYPE_IDS.BODY_PARTS.has(id) ? "Body Parts" : "Items";
  }
  __name(getCategoryName, "getCategoryName");
  function refreshPillToggle() {
    if (!pillToggleWrapper) return;
    let options = Array.from(discoveredCategories).map((cat) => ({ text: cat, value: cat })), categoryOrder = ["Items"];
    if (isBodyPartsCategoryEnabled && categoryOrder.push("Body Parts"), isAnimationsCategoryEnabled && categoryOrder.push("Animations"), isEmotesCategoryEnabled && categoryOrder.push("Emotes"), options.sort((a, b2) => {
      let indexA = categoryOrder.indexOf(a.value), indexB = categoryOrder.indexOf(b2.value);
      return indexA === -1 ? 1 : indexB === -1 ? -1 : indexA - indexB;
    }), pillToggleWrapper.innerHTML = "", options.length === 0) return;
    let newPillToggle = createPillToggle({
      options,
      initialValue: discoveredCategories.has(currentFilter) ? currentFilter : options[0].value,
      onChange: /* @__PURE__ */ __name((value) => {
        currentFilter = value, updateTabVisibility();
        let container = document.querySelector(".rovalra-items-scroll-container");
        if (container) {
          let left = container.parentElement.querySelector(".left"), right = container.parentElement.querySelector(".right");
          setTimeout(() => updateScrollButtonStates(container, left, right), 50);
        }
      }, "onChange")
    });
    pillToggleWrapper.appendChild(newPillToggle), updateTabVisibility();
  }
  __name(refreshPillToggle, "refreshPillToggle");
  function updateTabVisibility() {
    if (!accessoriesGrid) return;
    accessoriesGrid.style.display = currentFilter === "Items" ? "flex" : "none", emotesGrid && (emotesGrid.style.display = currentFilter === "Emotes" ? "flex" : "none"), animationsGrid && (animationsGrid.style.display = currentFilter === "Animations" ? "flex" : "none"), bodyPartsGrid && (bodyPartsGrid.style.display = currentFilter === "Body Parts" ? "flex" : "none");
    let container = accessoriesGrid.parentElement;
    container && (container.scrollLeft = 0);
  }
  __name(updateTabVisibility, "updateTabVisibility");
  function createCategorizedWearingSection() {
    let section = document.createElement("div");
    section.className = "section rovalra-container", section.style.cssText = "margin-bottom: 24px; display: block; width: 100%; clear: both; float: none;";
    let header = document.createElement("div");
    header.className = "container-header", header.style.cssText = "display: flex; margin-bottom: 12px; width: 100%; align-items: center;";
    let title = document.createElement("h2");
    title.textContent = "Currently Wearing", title.style.margin = "0", totalPriceElement = document.createElement("div"), totalPriceElement.id = "rovalra-wearing-total-price", totalPriceElement.style.cssText = "display: flex; align-items: center; color: var(--rovalra-secondary-text-color); font-size: 16px;";
    let spacer = document.createElement("div");
    spacer.style.flexGrow = "1", pillToggleWrapper = document.createElement("div"), pillToggleWrapper.className = "rovalra-pill-wrapper", header.append(title, totalPriceElement, spacer, pillToggleWrapper);
    let scrollWrapper = document.createElement("div");
    scrollWrapper.className = "rovalra-scroll-wrapper", scrollWrapper.style.cssText = "position: relative; width: 100%; display: flex; align-items: center;";
    let scrollContainer = document.createElement("div");
    scrollContainer.className = "rovalra-items-scroll-container", scrollContainer.style.cssText = "overflow-x: auto; scroll-behavior: smooth; padding: 10px 0; flex-grow: 1; display: block;", accessoriesGrid = document.createElement("div"), accessoriesGrid.className = "rovalra-category-grid wearables", accessoriesGrid.style.cssText = "display: flex; flex-wrap: nowrap; gap: 12px; width: max-content; min-width: 100%;", scrollContainer.append(accessoriesGrid), isEmotesCategoryEnabled && (emotesGrid = document.createElement("div"), emotesGrid.className = "rovalra-category-grid emotes", emotesGrid.style.cssText = "display: none; flex-wrap: nowrap; gap: 12px; width: max-content; min-width: 100%;", scrollContainer.append(emotesGrid)), isAnimationsCategoryEnabled && (animationsGrid = document.createElement("div"), animationsGrid.className = "rovalra-category-grid animations", animationsGrid.style.cssText = "display: none; flex-wrap: nowrap; gap: 12px; width: max-content; min-width: 100%;", scrollContainer.append(animationsGrid)), isBodyPartsCategoryEnabled && (bodyPartsGrid = document.createElement("div"), bodyPartsGrid.className = "rovalra-category-grid body-parts", bodyPartsGrid.style.cssText = "display: none; flex-wrap: nowrap; gap: 12px; width: max-content; min-width: 100%;", scrollContainer.append(bodyPartsGrid));
    let { leftButton, rightButton } = createScrollButtons({
      onLeftClick: /* @__PURE__ */ __name(() => {
        scrollContainer.scrollLeft -= 600;
      }, "onLeftClick"),
      onRightClick: /* @__PURE__ */ __name(() => {
        scrollContainer.scrollLeft += 600;
      }, "onRightClick")
    });
    return leftButton.classList.add("rovalra-scroll-btn", "left"), rightButton.classList.add("rovalra-scroll-btn", "right"), scrollContainer.addEventListener("scroll", () => updateScrollButtonStates(scrollContainer, leftButton, rightButton)), scrollWrapper.append(leftButton, scrollContainer, rightButton), section.append(header, scrollWrapper), section;
  }
  __name(createCategorizedWearingSection, "createCategorizedWearingSection");
  function addItemToCategoryView(itemEl, assetId) {
    if (itemEl.dataset.rovalraCategorized === "true") return;
    let info = assetInfoCache.get(assetId);
    if (!info || !accessoriesGrid) return;
    let category = getCategoryName(info.assetType.id), targetGrid;
    switch (category) {
      case "Emotes":
        targetGrid = emotesGrid;
        break;
      case "Animations":
        targetGrid = animationsGrid;
        break;
      case "Body Parts":
        targetGrid = bodyPartsGrid;
        break;
      default:
        targetGrid = accessoriesGrid;
    }
    if (!Array.from(targetGrid.children).some(
      (child) => child.dataset.rovalraPendingId == assetId || child.querySelector(`a[href*="/${assetId}/"]`)
    )) {
      itemEl.dataset.rovalraCategorized = "true";
      let card = createItemCard(assetId, {}, { cardStyles: { width: "150px", flexShrink: 0 } });
      card.dataset.rovalraPendingId = assetId, targetGrid.appendChild(card), discoveredCategories.has(category) || (discoveredCategories.add(category), refreshPillToggle());
      let container = targetGrid.parentElement;
      updateScrollButtonStates(container, container.parentElement.querySelector(".left"), container.parentElement.querySelector(".right"));
    }
    itemEl.style.display = "none";
  }
  __name(addItemToCategoryView, "addItemToCategoryView");
  function handleItemDetection(itemEl) {
    if (itemEl.closest(".profile-store")) return;
    let link = itemEl.querySelector("a.item-card-link");
    if (!link) return;
    let match = link.getAttribute("href")?.match(/\/(catalog|bundles)\/(\d+)\//);
    if (!match) return;
    let assetId = parseInt(match[2]);
    assetInfoCache.has(assetId) ? addItemToCategoryView(itemEl, assetId) : (pendingItems.has(assetId) || pendingItems.set(assetId, []), pendingItems.get(assetId).push(itemEl));
  }
  __name(handleItemDetection, "handleItemDetection");
  async function init51() {
    let result = await new Promise((resolve) => chrome.storage.local.get(["categorizeWearingEnabled", "CategorizeBodyParts", "CategorizeAnimations", "CategorizeEmotes"], resolve));
    if (!result.categorizeWearingEnabled) return;
    isBodyPartsCategoryEnabled = result.CategorizeBodyParts !== !1, isAnimationsCategoryEnabled = result.CategorizeAnimations !== !1, isEmotesCategoryEnabled = result.CategorizeEmotes !== !1, await loadAssetTypeIds(), observeElement(".profile-tab-content", (content) => {
      if (document.getElementById("rovalra-main-categorized-wrapper")) return;
      let originalWearing = content.querySelector(".profile-currently-wearing, .roseal-currently-wearing"), categorizedSection = createCategorizedWearingSection();
      categorizedSection.id = "rovalra-main-categorized-wrapper", originalWearing ? (originalWearing.before(categorizedSection), originalWearing.style.cssText = "display: none !important; height: 0px !important; margin: 0px !important; padding: 0px !important; opacity: 0 !important; pointer-events: none !important;") : content.prepend(categorizedSection);
    }, { multiple: !0 }), observeElement(".profile-currently-wearing, .roseal-currently-wearing", (wearing) => {
      if (wearing.style.cssText = "display: none !important; height: 0px !important; margin: 0px !important; padding: 0px !important; opacity: 0 !important; pointer-events: none !important;", !document.getElementById("rovalra-main-categorized-wrapper")) {
        let categorizedSection = createCategorizedWearingSection();
        categorizedSection.id = "rovalra-main-categorized-wrapper", wearing.before(categorizedSection);
      }
    }, { multiple: !0 }), window.addEventListener("rovalra-catalog-details", (e) => {
      let data = e.detail?.data;
      Array.isArray(data) && data.forEach((item) => {
        let typeId = item.assetType || item.assetTypeId;
        item.id && typeId && (assetInfoCache.set(item.id, { id: item.id, assetType: { id: typeId } }), pendingItems.has(item.id) && (pendingItems.get(item.id).forEach((el2) => addItemToCategoryView(el2, item.id)), pendingItems.delete(item.id)));
      });
    });
    let hideStyle = document.createElement("style");
    hideStyle.innerHTML = `
        .profile-store, .favorite-games-container, .profile-communities { 
            clear: both !important; 
            display: block !important; 
        }
        .profile-currently-wearing, .roseal-currently-wearing {
            display: none !important;
            height: 0px !important;
            margin: 0px !important;
            padding: 0px !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
        .rovalra-items-scroll-container::-webkit-scrollbar { display: none; }
        .rovalra-scroll-btn {
            position: absolute; z-index: 10; top: 50%; transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.6) !important; border-radius: 50%;
            width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;
            border: none; cursor: pointer; color: white; opacity: 0; 
            transition: opacity 0.25s ease; pointer-events: none;
        }
        .rovalra-scroll-btn.left { left: 5px; }
        .rovalra-scroll-btn.right { right: 5px; }
        .rovalra-scroll-wrapper:hover .rovalra-scroll-btn { opacity: 1; pointer-events: auto; }
        .rovalra-scroll-btn.rovalra-btn-disabled { opacity: 0.25 !important; cursor: default; pointer-events: none; }
    `, document.head.appendChild(hideStyle), [
      '.profile-currently-wearing [id="collection-carousel-item"]',
      ".profile-currently-wearing .carousel-item",
      '.roseal-currently-wearing [id="collection-carousel-item"]'
    ].forEach((selector) => {
      observeElement(selector, (item) => {
        item.dataset.rovalraProcessed || (item.dataset.rovalraProcessed = "true", handleItemDetection(item));
        let debouncedRecalculate = debounce2(recalculateTotalPrice, 250);
        observeElement(".rovalra-category-grid .rovalra-item-card", debouncedRecalculate, {
          multiple: !0,
          onRemove: debouncedRecalculate
        });
      }, { multiple: !0 });
    });
  }
  __name(init51, "init");

  // src/content/core/settings/settingConfig.js
  var SETTINGS_CONFIG = {
    Marketplace: {
      title: "Marketplace",
      settings: {
        itemSalesEnabled: {
          label: "Item Sales",
          description: [
            "This shows the most up to date sales and revenue data we have.",
            "The sales data is very likely to be inaccurate on items that are for sale, but very likely to be correct on off-sale items."
          ],
          deprecated: "Sale stats are very old and now inaccurate.",
          type: "checkbox",
          default: !1
        },
        hiddenCatalogEnabled: {
          label: "Hidden Catalog",
          description: [
            "Shows Roblox made items before they are on the official catalog."
          ],
          deprecated: "Patched by Roblox",
          type: "checkbox",
          default: !1
        },
        SaveLotsRobuxEnabled: {
          label: "Save 10%-40% Robux on Purchases",
          description: [
            "This adds a button allowing you to save 40% on items on the catalog and 10% on gamepasses",
            "Keep in mind a group is required for this to work.",
            "**When buying something there will be a 'Save X Robux' Button which when pressed will set up the experience required for it to work for you.**"
          ],
          type: "checkbox",
          default: !0,
          childSettings: {
            RobuxPlaceId: {
              label: "Place ID to use for the 10%-40% Robux back",
              description: [
                "It is best to not modify this, as when using the feature it will automatically set a correct place id.",
                "**Don't change this unless you know what your doing**"
              ],
              type: "input",
              default: null,
              placeholder: "Enter Place ID here..."
            }
          }
        },
        EnableItemDependencies: {
          label: "Item Dependencies",
          description: ["This feature shows an items dependencies which means you are able to view the texture, mesh and more of an item."],
          type: "checkbox",
          default: !0
        },
        priceFloorEnabled: {
          label: "Show Price Floor",
          description: "This will show the price floor when viewing items, and shows if the item you are viewing is sold at or above the price floor.",
          type: "checkbox",
          default: !0
        }
      }
    },
    Games: {
      title: "Experiences",
      settings: {
        PreferredRegionEnabled: {
          label: "Preferred Region Play Button",
          description: [
            "This adds a play button that joins your preferred region.",
            "This also automatically serverhops",
            "If you have this enabled and Quick Play Button, there will be a Preferred Region quick play button "
          ],
          type: "checkbox",
          default: !0,
          childSettings: {
            robloxPreferredRegion: {
              label: "Preferred Region",
              description: [
                "Select your preferred region for joining games.",
                "**Automatic** will automatically attempt to find the closest region to you."
              ],
              type: "select",
              options: "REGIONS",
              showFlags: !0,
              default: "AUTO"
            }
          }
        },
        QuickPlayEnable: {
          label: "Quick Play Button",
          description: [
            "This will add a quick play button to games so you can quickly join the game without opening the game page.",
            "If you have Preferred Region Play Button enabled it will also add a Preferred Region quick play button to quickly join your preferred region.",
            "This is made to look like the official Roblox client's Quick Play button."
          ],
          type: "checkbox",
          default: !0,
          childSettings: {
            privateservers: {
              label: "Show Private Servers in Quick Play",
              description: ["This adds a button to quickly browse and join private servers to the quick play."],
              type: "checkbox",
              default: !0
            },
            playbuttonpreferredregionenabled: {
              label: "Change the normal Play button to join your preferred region in Quick Play",
              description: ["This makes the Roblox Play button in the Quick Play join servers closest to you, instead of a random region."],
              type: "checkbox",
              default: !0
            }
          }
        },
        whatamIJoiningEnabled: {
          label: "What Am I Joining",
          description: [
            "This shows the server ID, region, if it's a private server, and more info about the server you are joining when joining a game."
          ],
          type: "checkbox",
          default: !0,
          childSettings: {
            AlwaysGetInfo: {
              label: "Always Get Server Info",
              description: [
                "This will always get the server info, even if no server data is available.",
                "It has a very small change to get inaccurate information."
              ],
              type: "checkbox",
              default: !0
            },
            closeUiByClickingTheBackground: {
              label: "Close the 'What am I joining' UI by clicking the background",
              description: "This allows you to click the background to close the UI, can be annoying if you want to see the info provided in the UI",
              type: "checkbox",
              default: !0
            }
          }
        },
        EnableGameTrailer: {
          label: "Experience Trailer",
          description: [
            "This adds experience trailers not on youtube to the website, replacing Roblox's way of doing it.",
            "And as a result adding more quality of life, like being able to full screen, turn off auto play, view the length of the video, change playback speed and picture in picture mode."
          ],
          type: "checkbox",
          default: !1,
          childSettings: {
            Enableautoplay: {
              label: "Auto Play Trailer",
              description: ["This will automatically play the trailer"],
              type: "checkbox",
              default: !0
            }
          }
        },
        EnableDevProducts: {
          label: "View Developer Products",
          description: "This allows you to view the developer products of an experience directly on the store page.",
          type: "checkbox",
          default: !0
        },
        QuickOutfitsEnabled: {
          label: "Quick Equip Outfits",
          description: ["This allows you to quickly switch your avatar on the an experience page."],
          type: "checkbox",
          default: !1
        },
        botdataEnabled: {
          label: "Bot Data",
          description: [
            "Shows if a game has a lot of bots in the description of the game.",
            "It doesn't show the amount of bots, since the sample size is too small to give an accurate number."
          ],
          type: "checkbox",
          default: !0
        },
        subplacesEnabled: {
          label: "Subplaces",
          description: ["This adds a tab to an experience page that shows the subplaces of the experience."],
          type: "checkbox",
          default: !0
        },
        updateHistoryEnabled: {
          label: "Update History",
          description: [
            "This adds a tab to an experience page that has a heatmap showing the update history of an experience.",
            "This feature was heavily inspired by a RoPro v2 feature."
          ],
          type: "checkbox",
          default: !1,
          beta: "This feature is lacking update history data. It will slowly get it over time."
        },
        recentServersEnabled: {
          label: "Recent Servers",
          description: ["Shows the 4 most recent servers you joined under an experience."],
          type: "checkbox",
          default: !0,
          storageKey: "rovalra_server_history"
        },
        TotalServersEnabled: {
          label: "Total Servers",
          description: ["This shows the total amount of servers RoValra is tracking under that experience."],
          type: "checkbox",
          default: !0
        },
        GameVersionEnabled: {
          label: "Game Version",
          description: [
            "This shows the current version an experience is on.",
            "Useful for developers."
          ],
          type: "checkbox",
          default: !0
        },
        OldestVersionEnabled: {
          label: "Oldest Server Version",
          description: [
            "This shows the oldest place version that servers are still running on.",
            "Useful for developers."
          ],
          type: "checkbox",
          default: !0
        },
        ServerFilterEnabled: {
          label: "Server Filters",
          description: [
            "This adds a filter to the server list.",
            "**It is highly recommended that the 'Server List Modifications' setting is enabled for this to work correctly.**"
          ],
          type: "checkbox",
          default: !0,
          childSettings: {
            RegionFiltersEnabled: {
              label: "Region Filters",
              description: "Adds Region filters in the server list.",
              type: "checkbox",
              default: !0
            },
            UptimeFiltersEnabled: {
              label: "Uptime Filters",
              description: "Adds Server Uptime filters in the server list.",
              type: "checkbox",
              default: !0
            },
            VersionFiltersEnabled: {
              label: "Place Version Filters",
              description: "Adds Place Version filters in the server list allowing you to filter by servers running a specific place version.",
              type: "checkbox",
              default: !0
            }
          }
        },
        ServerlistmodificationsEnabled: {
          label: "Server List Modifications",
          description: [
            "This adds multiple different features to the server list",
            "These modifications will also apply to the 'Servers My Connections Are In'"
          ],
          type: "checkbox",
          default: !0,
          childSettings: {
            enableShareLink: {
              label: "Share link button",
              description: [
                "This adds a share link button under the join button so you can send a link to the server for other people to join with.",
                "This uses fishstrap.app for the share link."
              ],
              type: "checkbox",
              default: !0
            },
            EnableServerUptime: {
              label: "Server Uptime",
              description: [
                "This shows an estimate of a servers uptime in the server list.",
                "This works by RoValra tracking hundreds of thousands of servers in a database and then estimating the uptime."
              ],
              type: "checkbox",
              default: !0
            },
            EnableServerRegion: {
              label: "Server Region",
              description: ["This shows the servers region / location"],
              type: "checkbox",
              default: !0
            },
            EnablePlaceVersion: {
              label: "Server Version",
              description: ["This shows the version of the experience that a specific server is running."],
              type: "checkbox",
              default: !0
            },
            EnableFullServerID: {
              label: "Show the entire ServerID",
              description: [
                "This shows the entire ServerID",
                "By default Roblox only shows a part of it.",
                "It will hide ServerIDs of servers that you are playing in or friends are playing in unless hovered over."
              ],
              type: "checkbox",
              default: !0
            },
            EnableFullServerIndicators: {
              label: "Full Server Indicators",
              description: [
                "This adds indicators when a server is full",
                "Like the queue size, and text telling you the server is full if we don't have region data."
              ],
              type: "checkbox",
              default: !0
            },
            EnableServerPerformance: {
              label: "Show Server Performance",
              description: ["This will show the performance of the server, useful if you wanna avoid servers that are running poorly."],
              type: "checkbox",
              default: !0
            },
            EnableMiscIndicators: {
              label: "Show misc indicators",
              description: ["This shows indicators for servers you cannot join like if someone is playing in a private server"],
              type: "checkbox",
              default: !0
            },
            EnableDatacenterandId: {
              label: "Show Datacenter ID and Server Ip",
              description: "This shows the Datacenter ID server Ip of servers in the server list.",
              type: "checkbox",
              default: !1
            }
          }
        },
        PrivateQuickLinkCopy: {
          label: "Quick Private Server Link Copy and Generation",
          description: [
            "This allows you to quickly copy a private server link or generate a new private server link"
          ],
          type: "checkbox",
          default: !0
        }
      }
    },
    Profile: {
      title: "Profile",
      settings: {
        userGamesEnabled: {
          label: "Hidden User Games",
          description: ["Shows a users hidden games on their profile."],
          type: "checkbox",
          default: !0
        },
        userSniperEnabled: {
          label: "Instant Joiner",
          description: [
            "This joins a user instantly when they go into a game, best used for people with a lot of people trying to join them.",
            "### Requirements",
            "- This feature requires the user to have their joins enabled for everyone or for you to be friends with them."
          ],
          type: "checkbox",
          default: !0,
          childSettings: {
            deeplinkEnabled: {
              label: "Join through deeplinks",
              description: ["This will use deeplinks to join the user for faster joining but may be less reliable."],
              type: "checkbox",
              default: !1
            }
          }
        },
        PrivateServerBulkEnabled: {
          label: "Private Server Bulk Removal",
          description: [
            "This will add a toggle to the private server inventory tab that allows you to easily set a bunch of private servers as inactive.",
            "This also works for setting inactive private servers as active"
          ],
          type: "checkbox",
          default: !0
        },
        donationbuttonEnable: {
          label: "Donation Button",
          description: ["This will add a donation button to a user's profile, which allows you to donate to someone via PLS Donate"],
          type: "checkbox",
          default: !0
        },
        categorizeWearingEnabled: {
          label: "Improved Currently Wearing",
          description: [
            "Separates the 'Currently Wearing' section on profiles into categories like Items, Emotes, Body Parts and Animations.",
            "Also improves the item cards making them look a bit better and adds total outfit price.",
            "This feature was heavily inspired by a [roseal](https://www.roseal.live/) feature."
          ],
          type: "checkbox",
          default: !0,
          childSettings: {
            CategorizeBodyParts: {
              label: "Body Parts in its own category",
              description: "This puts Body Parts into its own category",
              type: "checkbox",
              default: !0
            },
            CategorizeEmotes: {
              label: "Emotes in its own category",
              description: "This puts Emotes into its own category",
              type: "checkbox",
              default: !0
            },
            CategorizeAnimations: {
              label: "Animations in its own category",
              description: "This puts Animations into its own category",
              type: "checkbox",
              default: !0
            }
          }
        },
        userRapEnabled: {
          label: "User RAP",
          description: ["This shows a user's total RAP on their profile."],
          type: "checkbox",
          default: !0,
          childSettings: {
            HideSerial: {
              label: "Hide Serial Numbers",
              description: ["This hides serial numbers on limiteds unless you hover over them."],
              type: "checkbox",
              default: !1
            }
          }
        },
        useroutfitsEnabled: {
          label: "User Outfits",
          description: ["This allows you to view a user's saved outfits on their profile."],
          type: "checkbox",
          default: !0
        },
        RoValraBadgesEnable: {
          label: "RoValra Badges",
          description: [
            "Disabling this will hide any RoValra badges from profiles."
          ],
          type: "checkbox",
          default: !0
        }
      }
    },
    Communities: {
      title: "Communities",
      settings: {
        groupGamesEnabled: {
          label: "Hidden Community Experiences",
          description: ["Shows a communities hidden experiences."],
          type: "checkbox",
          default: !0
        },
        pendingRobuxEnabled: {
          label: "Unpending Robux",
          description: ["Shows an estimate of how many pending Robux will stop pending within 24 hours."],
          experimental: "May be inaccurate. And will take ages depending on the amount of sales",
          type: "checkbox",
          default: !1
        },
        antibotsEnabled: {
          label: "Anti-Bot Members",
          description: [
            "This adds a button that will allow you to scan all members in a community for bots.",
            "If there is any bots it will allow you to quickly ban or kick them.",
            "This calculates bots by similar avatars and display names, so it may not be 100% accurate."
          ],
          experimental: "Takes ages since Roblox has heavy rate limits.",
          type: "checkbox",
          default: !0
        },
        QuickActionsEnabled: {
          label: "Quick Actions",
          description: ["This adds a quick action button allowing you to quickly ban or kick a bunch of users at once."],
          type: "checkbox",
          default: !0
        },
        draggableGroupsEnabled: {
          label: "Draggable Communities",
          description: [
            "Hold and drag your communities to reorder them however you want.",
            "Your custom order will be saved and persist across page refreshes.",
            "Just hold down on a community for a moment and drag it up or down."
          ],
          type: "checkbox",
          default: !0,
          storageKey: "rovalra_groups_order"
        }
      }
    },
    Avatar: {
      title: "Avatar",
      settings: {
        forceR6Enabled: {
          label: "Remove R6 Warning",
          description: ["Removes the R6 warning when switching to R6"],
          type: "checkbox",
          default: !0
        },
        multiEquipEnabled: {
          label: "Multi-Equip",
          description: ["Allows you to equip multiple items like accessories seamlessly without having to use the advanced tab."],
          type: "checkbox",
          default: !0
        },
        avatarFiltersEnabled: {
          label: "Avatar Filters",
          description: ["Adds filters to the avatar page, allowing you to filter by effect items, limited, offsale / onsale and more."],
          type: "checkbox",
          default: !0
        },
        searchbarEnabled: {
          label: "Adds a Searchbar to the Avatar Page",
          description: ["Allowing you to quickly search for items in the avatar editor."],
          type: "checkbox",
          default: !0
        },
        avatarRotatorEnabled: {
          label: "Avatar Rotator",
          description: [
            "Adds an avatar Rotator allowing you to Rotate between different avatars on a set interval.",
            "Allowing you to have a random avatar equipped every time you join an experience or respawn."
          ],
          type: "checkbox",
          default: !0,
          storageKey: ["rovalra_avatar_rotator_enabled", "rovalra_avatar_rotator_ids", "rovalra_avatar_rotator_interval"]
        }
      }
    },
    transactions: {
      title: "Transactions",
      settings: {
        totalspentEnabled: {
          label: "Total Spent",
          description: ["This calculates the total amount of Robux and money you have spent on your account based on your transaction history."],
          type: "checkbox",
          default: !0
        },
        totalearnedEnabled: {
          label: "Total Earned",
          description: ["This Calulates the amount of Robux you have earned through out the years via stuff like gamepasses, item sales etc."],
          type: "checkbox",
          default: !0
        },
        pendingrobuxtrans: {
          label: "Unpending Robux Transactions",
          description: [
            "This estimates how many Robux will stop pending in 24 hours."
          ],
          experimental: "May be inaccurate. And will take ages depending on the amount of sales",
          type: "checkbox",
          default: !1
        }
      }
    },
    Navigation: {
      title: "Navigation",
      settings: {
        qolTogglesEnabled: {
          label: "Adds quality of life toggles to the nav bar",
          description: "Allowing you to quickly change your online status or experience status without going into settings.",
          type: "checkbox",
          default: !0
        },
        betaProgramsEnabled: {
          label: "Adds a beta programs toggle to the nav bar",
          description: "This allows you to toggle beta programs you are enrolled into easily.",
          type: "checkbox",
          default: !1
        }
      }
    },
    Miscellaneous: {
      title: "Miscellaneous",
      settings: {
        MemoryleakFixEnabled: {
          label: "Fix Roblox Memory Leak",
          description: [
            "This attempts to fix the memory leak caused by the Roblox website when reloading a page or navigating the site.",
            "This fix will redirect most url changes to 'about:blank' and then to the intended url, which fixes the memory leak, but may cause a slight flicker when navigating and issues with the back and forward arrows.",
            "If you don't know what a memory leak is or you don't feel like Roblox is using too much memory, you can leave this off.",
            "**This will prompt you to enable the 'webNavigation' permission for the feature to work.**"
          ],
          experimental: "May cause some issues.",
          type: "checkbox",
          default: !1,
          requiredPermissions: ["webNavigation"]
        },
        ServerdataEnabled: {
          label: "Send Server IDs and Place IDs to RoValra's API",
          description: [
            "This feature sends server IDs and place IDs to RoValra's API when you browse the site.",
            "This data is used for the server uptime and the Total Servers features.",
            "Leaving this feature on will help improve the Server Uptime and Total Servers features.",
            "**No personal data is sent, not even user ID or username\u2014only the server IDs and the place ID.**",
            "**No data that can be used to link the server IDs/place IDs to you are sent or logged.**"
          ],
          type: "checkbox",
          default: !0
        },
        DownloadCreateEnabled: {
          label: "Adds a download button to create.roblox.com",
          description: "This feature allows you to download assets like meshes, images, audios, etc from the create page.",
          type: "checkbox",
          default: !0
        },
        copyIdEnabled: {
          label: "Allows you to quickly copy an id of a thing you are right clicking.",
          description: "This adds a copy id button directly into the right click context menu so you don't have  to open the link and copy the id from the link.",
          type: "checkbox",
          default: !1,
          requiredPermissions: ["contextMenus"]
        },
        copyUniverseIdEnabled: {
          label: "Allows you to quickly copy a universe id",
          description: "This adds a copy universe id button directly into the right click context menu.",
          type: "checkbox",
          default: !1,
          requiredPermissions: ["contextMenus"]
        },
        PreviousPriceEnabled: {
          label: "Previous Price to item cards and on item pages.",
          description: "This shows the price of an offsale item before it went offsale.",
          type: "checkbox",
          default: !0
        },
        cssfixesEnabled: {
          label: "Site Fixes",
          description: ["This fixes various site issues or just poor design choices by Roblox."],
          type: "checkbox",
          default: !0,
          childSettings: {
            giantInvisibleLink: {
              label: "Fix the Continue and Favorites buttons' clickable area",
              description: ["Fixes the Continue and Favorites buttons on the home page being wider than shown visually."],
              type: "checkbox",
              default: !0
            },
            gameTitleIssueEnable: {
              label: "Fix the experience title issues",
              description: "Fixes the top and bottom of experience titles on profiles getting cut off.",
              type: "checkbox",
              default: !0
            },
            FixCartRemoveButton: {
              label: "Fix Cart Remove Button Size",
              description: "Fixes the size of the remove item from cart button being super small in the shopping cart.",
              type: "checkbox",
              default: !0
            }
          }
        },
        eastereggslinksEnabled: {
          label: "Easter Egg Links",
          description: [
            "Adds Easter eggs to random links that otherwise would do nothing.",
            "Some easter eggs redirect offsite."
          ],
          type: "checkbox",
          default: !0
        },
        revertLogo: {
          label: "Change the app launch icon",
          description: [
            "This changes the icon that shows when you join a game.",
            "Old icon is the icon it had before they changed it to the new app client icon.",
            "And of course, a custom icon can be any image you want."
          ],
          type: "checkbox",
          default: !1,
          childSettings: {
            customLogoData: {
              label: "Custom icon",
              description: ["Upload your custom image. Maximum file size is 1MB."],
              type: "file",
              default: null,
              compressSettingName: "compressCustomLogo",
              storageKey: "customLogoData"
            },
            compressCustomLogo: {
              label: "Compress Custom Icon",
              description: [
                "Compresses the image to reduce storage space (max 512px, JPEG 80% quality for photos, PNG for transparent images).",
                "Disable this to keep full quality and transparency, but it may use more storage space.",
                "Uncompressed images must still be under 1MB."
              ],
              type: "checkbox",
              default: !0
            }
          }
        }
      }
    },
    AntiAccountTracking: {
      title: "Privacy",
      settings: {
        streamermode: {
          label: "Streamer Mode",
          description: [
            "This feature hides information that you most likely don't wanna accidently show on something like a live stream."
          ],
          type: "checkbox",
          default: !1,
          experimental: "This may cause some issues since it tricks Roblox into thinking your private info is something it isn't.",
          childSettings: {
            settingsPageInfo: {
              label: "Hide Private Information on the settings page",
              description: [
                "This visually replaces your Email, Phone Number, Sessions and account location with 'RoValra Streamer Mode Enabled'",
                "And completely hides your Age Group, previous usernames in settings and Birthday."
              ],
              type: "checkbox",
              default: !0
            },
            hideRobux: {
              label: "Hide Robux",
              description: [
                "Simply hides your Robux by changing it to 'Hidden'",
                "This does not hide your Robux on purchase prompts."
              ],
              type: "checkbox",
              default: !1
            }
          }
        },
        spoofAsOffline: {
          label: "Spoof status as Offline",
          description: [
            "Makes you appear as offline to you and other people.",
            "This is useful if you want to appear offline while still allowing connections to join you in experiences, since the official offline status by Roblox does not allow this.",
            "Joining an experience will overwrite this status.",
            "This may take a few minutes to actually change your status to offline after turning on the feature."
          ],
          type: "checkbox",
          default: !1,
          exclusiveWith: ["spoofAsStudio", "spoofAsOnline"]
        },
        spoofAsStudio: {
          label: "Spoof status as In Studio",
          description: [
            "Makes your online status appear as 'In Studio' to you and other users.",
            "Joining an experience will overwrite this status.",
            "The Spoofed Status will only show if RoValra is enabled and a Roblox page is open."
          ],
          type: "checkbox",
          default: !1,
          exclusiveWith: ["spoofAsOffline", "spoofAsOnline"]
        }
      }
    },
    FunStuff: {
      title: "Fun Stuff",
      settings: {
        bandurationsEnabled: {
          label: "All possible ban durations",
          description: [
            "**This does not include voice chat bans.**",
            "**Any text saying 'Note:' is a note added by Valra to explain stuff better.**",
            "- Banned for 1 Day",
            "- Banned for 3 Days",
            "- Banned for 7 Days",
            "- Banned for 14 Days",
            "- Account Deleted",
            "\u2022 Warning",
            "\u2022 Banned for 6 Months",
            "\u2022 Banned for 1 Year",
            "\u2022 Note: the stuff below are not bans but instead Roblox telling you what will happen if you do it again, this doesn't always show when you get banned.",
            "\u2022 This stuff below is called a 'Forshadow ban'",
            "\u2022 If you violate the Community Standards again, your account may be suspended in the future. ",
            "\u2022 If you violate the Community Standards again, your account may be suspended for at least 1 day.",
            "\u2022 If you violate the Community Standards again, your account may be suspended for at least 3 days.",
            "\u2022 If you violate the Community Standards again, your account may be suspended for at least 7 days.",
            "\u2022 If you violate the Community Standards again, your account may be permanently banned from Roblox.",
            "- Note: 2 days, 1 hour, 3 hours, 6 hours and 12 hours bans might not be in use.",
            "\u2022 Banned for 2 Days",
            "\u2022 Banned for 3 Hours",
            "\u2022 Banned for 6 Hours",
            "\u2022 Banned for 12 Hours",
            "\u2022 Banned for 1 Hour",
            "\u2022 Account Terminated",
            "\u2022 Banned for 60 Days"
          ],
          default: null
        },
        BanReasons: {
          label: "All possible ban reasons on Roblox, some ban reasons have been censored by Valra.",
          description: [
            "**All ban reasons are 100% confirmed**",
            "**Keep in mind these are ban reasons, which is basically categories each ban might fall into.**",
            "**Any text saying 'Note:' is a note added by Valra to explain stuff better.**",
            "- None (Note: Likely used for when there isn't a ban reason, and instead only a moderator note.)",
            "- Profanity",
            "- Harassment",
            "- Spam",
            "- Advertisement",
            "\u2022 Scamming",
            "\u2022 Adult Content",
            "\u2022 Inappropriate",
            "\u2022 Privacy",
            "\u2022 Unclassified Mild",
            "\u2022 BlockedContent",
            "\u2022 Minor Swearing",
            "\u2022 Distorted Audio",
            "\u2022 Loud Earbleeders",
            "\u2022 Players Screaming into Microphone",
            "\u2022 Swearing",
            "\u2022 P####graphic Sounds",
            "\u2022 Explicit S##ual References and Innuendo",
            "\u2022 Dr## and Alc###l References",
            "\u2022 Discriminatory or N##i Content",
            "\u2022 Dating Imagery",
            "\u2022 Discriminatory Content",
            "\u2022 Dr##s, Alc###l",
            "\u2022 DMCA",
            "\u2022 Explicit N####y/P##n",
            "\u2022 Gang Images",
            "\u2022 N###s",
            "\u2022 Personal Attack/Harassment/Bullying",
            "\u2022 Red Armbands (Not N###s) ",
            "\u2022 Suggestive/S##ualized Imagery",
            "\u2022 S####de/Self-####",
            "\u2022 Clickbait Ads",
            "\u2022 Inappropriate Content",
            "\u2022 Not Related to Roblox",
            "\u2022 Off-Site Links",
            "\u2022 Hidden Message Clothing",
            "\u2022 None of the Above",
            "\u2022 Account Theft",
            "\u2022 Asset Ownership",
            "\u2022 Billing",
            "\u2022 Compromised Account",
            "\u2022 Copyright/DMCA",
            "\u2022 Derogatory/Harassment",
            "\u2022 Depressive",
            "\u2022 Discriminatory",
            "\u2022 Exploiting",
            "\u2022 Text Filter / Profanity",
            "\u2022 Gr###ing",
            "\u2022 Illicit Substance",
            "\u2022 Malicious",
            "\u2022 Misleading",
            "\u2022 Dating",
            "\u2022 Phishing/Scam",
            "\u2022 Real Info",
            "\u2022 RMT (Note: Real money transaction)",
            "\u2022 S##ual/Adult Content",
            "\u2022 Shock",
            "\u2022 Threats",
            "\u2022 Real-Life Tragedy",
            "\u2022 Politics",
            "\u2022 Encouraging Dangerous Behavior",
            "\u2022 Other",
            "\u2022 Dating and Romantic Content",
            "\u2022 S##ual Content",
            "\u2022 Directing Users Off-Platform",
            "\u2022 Privacy: Asking for PII",
            "\u2022 Privacy: Giving PII",
            "\u2022 Impersonation",
            "\u2022 Extortion and Blackmail",
            "\u2022 Illegal and Regulated Content",
            "\u2022 Misusing Roblox Systems",
            "\u2022 Political Content",
            "\u2022 T###orism/Extremism",
            "\u2022 Child Endangerment",
            "\u2022 Real-Life Threats",
            "\u2022 Cheat and Exploits",
            "\u2022 Seeking S##ual Content",
            "\u2022 Disruptive Audio",
            "\u2022 Contests and Sweepstakes",
            "\u2022 Threats or Abuse of Roblox Employees or Affiliates",
            "\u2022 Roblox Economy",
            "\u2022 IRL Dangerous Activities",
            "\u2022 Intellectual Property Violation",
            "\u2022 Off Platform Speech and Behavior",
            "\u2022 Violent Content and Gore",
            "\u2022 Advertising",
            "\u2022 Chargeback",
            "\u2022 DMCA Early Legal Strike",
            "\u2022 DMCA Final Legal Strike",
            "\u2022 You created or used an account to avoid an enforcement action taken against another account determined from your account information, such as your account email, phone number, or other information (Note: This is not a ban reason; this is a moderator note)",
            "\u2022 Trademark Violation",
            "\u2022 Roblox does not permit using third-parties to buy, sell, or trade Robux, promotional codes that falsely appear to be from Roblox Corporation, or inappropriate use of the community payout system. (Note: This is not a ban reason; this is a moderator note)",
            "- Note: Fun fact\u2014the 'using third-parties to buy, sell, or trade Robux' moderator notes are called 'Virtual Casino' bans in the code"
          ],
          default: null
        },
        appealstuff: {
          label: "Appeals related stuff",
          description: [
            "**Appeal Outcomes & Decisions**",
            "- Appeal denied",
            "- We have reviewed your appeal. This activity is still in violation of Roblox Community Standards.",
            "- Appeal accepted",
            "- We have reviewed your appeal. This activity is not in violation of Roblox Community Standards. Any consequence related to this activity is reversed.",
            "- We have reviewed your appeal. This activity is still in violation of Roblox Community Standards. However, we\u2019ve updated the violation category.",
            "**Appeal Instructions & Information**",
            "- Appeal something not shown",
            "- Request Appeal",
            "- Additional info (optional)",
            "- You can appeal by {date}",
            `- View past violations and manage your appeals. All content and behavior must adhere to the {link}Roblox Community
Standards{linkEnd}.`,
            "- Reviews are based on {link}Roblox Community Standards{linkEnd}",
            "- Learn more about appeals {link}here{linkEnd}.",
            "**Error Messages & Support Fallbacks**",
            "- Appeals information not found",
            "- If you would like to appeal something not shown here please visit {link}Support{linkEnd}",
            "- You've reached the maximum number of appeals. You may no longer appeal this {assetType}."
          ],
          default: null
        },
        captcha: {
          label: "All the places where you can get a captcha on Roblox",
          description: ["Roblox, I'm still mad that you denied my captcha bypass just to fix it a few weeks later \u{1F621}\u{1F621}\u{1F621}\u{1F621}\u{1F621}", "- sign up", "- login", "- change password", "- redeeming a gift card", "- submitting a support ticket", "- buying an item (speculation, might have been removed)", "- posting on a group wall (likely gonna be the same for group forum posts)", "- joining a group", "- 'generic challenge'\u2014no idea what they mean by that.", "- following a user", "- uploading 'clothing asset'\u2014could also be the same for any asset but I'm unsure", "- posting a comment on an asset (comments on assets have been removed)"],
          default: null
        }
      }
    }
  };

  // src/content/core/ui/fileupload.js
  async function compressImage(base64Image, shouldCompress = !0) {
    return shouldCompress ? new Promise((resolve, reject) => {
      let img = new Image();
      img.onload = () => {
        let { width, height } = img;
        if (width > 512 || height > 512) {
          let ratio = Math.min(512 / width, 512 / height);
          width = Math.floor(width * ratio), height = Math.floor(height * ratio);
        }
        let canvas = document.createElement("canvas");
        canvas.width = width, canvas.height = height;
        let ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, width, height);
        let imageData = ctx.getImageData(0, 0, width, height), hasTransparency = !1;
        for (let i = 3; i < imageData.data.length; i += 4)
          if (imageData.data[i] < 255) {
            hasTransparency = !0;
            break;
          }
        let compressed;
        hasTransparency ? compressed = canvas.toDataURL("image/png", 0.9) : compressed = canvas.toDataURL("image/jpeg", 0.8), resolve(compressed);
      }, img.onerror = reject, img.src = base64Image;
    }) : base64Image;
  }
  __name(compressImage, "compressImage");
  function formatFileSize(bytes) {
    return bytes < 1024 ? bytes + " B" : bytes < 1024 * 1024 ? (bytes / 1024).toFixed(1) + " KB" : (bytes / (1024 * 1024)).toFixed(2) + " MB";
  }
  __name(formatFileSize, "formatFileSize");
  var isCssInjected2 = !1;
  function injectFileUploadCss() {
    if (isCssInjected2) return;
    isCssInjected2 = !0;
    let style = document.createElement("style");
    style.id = "rovalra-global-fileupload-style", style.textContent = `
        .rovalra-fileupload-wrapper {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-left: auto;
            max-width: 250px;
        }
        .rovalra-fileupload-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rovalra-fileupload-filename {
            font-size: 12px;
            color: var(--text-secondary);
            max-width: 150px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .rovalra-fileupload-preview {
            display: none;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
            padding: 8px;
            border: 1px solid var(--border-default);
            border-radius: 8px;
            background-color: var(--surface-default);
        }
        .rovalra-fileupload-preview.visible {
            display: flex;
        }
        .rovalra-fileupload-preview img {
            max-width: 100%;
            max-height: 150px;
            border-radius: 4px;
            object-fit: contain;
            align-self: flex-start;
        }
        .rovalra-fileupload-size {
            font-size: 11px;
            color: var(--text-secondary);
        }
        .rovalra-fileupload-error {
            font-size: 11px;
            color: var(--color-status-error);
            margin-top: 4px;
        }
    `, document.head.appendChild(style);
  }
  __name(injectFileUploadCss, "injectFileUploadCss");
  function createFileUpload({ id, accept = "image/*", compress = !0, compressSettingName, onFileSelect, onFileClear }) {
    injectFileUploadCss();
    let wrapper = document.createElement("div");
    wrapper.className = "rovalra-fileupload-wrapper";
    let controlsContainer = document.createElement("div");
    controlsContainer.className = "rovalra-fileupload-controls";
    let fileInput = document.createElement("input");
    fileInput.type = "file", fileInput.id = id, fileInput.accept = accept, fileInput.style.display = "none";
    let triggerButton = document.createElement("button");
    triggerButton.type = "button", triggerButton.id = `${id}-trigger`, triggerButton.className = "rovalra-fileupload-trigger relative clip group/interactable focus-visible:outline-focus disabled:outline-none flex items-center justify-between width-full bg-none stroke-standard radius-medium height-1000 padding-x-medium text-body-medium stroke-default content-default";
    let presentationDiv = document.createElement("div");
    presentationDiv.setAttribute("role", "presentation"), presentationDiv.className = "absolute inset-[0] transition-colors group-hover/interactable:bg-[var(--color-state-hover)] group-active/interactable:bg-[var(--color-state-press)] group-disabled/interactable:bg-none";
    let textWrapper = document.createElement("div");
    textWrapper.className = "grow-1 text-truncate-split text-align-x-left";
    let triggerValue = document.createElement("span");
    triggerValue.className = "text-no-wrap text-truncate-split content-emphasis", triggerValue.style.pointerEvents = "none", triggerValue.textContent = "Upload File", textWrapper.appendChild(triggerValue);
    let fileNameDisplay = document.createElement("span");
    fileNameDisplay.id = `${id}-filename`, fileNameDisplay.className = "rovalra-fileupload-filename", fileNameDisplay.style.display = "none";
    let clearButton = document.createElement("button");
    clearButton.type = "button", clearButton.id = `${id}-clear`, clearButton.className = "btn-control-xs rovalra-fileupload-clear", clearButton.innerHTML = '<span class="icon-close"></span>', clearButton.style.display = "none";
    let previewContainer = document.createElement("div");
    previewContainer.className = "rovalra-fileupload-preview";
    let previewImage = document.createElement("img");
    previewImage.alt = "File preview";
    let fileSizeDisplay = document.createElement("span");
    fileSizeDisplay.className = "rovalra-fileupload-size", previewContainer.append(previewImage, fileSizeDisplay);
    let errorMessage = document.createElement("span");
    errorMessage.className = "rovalra-fileupload-error", errorMessage.style.display = "none", triggerButton.addEventListener("click", () => fileInput.click()), fileInput.addEventListener("change", async () => {
      if (fileInput.files && fileInput.files.length > 0) {
        let file = fileInput.files[0];
        errorMessage.style.display = "none", errorMessage.textContent = "";
        let reader = new FileReader();
        reader.onload = async (e) => {
          try {
            let base64Data = e.target.result;
            if (!base64Data || !base64Data.startsWith("data:image/")) {
              errorMessage.textContent = "Invalid file format. Please upload a valid image.", errorMessage.style.display = "block", fileInput.value = "", clearPreview();
              return;
            }
            let shouldCompress = compress;
            compressSettingName && (shouldCompress = (await chrome.storage.local.get([compressSettingName]))[compressSettingName] !== !1);
            let finalData = base64Data;
            if (file.type.startsWith("image/") && (finalData = await compressImage(base64Data, shouldCompress)), !finalData || !finalData.startsWith("data:image/")) {
              errorMessage.textContent = "Image processing failed. Please try another file.", errorMessage.style.display = "block", fileInput.value = "", clearPreview();
              return;
            }
            let finalSize = Math.round(finalData.length * 3 / 4);
            if (finalSize > 1048576) {
              let errorMsg = shouldCompress ? `File too large even after compression. Size: ${formatFileSize(finalSize)}, maximum: ${formatFileSize(1048576)}.` : `File too large. Size: ${formatFileSize(finalSize)}, maximum: ${formatFileSize(1048576)}. Enable compression to reduce file size.`;
              errorMessage.textContent = errorMsg, errorMessage.style.display = "block", fileInput.value = "", clearPreview();
              return;
            }
            setPreview(finalData, finalSize), onFileSelect(finalData);
          } catch (error) {
            console.error("Error processing image:", error), errorMessage.textContent = "Error processing image. Please try another file.", errorMessage.style.display = "block", fileInput.value = "", clearPreview();
          }
        }, reader.readAsDataURL(file);
      }
    }), onFileClear && clearButton.addEventListener("click", () => {
      fileInput.value = "", clearPreview(), onFileClear();
    }), triggerButton.append(presentationDiv, textWrapper), controlsContainer.append(fileNameDisplay, clearButton, triggerButton), wrapper.append(controlsContainer, errorMessage, fileInput);
    let setFileName = /* @__PURE__ */ __name((name) => {
      name ? (fileNameDisplay.textContent = name, fileNameDisplay.style.display = "inline", triggerValue.textContent = "Change") : (fileNameDisplay.style.display = "none", triggerValue.textContent = "Upload File");
    }, "setFileName"), showClear = /* @__PURE__ */ __name((visible) => {
      clearButton.style.display = visible ? "inline-flex" : "none";
    }, "showClear"), setPreview = /* @__PURE__ */ __name((base64Data, sizeInBytes) => {
      previewImage.src = base64Data, fileSizeDisplay.textContent = formatFileSize(sizeInBytes), previewContainer.classList.add("visible");
    }, "setPreview"), clearPreview = /* @__PURE__ */ __name(() => {
      previewImage.src = "", fileSizeDisplay.textContent = "", previewContainer.classList.remove("visible");
    }, "clearPreview"), componentApi = { setFileName, showClear, setPreview, clearPreview, showError: /* @__PURE__ */ __name((message) => {
      errorMessage.textContent = message, errorMessage.style.display = message ? "block" : "none";
    }, "showError"), getPreviewElement: /* @__PURE__ */ __name(() => previewContainer, "getPreviewElement") };
    return wrapper.rovalraFileUpload = componentApi, { element: wrapper, ...componentApi };
  }
  __name(createFileUpload, "createFileUpload");

  // src/content/core/utils/sanitize.js
  function sanitizeString(str) {
    return typeof str != "string" || (str = str.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ""), str = str.replace(/on\w+\s*=\s*["'][^"']*["']/gi, ""), str = str.replace(/on\w+\s*=\s*[^\s>]*/gi, ""), str = str.replace(/javascript:/gi, ""), str = str.replace(/data:text\/html[^,]*,/gi, ""), str = str.replace(/style\s*=\s*["'][^"']*["']/gi, ""), str = str.replace(/expression\s*\(/gi, ""), str = str.replace(/vbscript:/gi, ""), str = str.replace(/<[^>]*>/g, "")), str;
  }
  __name(sanitizeString, "sanitizeString");
  function sanitizeObject(obj) {
    if (obj == null)
      return obj;
    if (typeof obj == "string")
      return sanitizeString(obj);
    if (typeof obj == "number" || typeof obj == "boolean")
      return obj;
    if (Array.isArray(obj))
      return obj.map((item) => sanitizeObject(item));
    if (typeof obj == "object") {
      let sanitized = {};
      for (let [key, value] of Object.entries(obj)) {
        let sanitizedKey = sanitizeString(key);
        sanitized[sanitizedKey] = sanitizeObject(value);
      }
      return sanitized;
    }
    return obj;
  }
  __name(sanitizeObject, "sanitizeObject");
  function sanitizeSettings(settings, SETTINGS_CONFIG2 = null) {
    if (!settings || typeof settings != "object")
      throw new Error("Invalid settings format");
    let sanitized = {};
    if (SETTINGS_CONFIG2)
      for (let [key, value] of Object.entries(settings)) {
        let settingDef = null;
        for (let category of Object.values(SETTINGS_CONFIG2)) {
          for (let [settingName, def] of Object.entries(category.settings)) {
            if (settingName === key) {
              settingDef = def;
              break;
            }
            if (def.childSettings && def.childSettings[key]) {
              settingDef = def.childSettings[key];
              break;
            }
          }
          if (settingDef) break;
        }
        if (!settingDef) {
          console.warn(`Sanitizing: Unknown setting '${key}' - skipping`);
          continue;
        }
        let sanitizedValue = value;
        switch (settingDef.type) {
          case "checkbox":
            value !== !0 && value !== !1 && value !== null && (console.warn(`Sanitizing: Invalid boolean value for '${key}' - setting to default`), sanitizedValue = settingDef.default ?? !1);
            break;
          case "number":
            typeof value != "number" || isNaN(value) ? (console.warn(`Sanitizing: Invalid number value for '${key}' - setting to default`), sanitizedValue = settingDef.default ?? 0) : (settingDef.min !== void 0 && value < settingDef.min && (sanitizedValue = settingDef.min), settingDef.max !== void 0 && value > settingDef.max && (sanitizedValue = settingDef.max));
            break;
          case "text":
          case "select":
            if (value === null)
              sanitizedValue = null;
            else if (typeof value != "string")
              console.warn(`Sanitizing: Invalid string value for '${key}' - setting to default`), sanitizedValue = settingDef.default ?? "";
            else if (sanitizedValue = sanitizeString(value), settingDef.type === "select" && settingDef.options && Array.isArray(settingDef.options)) {
              let validValues = settingDef.options.map(
                (opt) => typeof opt == "object" ? opt.value : opt
              );
              validValues.includes(sanitizedValue) || (console.warn(`Sanitizing: Invalid select value '${sanitizedValue}' for '${key}' - setting to default`), sanitizedValue = settingDef.default ?? validValues[0]);
            }
            break;
          case "file":
            value === null ? sanitizedValue = null : (typeof value != "string" || !value.startsWith("data:image/")) && (console.warn(`Sanitizing: Invalid image data for '${key}' - clearing`), sanitizedValue = null);
            break;
          default:
            sanitizedValue = sanitizeObject(value);
        }
        sanitized[key] = sanitizedValue;
      }
    else
      for (let [key, value] of Object.entries(settings))
        sanitized[key] = sanitizeObject(value);
    return delete sanitized.__proto__, delete sanitized.constructor, delete sanitized.prototype, sanitized;
  }
  __name(sanitizeSettings, "sanitizeSettings");

  // src/content/core/settings/handlesettings.js
  var loadSettings = /* @__PURE__ */ __name(async () => new Promise((resolve, reject) => {
    let defaultSettings = {};
    for (let category of Object.values(SETTINGS_CONFIG))
      for (let [settingName, settingDef] of Object.entries(category.settings))
        if (settingDef.default !== void 0 && (defaultSettings[settingName] = settingDef.default), settingDef.childSettings)
          for (let [childName, childSettingDef] of Object.entries(settingDef.childSettings))
            childSettingDef.default !== void 0 && (defaultSettings[childName] = childSettingDef.default);
    chrome.storage.local.get(defaultSettings, (settings) => {
      chrome.runtime.lastError ? (console.error("Failed to load settings:", chrome.runtime.lastError), reject(chrome.runtime.lastError)) : resolve(settings);
    });
  }), "loadSettings"), handleSaveSettings = /* @__PURE__ */ __name(async (settingName, value) => {
    if (!settingName)
      return console.error("No setting name provided"), Promise.reject(new Error("No setting name provided"));
    try {
      let settingConfig = findSettingConfig(settingName), sanitizedValue = value;
      if (settingConfig)
        switch (settingConfig.type) {
          case "checkbox":
            value !== !0 && value !== !1 && value !== null && (console.warn(`Invalid boolean value for '${settingName}' - coercing to boolean`), sanitizedValue = !!value);
            break;
          case "number": {
            let numValue = Number(value);
            isNaN(numValue) ? (console.warn(`Invalid number value for '${settingName}' - setting to default`), sanitizedValue = settingConfig.default ?? 0) : (sanitizedValue = numValue, settingConfig.min !== void 0 && sanitizedValue < settingConfig.min && (sanitizedValue = settingConfig.min), settingConfig.max !== void 0 && sanitizedValue > settingConfig.max && (sanitizedValue = settingConfig.max));
            break;
          }
          case "text":
          case "input":
          case "select":
            if (value === null)
              sanitizedValue = null;
            else if (typeof value == "string") {
              if (sanitizedValue = sanitizeString(value), settingConfig.type === "select" && settingConfig.options) {
                let validValues = Array.isArray(settingConfig.options) ? settingConfig.options.map((opt) => typeof opt == "object" ? opt.value : opt) : [];
                validValues.length > 0 && !validValues.includes(sanitizedValue) && (console.warn(`Invalid select value '${sanitizedValue}' for '${settingName}' - setting to default`), sanitizedValue = settingConfig.default ?? validValues[0]);
              }
            } else
              console.warn(`Invalid string value for '${settingName}' - converting to string and sanitizing`), sanitizedValue = sanitizeString(String(value));
            break;
          case "file":
            value !== null && (typeof value != "string" || !value.startsWith("data:image/")) && (console.warn("Attempted to save non-image data to file setting:", settingName), sanitizedValue = null);
            break;
        }
      let settings = { [settingName]: sanitizedValue };
      return new Promise((resolve, reject) => {
        chrome.storage.local.set(settings, () => {
          chrome.runtime.lastError ? (console.error("Failed to save setting:", settingName, chrome.runtime.lastError), reject(chrome.runtime.lastError)) : (syncToSettingsKey(settingName, sanitizedValue), resolve());
        });
      });
    } catch (error) {
      return console.error(`Error saving setting ${settingName}:`, error), Promise.reject(error);
    }
  }, "handleSaveSettings"), syncToSettingsKey = /* @__PURE__ */ __name((settingName, value) => {
    chrome.storage.local.get("rovalra_settings", (result) => {
      let settingsData = result.rovalra_settings || {};
      settingsData[settingName] = value, chrome.storage.local.set({ rovalra_settings: settingsData });
    });
  }, "syncToSettingsKey"), buildSettingsKey = /* @__PURE__ */ __name(async () => new Promise((resolve) => {
    let allSettingKeys = [];
    for (let category of Object.values(SETTINGS_CONFIG))
      for (let [settingName, settingDef] of Object.entries(category.settings))
        if (allSettingKeys.push(settingName), settingDef.childSettings)
          for (let childName of Object.keys(settingDef.childSettings))
            allSettingKeys.push(childName);
    chrome.storage.local.get(allSettingKeys, (currentSettings) => {
      chrome.storage.local.set({ rovalra_settings: currentSettings }, () => {
        chrome.runtime.lastError ? console.error("Failed to build settings key:", chrome.runtime.lastError) : console.log("RoValra: Settings key initialized"), resolve();
      });
    });
  }), "buildSettingsKey"), initSettings = /* @__PURE__ */ __name(async (settingsContent) => {
    if (!settingsContent) {
      console.error("settingsContent is null in initSettings! Check HTML structure.");
      return;
    }
    let settings = await loadSettings();
    if (settings)
      for (let sectionName in SETTINGS_CONFIG) {
        let section = SETTINGS_CONFIG[sectionName];
        for (let [settingName, config] of Object.entries(section.settings))
          if (settings[settingName] === !0 && config.requiredPermissions) {
            let missingPerms = !1;
            for (let perm of config.requiredPermissions)
              if (!await hasPermission(perm)) {
                missingPerms = !0;
                break;
              }
            missingPerms && (console.log(`RoValra: Disabling '${settingName}' because required permissions are missing.`), await handleSaveSettings(settingName, !1), settings[settingName] = !1);
          }
      }
    if (settings) {
      for (let sectionName in SETTINGS_CONFIG) {
        let section = SETTINGS_CONFIG[sectionName];
        for (let [settingName, setting] of Object.entries(section.settings)) {
          let element = settingsContent.querySelector(`#${settingName}`);
          if (element) {
            if (setting.type === "checkbox")
              element.checked = settings[settingName] !== void 0 ? settings[settingName] : setting.default;
            else if (setting.type === "select") {
              let savedValue = settings[settingName] || setting.default;
              element.value = savedValue, element._dropdownApi && element._dropdownApi.setValue(savedValue);
            } else if (setting.type === "input")
              element.value = settings[settingName] || "";
            else if (setting.type === "file") {
              let fileUploadWrapper = settingsContent.querySelector(`[data-setting-name="${settingName}"]`), previewElement = settingsContent.querySelector(`#preview-${settingName}`), customLogoData = settings[settingName];
              if (fileUploadWrapper && fileUploadWrapper.rovalraFileUpload) {
                let { setFileName, showClear } = fileUploadWrapper.rovalraFileUpload;
                customLogoData ? (setFileName("custom_icon.png"), showClear(!0), previewElement && (previewElement.src = customLogoData, previewElement.style.display = "block")) : (setFileName(null), showClear(!1), previewElement && (previewElement.style.display = "none"));
              } else
                previewElement && settings[settingName] ? (previewElement.src = settings[settingName], previewElement.style.display = "block") : previewElement && (previewElement.src = "#", previewElement.style.display = "none");
            }
          }
          if (setting.childSettings)
            for (let [childName, childSetting] of Object.entries(setting.childSettings)) {
              let childElement = settingsContent.querySelector(`#${childName}`);
              if (childElement) {
                if (childSetting.type === "checkbox")
                  childElement.checked = settings[childName] !== void 0 ? settings[childName] : childSetting.default;
                else if (childSetting.type === "select") {
                  let savedValue = settings[childName] || childSetting.default;
                  childElement.value = savedValue, childElement._dropdownApi && childElement._dropdownApi.setValue(savedValue), childName === "robloxPreferredRegion" && childElement.options.length === 0 && Object.keys(REGIONS).forEach((regionCode) => {
                    let option = document.createElement("option");
                    option.value = regionCode, option.textContent = getFullRegionName(regionCode), childElement.appendChild(option);
                  });
                } else if (childSetting.type === "input")
                  childElement.value = settings[childName] || "";
                else if (childSetting.type === "number") {
                  let currentValue = settings[childName] !== void 0 ? settings[childName] : childSetting.default;
                  childElement.value = currentValue;
                  let toggleElement = settingsContent.querySelector(`#${childName}-enabled`);
                  if (toggleElement) {
                    let isEnabled2 = currentValue > 0;
                    toggleElement.checked = isEnabled2;
                  }
                } else if (childSetting.type === "file") {
                  let previewElement = settingsContent.querySelector(`#preview-${childName}`), clearButton = settingsContent.querySelector(`#clear-${childName}`);
                  previewElement && settings[childName] ? (previewElement.src = settings[childName], previewElement.style.display = "block", clearButton && (clearButton.style.display = "inline-block")) : previewElement && (previewElement.style.display = "none", clearButton && (clearButton.style.display = "none"));
                }
              }
            }
        }
      }
      updateConditionalSettingsVisibility(settingsContent, settings), document.querySelector(".permission-manager") && updateAllPermissionToggles();
    }
    settingsContent.querySelectorAll(".permission-toggle").forEach((toggle) => {
      toggle.addEventListener("change", handlePermissionToggle);
    });
  }, "initSettings");
  function applyDisabledState(settingName, parentElement, isDisabled, isPermissionRelated = !1) {
    let inputElement = parentElement.querySelector(`[data-setting-name="${settingName}"]`);
    if (!inputElement) return;
    let wrapper = inputElement.closest(".child-setting-item") || inputElement.closest(".setting");
    if (!wrapper) return;
    let toggleSwitch = wrapper.querySelector(".setting-controls > .toggle-switch");
    isDisabled && isPermissionRelated ? (toggleSwitch && (toggleSwitch.style.opacity = "0.5", toggleSwitch.style.pointerEvents = "none"), inputElement.type === "checkbox" && (inputElement.disabled = !0)) : isDisabled ? (wrapper.classList.add("disabled-setting"), wrapper.style.opacity = "0.5", wrapper.style.pointerEvents = "none", wrapper.querySelectorAll("input, select, button").forEach((el2) => {
      el2.disabled = !0;
    })) : (wrapper.classList.remove("disabled-setting"), wrapper.style.opacity = "1", wrapper.style.pointerEvents = "auto", wrapper.querySelectorAll("input, select, button").forEach((el2) => {
      el2.disabled = !1;
    }), toggleSwitch && (toggleSwitch.style.opacity = "1", toggleSwitch.style.pointerEvents = "auto"));
  }
  __name(applyDisabledState, "applyDisabledState");
  function updateConditionalSettingsVisibility(settingsContent, currentSettings) {
    if (!settingsContent || !currentSettings)
      return;
    let settingsToDisable = /* @__PURE__ */ new Set();
    for (let [settingName, isEnabled2] of Object.entries(currentSettings)) {
      let config = findSettingConfig(settingName);
      if (config && config.childSettings)
        for (let [childName, childConfig] of Object.entries(config.childSettings))
          childConfig.condition ? currentSettings[childConfig.condition.parent] !== childConfig.condition.value && settingsToDisable.add(childName) : config.type === "checkbox" && !isEnabled2 && settingsToDisable.add(childName);
    }
    settingsContent.querySelectorAll("[data-setting-name]").forEach((element) => {
      let settingName = element.dataset.settingName;
      applyDisabledState(settingName, settingsContent, settingsToDisable.has(settingName));
    }), settingsContent.querySelectorAll('input[type="checkbox"][data-controls-setting]').forEach((toggle) => {
      let controlledSettingName = toggle.dataset.controlsSetting, numberInputContainer = settingsContent.querySelector(`#${controlledSettingName}`)?.closest(".rovalra-number-input-container");
      if (numberInputContainer) {
        let isDisabled = !toggle.checked;
        numberInputContainer.style.opacity = isDisabled ? "0.5" : "1", numberInputContainer.style.pointerEvents = isDisabled ? "none" : "auto", numberInputContainer.querySelectorAll("input, button").forEach((el2) => el2.disabled = isDisabled);
      }
    });
  }
  __name(updateConditionalSettingsVisibility, "updateConditionalSettingsVisibility");
  async function hasPermission(permission) {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage({ action: "checkPermission", permission }, (response) => {
        chrome.runtime.lastError && (console.error("RoValra: Error checking permission:", chrome.runtime.lastError.message), resolve(!1)), resolve(response?.granted || !1);
      });
    });
  }
  __name(hasPermission, "hasPermission");
  async function requestPermission(permission) {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage({ action: "requestPermission", permission }, (response) => {
        chrome.runtime.lastError && (console.warn(`RoValra: Permission request for '${permission}' failed or was dismissed:`, chrome.runtime.lastError.message), resolve(!1)), resolve(response?.granted || !1);
      });
    });
  }
  __name(requestPermission, "requestPermission");
  async function revokePermission(permission) {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage({ action: "revokePermission", permission }, (response) => {
        chrome.runtime.lastError && (console.error(`RoValra: Failed to revoke '${permission}' permission:`, chrome.runtime.lastError.message), resolve(!1)), resolve(response?.revoked || !1);
      });
    });
  }
  __name(revokePermission, "revokePermission");
  async function updateAllPermissionToggles() {
    let settings = await loadSettings(), permissionManagers = document.querySelectorAll(".permission-manager");
    for (let manager of permissionManagers) {
      let permissionName = manager.dataset.permissionName, isGranted = await hasPermission(permissionName), toggle = manager.querySelector(".permission-toggle");
      toggle && (toggle.checked = isGranted);
    }
    for (let sectionName in SETTINGS_CONFIG) {
      let section = SETTINGS_CONFIG[sectionName];
      for (let [settingName, config] of Object.entries(section.settings))
        if (settings[settingName] === !0 && config.requiredPermissions) {
          let missingPerms = !1;
          for (let perm of config.requiredPermissions)
            if (!await hasPermission(perm)) {
              missingPerms = !0;
              break;
            }
          if (missingPerms) {
            console.log(`RoValra: Disabling '${settingName}' because required permissions are missing.`), await handleSaveSettings(settingName, !1), settings[settingName] = !1;
            let element = document.querySelector(`#${settingName}`);
            element && (element.checked = !1);
          }
        }
    }
    updateConditionalSettingsVisibility(document, settings);
  }
  __name(updateAllPermissionToggles, "updateAllPermissionToggles");
  async function handlePermissionToggle(event) {
    let toggle = event.target, permissionName = toggle.dataset.permissionName;
    toggle.checked ? await requestPermission(permissionName) || (toggle.checked = !1) : await revokePermission(permissionName) || (toggle.checked = !0), await updateAllPermissionToggles();
  }
  __name(handlePermissionToggle, "handlePermissionToggle");
  function initializeSettingsEventListeners() {
    chrome.runtime.onMessage.addListener((request) => {
      request.action === "permissionsUpdated" && updateAllPermissionToggles();
    }), document.addEventListener("change", async (event) => {
      let target = event.target, settingName = target.dataset.settingName;
      if (target.matches('input[type="checkbox"][data-controls-setting]')) {
        let controlledSettingName = target.dataset.controlsSetting, numberInput = document.getElementById(controlledSettingName), settingConfig = findSettingConfig(controlledSettingName), defaultValue = settingConfig?.default !== void 0 && settingConfig.default > 0 ? settingConfig.default : 1;
        numberInput && (target.checked ? (parseFloat(numberInput.value) || 0) === 0 && (numberInput.value = defaultValue, numberInput.dispatchEvent(new Event("change", { bubbles: !0 }))) : (numberInput.value = 0, numberInput.dispatchEvent(new Event("change", { bubbles: !0 }))));
      }
      if (!settingName || target.matches('input[type="file"]')) return;
      let savePromises = [], value;
      if (target.matches('input[type="checkbox"]')) {
        if (value = target.checked, value) {
          let settingConfig = findSettingConfig(settingName);
          if (settingConfig?.requiredPermissions) {
            let missingPermissions = [];
            for (let perm of settingConfig.requiredPermissions)
              await hasPermission(perm) || missingPermissions.push(perm);
            if (missingPermissions.length > 0 && !await requestPermission(missingPermissions)) {
              target.checked = !1, console.log(`RoValra: Permission denied for ${settingName}`);
              return;
            }
          }
          settingConfig?.exclusiveWith && settingConfig.exclusiveWith.forEach((exclusiveSettingName) => {
            let exclusiveElement = document.querySelector(`#${exclusiveSettingName}`);
            exclusiveElement?.checked && (exclusiveElement.checked = !1, savePromises.push(handleSaveSettings(exclusiveSettingName, !1)));
          });
        }
        savePromises.push(handleSaveSettings(settingName, value));
      } else if (target.matches("select"))
        value = target.value, savePromises.push(handleSaveSettings(settingName, value));
      else if (target.matches('input[type="text"], input:not([type])'))
        value = target.value.trim() === "" ? null : target.value, savePromises.push(handleSaveSettings(settingName, value));
      else if (target.matches('input[type="number"]')) {
        let min = parseFloat(target.min) || 0, max = parseFloat(target.max) || 1 / 0;
        value = Math.max(min, Math.min(max, parseFloat(target.value) || 0));
        let toggleElement = document.querySelector(`[data-controls-setting="${settingName}"]`);
        toggleElement && (toggleElement.checked = value > 0), savePromises.push(handleSaveSettings(settingName, value));
      } else
        return;
      savePromises.length !== 0 && Promise.all(savePromises).then(async () => {
        let settingsContent = document.querySelector("#setting-section-content");
        if (settingsContent) {
          let currentSettings = await loadSettings();
          updateConditionalSettingsVisibility(settingsContent, currentSettings), updateAllPermissionToggles(), settingName === "MemoryleakFixEnabled" && chrome.runtime.sendMessage({ action: "toggleMemoryLeakFix", enabled: currentSettings.MemoryleakFixEnabled });
        }
      }).catch((error) => {
        console.error("Error saving one or more settings:", error);
      });
    }), document.addEventListener("click", (event) => {
      let target = event.target, numberButton = target.closest(".rovalra-number-input-btn");
      if (numberButton) {
        let action = numberButton.dataset.action, inputId = numberButton.dataset.target, inputElement = document.getElementById(inputId);
        if (inputElement) {
          let step = parseFloat(inputElement.step) || 1, min = parseFloat(inputElement.min) || 0, max = parseFloat(inputElement.max) || 1 / 0, currentValue = parseFloat(inputElement.value) || 0;
          currentValue = action === "increment" ? currentValue + step : currentValue - step, inputElement.value = Math.max(min, Math.min(max, currentValue)), inputElement.dispatchEvent(new Event("change", { bubbles: !0 }));
        }
      }
      if (target.id?.startsWith("clear-")) {
        let settingName = target.dataset.settingName;
        if (settingName) {
          let fileUploadWrapper = document.querySelector(`[data-setting-name="${settingName}"]`);
          if (fileUploadWrapper && fileUploadWrapper.rovalraFileUpload) {
            let clearButton = fileUploadWrapper.querySelector(`#${settingName}-clear`);
            clearButton && clearButton.click();
          } else
            handleSaveSettings(settingName, null), target.style.display = "none";
        }
      }
    });
  }
  __name(initializeSettingsEventListeners, "initializeSettingsEventListeners");

  // src/content/core/ui/confirmationPrompt.js
  function showConfirmationPrompt({
    title = "Confirm Action",
    message = "Are you sure you want to proceed?",
    confirmText = "Confirm",
    cancelText = "Cancel",
    confirmType = "primary",
    cancelType = "secondary",
    onConfirm,
    onCancel
  }) {
    let bodyContent = document.createElement("div");
    bodyContent.innerHTML = purify.sanitize(`<p class="text-body" style="margin: 0; font-size: 14px; line-height: 1.5;">${message}</p>`);
    let isConfirmed = !1, confirmBtn = createButton(confirmText, confirmType, {
      onClick: /* @__PURE__ */ __name(() => {
        isConfirmed = !0, close(), onConfirm && onConfirm();
      }, "onClick")
    }), cancelBtn = createButton(cancelText, cancelType, {
      onClick: /* @__PURE__ */ __name(() => {
        close();
      }, "onClick")
    }), { close } = createOverlay({
      title,
      bodyContent,
      actions: [cancelBtn, confirmBtn],
      maxWidth: "400px",
      showLogo: !0,
      onClose: /* @__PURE__ */ __name(() => {
        !isConfirmed && onCancel && onCancel();
      }, "onClose")
    });
  }
  __name(showConfirmationPrompt, "showConfirmationPrompt");

  // src/content/core/settings/generateSettings.js
  function createClearStorageButton(storageKey, inputElement, settingType) {
    let btn = createButton("", "secondary");
    btn.classList.remove("btn-control-md"), btn.classList.add("btn-control-xs"), btn.style.marginLeft = "0px", btn.style.display = "inline-flex", btn.style.alignItems = "center", btn.style.justifyContent = "center", btn.style.width = "32px", btn.style.height = "32px";
    let icon = document.createElement("div");
    return icon.style.width = "20px", icon.style.height = "20px", icon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="100%" height="100%"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"></path></svg>', btn.appendChild(icon), addTooltip(btn, "Clear Storage", { position: "top" }), btn.onclick = (e) => {
      e.preventDefault(), showConfirmationPrompt({
        title: "Clear Storage",
        message: "Are you sure you want to clear the storage for this setting? This will clear stuff this feature stored for its functionality. This cannot be reverted.",
        confirmText: "Clear",
        confirmType: "secondary",
        cancelType: "primary",
        onConfirm: /* @__PURE__ */ __name(() => {
          chrome.storage.local.remove(storageKey, () => {
            if (settingType === "file" && inputElement) {
              let uploadApi = inputElement._uploadApi || inputElement.rovalraFileUpload;
              uploadApi && (uploadApi.setFileName(null), uploadApi.showClear(!1), uploadApi.clearPreview());
            }
          });
        }, "onConfirm")
      });
    }, btn;
  }
  __name(createClearStorageButton, "createClearStorageButton");
  function findSettingConfig(settingName) {
    for (let category of Object.values(SETTINGS_CONFIG))
      for (let [parentSettingName, parentSettingDef] of Object.entries(category.settings)) {
        if (parentSettingName === settingName)
          return parentSettingDef;
        if (parentSettingDef.childSettings && parentSettingDef.childSettings[settingName])
          return parentSettingDef.childSettings[settingName];
      }
    return null;
  }
  __name(findSettingConfig, "findSettingConfig");
  function generateSettingInput(settingName, setting, REGIONS6 = {}) {
    let theme = getCurrentTheme();
    if (setting.type === "checkbox") {
      let toggleClass = setting.disabled ? "toggle-switch1" : "toggle-switch", label = document.createElement("label");
      return label.className = toggleClass, label.innerHTML = purify.sanitize(`
            <input type="checkbox" id="${settingName}" data-setting-name="${settingName}"${setting.disabled ? " disabled" : ""}>
            <span class="${setting.disabled ? "slider1" : "slider"}"></span>`), label;
    } else if (setting.type === "select") {
      let dropdownOptions = [];
      if (setting.options === "REGIONS") {
        dropdownOptions.push({ value: "AUTO", label: getFullRegionName("AUTO") });
        let regionsByContinent = {};
        Object.keys(REGIONS6).filter((rc) => rc !== "AUTO").forEach((regionCode) => {
          let region = REGIONS6[regionCode], countryCode = regionCode.split("-")[0], continent = getContinent(countryCode);
          regionsByContinent[continent] || (regionsByContinent[continent] = []), regionsByContinent[continent].push({
            value: regionCode,
            label: getFullRegionName(regionCode),
            group: continent
          });
        }), Object.values(regionsByContinent).forEach((regions) => {
          regions.sort((a, b2) => a.label.localeCompare(b2.label));
        }), ["North America", "South America", "Europe", "Asia", "Africa", "Oceania", "Other"].forEach((continent) => {
          regionsByContinent[continent] && dropdownOptions.push(...regionsByContinent[continent]);
        });
      } else Array.isArray(setting.options) && (dropdownOptions = setting.options);
      let dropdown = createDropdown({
        items: dropdownOptions,
        initialValue: setting.default,
        showFlags: setting.showFlags || !1,
        onValueChange: /* @__PURE__ */ __name((value) => {
          let hiddenSelect2 = document.getElementById(settingName);
          hiddenSelect2 && (hiddenSelect2.value = value, hiddenSelect2.dispatchEvent(new Event("change", { bubbles: !0 })));
        }, "onValueChange")
      }), tempDiv = document.createElement("div");
      tempDiv.style.position = "absolute", tempDiv.style.visibility = "hidden", tempDiv.style.height = "auto", tempDiv.style.width = "auto", tempDiv.style.whiteSpace = "nowrap", tempDiv.style.fontSize = "14px", tempDiv.style.fontWeight = "500", document.body.appendChild(tempDiv);
      let maxItemWidth = 0;
      dropdownOptions.forEach((item) => {
        tempDiv.textContent = item.label, maxItemWidth = Math.max(maxItemWidth, tempDiv.clientWidth);
      }), document.body.removeChild(tempDiv);
      let hiddenSelect = document.createElement("select");
      hiddenSelect.id = settingName, hiddenSelect.dataset.settingName = settingName, hiddenSelect.style.display = "none", dropdownOptions.forEach((opt) => {
        let option = document.createElement("option");
        option.value = opt.value, option.textContent = opt.label, hiddenSelect.appendChild(option);
      });
      let wrapper = document.createElement("div");
      return wrapper.style.marginLeft = "auto", maxItemWidth > 0 && (dropdown.element.style.minWidth = `${maxItemWidth + 60}px`), hiddenSelect._dropdownApi = dropdown, wrapper.append(dropdown.element, hiddenSelect), wrapper;
    } else if (setting.type === "input") {
      let { container, input } = createStyledInput({
        id: settingName,
        label: setting.placeholder || "Enter value",
        placeholder: " "
      });
      return input.dataset.settingName = settingName, container.style.marginLeft = "auto", container.style.width = "200px", container;
    } else if (setting.type === "file") {
      let fileUpload = createFileUpload({
        id: settingName,
        compress: setting.compress !== !1,
        compressSettingName: setting.compressSettingName,
        onFileSelect: /* @__PURE__ */ __name((base64Data) => {
          handleSaveSettings(settingName, base64Data);
        }, "onFileSelect"),
        onFileClear: /* @__PURE__ */ __name(() => {
          handleSaveSettings(settingName, null);
        }, "onFileClear")
      });
      return fileUpload.element.dataset.settingName = settingName, fileUpload.element._uploadApi = fileUpload, fileUpload.element;
    } else if (setting.type === "number") {
      let wrapper = document.createElement("div");
      return wrapper.className = "rovalra-number-input-wrapper", wrapper.style.cssText = "display: flex; align-items: center; gap: 12px; margin-left: auto;", wrapper.innerHTML = purify.sanitize(`
            <div class="rovalra-number-input-container" style="display: flex; align-items: center; gap: 8px; background-color: var(--rovalra-container-background-color); padding: 4px; border-radius: 8px;">
                <button type="button" class="rovalra-number-input-btn btn-control-xs" data-action="decrement" data-target="${settingName}" style="width: 32px; height: 32px; padding: 0; line-height: 0; border: none;">
                    <svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1phnduy" focusable="false" aria-hidden="true" viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--rovalra-main-text-color);"><path d="M19 13H5v-2h14z"></path></svg>
                </button>
                <input type="number" id="${settingName}" data-setting-name="${settingName}" class="setting-number-input" 
                       min="${setting.min || 0}" max="${setting.max || 100}" step="${setting.step || 1}"
                       style="width: 60px; text-align: center; -moz-appearance: textfield; appearance: textfield; border-radius: 6px; border: 1px solid var(--rovalra-border-color); background-color: var(--rovalra-main-background-color); color: var(--rovalra-main-text-color); padding: 8px; font-weight: 500;">
                <button type="button" class="rovalra-number-input-btn btn-control-xs" data-action="increment" data-target="${settingName}" style="width: 32px; height: 32px; padding: 0; line-height: 0; border: none;">
                    <svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1phnduy" focusable="false" aria-hidden="true" viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--rovalra-main-text-color);"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"></path></svg>
                </button>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="${settingName}-enabled" data-setting-name="${settingName}-enabled" data-controls-setting="${settingName}">
                <span class="slider"></span>
            </label>`), wrapper;
    }
    return document.createElement("div");
  }
  __name(generateSettingInput, "generateSettingInput");
  function generateSingleSettingHTML(settingName, setting, REGIONS6 = {}) {
    let themeColors = THEME_CONFIG[getCurrentTheme()] || THEME_CONFIG.dark, settingContainer = document.createElement("div");
    settingContainer.className = "setting", settingContainer.id = `setting-container-${settingName}`;
    let controlsContainer = document.createElement("div");
    controlsContainer.className = "setting-controls";
    let label = document.createElement("label");
    if (label.textContent = setting.label, controlsContainer.appendChild(label), setting.experimental) {
      let experimentalPill = createPill("Experimental", setting.experimental, "experimental");
      controlsContainer.appendChild(experimentalPill);
    }
    if (setting.beta) {
      let betaPill = createPill("Beta", setting.beta, "beta");
      controlsContainer.appendChild(betaPill);
    }
    if (setting.deprecated) {
      let deprecatedPill = createPill("Deprecated", setting.deprecated, "deprecated");
      controlsContainer.appendChild(deprecatedPill);
    }
    let inputElement = generateSettingInput(settingName, setting, REGIONS6);
    setting.storageKey && controlsContainer.appendChild(createClearStorageButton(setting.storageKey, inputElement, setting.type)), controlsContainer.appendChild(inputElement), settingContainer.appendChild(controlsContainer);
    let divider = document.createElement("div");
    if (divider.className = "setting-label-divider", settingContainer.appendChild(divider), setting.description && (Array.isArray(setting.description) ? setting.description : [String(setting.description)]).forEach((desc) => {
      let descElement = document.createElement("div");
      descElement.className = "setting-description", descElement.innerHTML = purify.sanitize(parseMarkdown(desc, themeColors)), settingContainer.appendChild(descElement);
    }), setting.requiredPermissions && setting.requiredPermissions.length > 0) {
      let permissionManager = document.createElement("div");
      permissionManager.className = "permission-manager", permissionManager.dataset.permissionName = setting.requiredPermissions[0], permissionManager.dataset.permissionFor = settingName, permissionManager.style.cssText = "margin-top: 10px; padding: 10px; background-color: var(--rovalra-container-background-color, rgba(0,0,0,0.1)); border-radius: 8px;";
      let container = document.createElement("div");
      container.style.cssText = "display: flex; align-items: center; justify-content: space-between;";
      let text2 = document.createElement("span");
      text2.textContent = `Enable ${setting.requiredPermissions[0]} permission`, text2.style.cssText = "font-size: 15px; color: var(--rovalra-main-text-color); font-weight: 400;";
      let label2 = document.createElement("label");
      label2.className = "toggle-switch", label2.innerHTML = purify.sanitize(`
            <input type="checkbox" class="permission-toggle" data-permission-name="${setting.requiredPermissions[0]}">
            <span class="slider"></span>`), container.appendChild(text2), container.appendChild(label2), permissionManager.appendChild(container), settingContainer.appendChild(permissionManager);
    }
    if (setting.type === "file") {
      let uploadElement = inputElement, uploadApi = uploadElement._uploadApi || uploadElement.rovalraFileUpload;
      if (uploadApi) {
        let previewElement = uploadApi.getPreviewElement();
        settingContainer.appendChild(previewElement), chrome.storage.local.get([settingName], (result) => {
          if (result[settingName]) {
            let base64Data = result[settingName];
            if (!base64Data || typeof base64Data != "string" || !base64Data.startsWith("data:image/")) {
              console.warn("Invalid image data detected for", settingName, "- clearing"), chrome.storage.local.set({ [settingName]: null });
              return;
            }
            let size = Math.round(base64Data.length * 3 / 4);
            uploadApi.setPreview(base64Data, size);
          }
        });
      } else
        console.error("Upload API not found for", settingName);
    }
    if (setting.childSettings)
      for (let [childName, childSetting] of Object.entries(setting.childSettings)) {
        let separator = document.createElement("div");
        separator.className = "child-setting-separator", settingContainer.appendChild(separator);
        let childContainer = document.createElement("div");
        childContainer.className = "child-setting-item", childContainer.id = `setting-${childName}`, childSetting.condition && (childContainer.style.display = "none");
        let childControls = document.createElement("div");
        childControls.className = "setting-controls";
        let childLabel = document.createElement("label");
        if (childLabel.textContent = childSetting.label, childControls.appendChild(childLabel), childSetting.experimental) {
          let experimentalPill = createPill("Experimental", childSetting.experimental, "experimental");
          childControls.appendChild(experimentalPill);
        }
        if (childSetting.beta) {
          let betaPill = createPill("Beta", childSetting.beta, "beta");
          childControls.appendChild(betaPill);
        }
        if (childSetting.deprecated) {
          let deprecatedPill = createPill("Deprecated", childSetting.deprecated, "deprecated");
          childControls.appendChild(deprecatedPill);
        }
        let childInput = generateSettingInput(childName, childSetting, REGIONS6);
        childSetting.storageKey && childControls.appendChild(createClearStorageButton(childSetting.storageKey, childInput, childSetting.type)), childControls.appendChild(childInput), childContainer.appendChild(childControls);
        let childDivider = document.createElement("div");
        if (childDivider.className = "setting-label-divider", childContainer.appendChild(childDivider), childSetting.description && (Array.isArray(childSetting.description) ? childSetting.description : [String(childSetting.description)]).forEach((desc) => {
          let childDescElement = document.createElement("div");
          childDescElement.className = "setting-description", childDescElement.innerHTML = purify.sanitize(parseMarkdown(desc, themeColors)), childContainer.appendChild(childDescElement);
        }), childSetting.type === "file") {
          let uploadElement = childInput, uploadApi = uploadElement._uploadApi || uploadElement.rovalraFileUpload;
          if (uploadApi) {
            let previewElement = uploadApi.getPreviewElement();
            childContainer.appendChild(previewElement), chrome.storage.local.get([childName], (result) => {
              if (result[childName]) {
                let base64Data = result[childName];
                if (!base64Data || typeof base64Data != "string" || !base64Data.startsWith("data:image/")) {
                  console.warn("Invalid image data detected for", childName, "- clearing"), chrome.storage.local.set({ [childName]: null });
                  return;
                }
                let size = Math.round(base64Data.length * 3 / 4);
                uploadApi.setPreview(base64Data, size);
              }
            });
          } else
            console.error("Child upload API not found for", childName);
        }
        settingContainer.appendChild(childContainer);
      }
    return settingContainer;
  }
  __name(generateSingleSettingHTML, "generateSingleSettingHTML");
  function generateSettingsUI(section, REGIONS6 = {}) {
    let fragment = document.createDocumentFragment(), sectionConfig = SETTINGS_CONFIG[section];
    if (!sectionConfig) return fragment;
    for (let [settingName, setting] of Object.entries(sectionConfig.settings))
      fragment.appendChild(generateSingleSettingHTML(settingName, setting, REGIONS6));
    return fragment;
  }
  __name(generateSettingsUI, "generateSettingsUI");

  // src/content/core/settings/portSettings.js
  var ROVALRA_SETTINGS_UUID = "a1b2c3d4-e5f6-7890-1234-567890abcdef";
  async function exportSettings() {
    try {
      chrome.storage.local.get("rovalra_settings", (result) => {
        if (chrome.runtime.lastError) {
          console.error("Failed to export settings:", chrome.runtime.lastError), alert("Error exporting settings. Check the console for details.");
          return;
        }
        let allSettings = result.rovalra_settings || {}, sanitizedSettings;
        try {
          sanitizedSettings = sanitizeSettings(allSettings, SETTINGS_CONFIG);
        } catch (error) {
          console.error("Failed to sanitize settings for export:", error), alert("Error sanitizing settings for export. Check the console for details.");
          return;
        }
        let settingsToExport = {
          rovalra_uuid: ROVALRA_SETTINGS_UUID,
          settings: sanitizedSettings
        }, blob = new Blob([JSON.stringify(settingsToExport, null, 2)], { type: "application/json" }), url = URL.createObjectURL(blob), a = document.createElement("a");
        a.href = url, a.download = "RoValraExportedSettings.json", document.body.appendChild(a), a.click(), document.body.removeChild(a), URL.revokeObjectURL(url);
      });
    } catch (error) {
      console.error("Error in exportSettings:", error), alert("An unexpected error occurred during export.");
    }
  }
  __name(exportSettings, "exportSettings");
  async function importSettings() {
    try {
      let input = document.createElement("input");
      input.type = "file", input.accept = ".json", input.onchange = (e) => {
        let file = e.target.files[0];
        if (!file)
          return;
        let reader = new FileReader();
        reader.onload = (readerEvent) => {
          try {
            let content = readerEvent.target.result, importedData = JSON.parse(content);
            if (importedData.rovalra_uuid !== ROVALRA_SETTINGS_UUID) {
              alert("This does not appear to be a valid RoValra settings file.");
              return;
            }
            if (importedData.settings && typeof importedData.settings == "object") {
              let sanitizedSettings;
              try {
                sanitizedSettings = sanitizeSettings(importedData.settings, SETTINGS_CONFIG);
              } catch (error) {
                console.error("Failed to sanitize imported settings:", error), alert("Error: The imported settings file contains invalid or potentially dangerous data.");
                return;
              }
              if (JSON.stringify(sanitizedSettings).length > 1024 * 1024) {
                alert("Error: Settings file is too large. Maximum size is 1MB.");
                return;
              }
              chrome.storage.local.set(sanitizedSettings, () => {
                chrome.runtime.lastError ? (console.error("Failed to import settings:", chrome.runtime.lastError), alert("Error importing settings. Check the console for details.")) : chrome.storage.local.set({ rovalra_settings: sanitizedSettings }, () => {
                  location.reload();
                });
              });
            } else
              alert("The settings file is malformed.");
          } catch (error) {
            console.error("Error parsing or processing settings file:", error), alert("Could not read the settings file. It might be corrupted or in the wrong format.");
          }
        }, reader.readAsText(file);
      }, input.click();
    } catch (error) {
      console.error("Error in importSettings:", error), alert("An unexpected error occurred during import.");
    }
  }
  __name(importSettings, "importSettings");
  function createExportImportButtons() {
    let exportButton = createButton("Export Settings", "secondary", {
      id: "export-rovalra-settings"
    }), importButton = createButton("Import Settings", "secondary", {
      id: "import-rovalra-settings"
    }), container = document.createElement("div");
    return container.style.cssText = "display: flex; gap: 10px;", container.appendChild(exportButton), container.appendChild(importButton), container;
  }
  __name(createExportImportButtons, "createExportImportButtons");

  // src/content/core/settings/ui/settingsbutton.js
  var rovalraButtonAdded = !1;
  function addCustomButton2(debouncedAddPopoverButton2) {
    if (!window.location.href.includes("/my/account") || window.location.href.includes("?rovalra="))
      return;
    let menuList = document.querySelector('ul.menu-vertical[role="tablist"]');
    if (!menuList) {
      debouncedAddPopoverButton2 && debouncedAddPopoverButton2();
      return;
    }
    let divider = menuList.querySelector("li.rbx-divider.thick-height");
    if (divider)
      divider.style.width = "100%";
    else {
      let lastMenuItem = menuList.querySelector('li.menu-option[role="tab"]:last-of-type');
      if (!lastMenuItem) {
        debouncedAddPopoverButton2 && debouncedAddPopoverButton2();
        return;
      }
      let newDivider = document.createElement("li");
      newDivider.classList.add("rbx-divider", "thick-height"), newDivider.style.width = "100%", newDivider.style.height = "2px", lastMenuItem.insertAdjacentElement("afterend", newDivider), divider = newDivider;
    }
    if (rovalraButtonAdded) return;
    if (menuList.querySelector('li.menu-option > a > span.font-caption-header[textContent="RoValra Settings"]')) {
      rovalraButtonAdded = !0;
      return;
    }
    let assets3 = getAssets(), newButtonListItem = document.createElement("li");
    newButtonListItem.classList.add("menu-option"), newButtonListItem.setAttribute("role", "tab");
    let newButtonLink = document.createElement("a");
    newButtonLink.href = "https://www.roblox.com/my/account?rovalra=info", newButtonLink.classList.add("menu-option-content"), newButtonLink.style.cursor = "pointer", newButtonLink.style.display = "flex", newButtonLink.style.alignItems = "center", newButtonLink.addEventListener("click", (e) => {
      e.preventDefault(), window.location.search.includes("rovalra=") ? window.location.reload() : window.location.href = "https://www.roblox.com/my/account?rovalra=info#!/info";
    });
    let newButtonSpan = document.createElement("span");
    newButtonSpan.classList.add("font-caption-header"), newButtonSpan.textContent = "RoValra Settings", newButtonSpan.style.fontSize = "12px";
    let logo = document.createElement("img");
    logo.src = assets3.rovalraIcon, logo.style.width = "15px", logo.style.height = "15px", logo.style.marginRight = "5px", logo.style.verticalAlign = "middle", newButtonLink.append(logo, newButtonSpan), newButtonListItem.appendChild(newButtonLink), divider.insertAdjacentElement("afterend", newButtonListItem), rovalraButtonAdded = !0;
  }
  __name(addCustomButton2, "addCustomButton");
  function addPopoverButton() {
    if (window.rovalraPopoverButtonAdded) return;
    let popoverMenu = document.getElementById("settings-popover-menu");
    if (!popoverMenu) return;
    if (popoverMenu.querySelector('a[href*="?rovalra=info"]')) {
      window.rovalraPopoverButtonAdded = !0;
      return;
    }
    let assets3 = getAssets(), newButtonListItem = document.createElement("li"), newButtonLink = document.createElement("a");
    newButtonLink.className = "rbx-menu-item", newButtonLink.href = "https://www.roblox.com/my/account?rovalra=info", Object.assign(newButtonLink.style, { display: "flex", alignItems: "center", gap: "8px" }), newButtonLink.addEventListener("click", (e) => {
      e.preventDefault(), window.location.search.includes("rovalra=") ? window.location.reload() : window.location.href = "https://www.roblox.com/my/account?rovalra=info";
    });
    let logo = document.createElement("img");
    logo.src = assets3.rovalraIcon, Object.assign(logo.style, { width: "18px", height: "18px" });
    let buttonText = document.createTextNode("RoValra Settings");
    newButtonLink.append(logo, buttonText), newButtonListItem.appendChild(newButtonLink);
    let nativeSettingsLink = popoverMenu.querySelector('a.rbx-menu-item[href="/my/account"]');
    nativeSettingsLink?.parentElement ? nativeSettingsLink.parentElement.before(newButtonListItem) : popoverMenu.prepend(newButtonListItem), window.rovalraPopoverButtonAdded = !0;
  }
  __name(addPopoverButton, "addPopoverButton");

  // src/content/core/settings/ui/settingui.js
  function ensureDeveloperSettings() {
    SETTINGS_CONFIG.Developer || addDeveloperTab({});
  }
  __name(ensureDeveloperSettings, "ensureDeveloperSettings");
  async function buildSettingsPage({ handleSearch: handleSearch2, debounce: debounce4, loadTabContent, buttonData: buttonData2, REGIONS: REGIONS6, initSettings: initSettings2 }) {
    let devTabAdded = (await new Promise((resolve) => {
      chrome.storage.local.get("alwaysShowDeveloperSettings", resolve);
    })).alwaysShowDeveloperSettings === !0;
    devTabAdded && ensureDeveloperSettings();
    let assets3 = getAssets(), containerMain = document.querySelector("main.container-main");
    if (!containerMain)
      return console.error("RoValra: Main container not found. Cannot build settings page."), {};
    let roproThemeFrame = containerMain.querySelector("#roproThemeFrame"), roproThemeFrameHTML = roproThemeFrame ? roproThemeFrame.outerHTML : "";
    containerMain.innerHTML = roproThemeFrameHTML;
    let reactUserAccountBaseDiv = document.createElement("div");
    reactUserAccountBaseDiv.id = "react-user-account-base";
    let contentDiv = document.createElement("div");
    contentDiv.classList.add("content"), contentDiv.id = "content";
    let userAccountDiv = document.createElement("div");
    userAccountDiv.classList.add("row", "page-content", "new-username-pwd-rule"), userAccountDiv.id = "user-account";
    let headerContainer = document.createElement("div");
    headerContainer.style.cssText = "display: flex; align-items: center; justify-content: center; margin-bottom: 20px;";
    let rovalraIcon = document.createElement("img");
    rovalraIcon.src = assets3.rovalraIcon, rovalraIcon.style.cssText = "width: 35px; height: 35px; margin-left: 5px;  user-select: none;";
    let rovalraHeader = document.createElement("h1");
    rovalraHeader.textContent = "RoValra Settings", rovalraHeader.style.margin = "0", rovalraHeader.style.color = "var(--rovalra-main-text-color)", headerContainer.appendChild(rovalraHeader), rovalraHeader.appendChild(rovalraIcon);
    let settingsContainer = document.createElement("div");
    settingsContainer.id = "settings-container", userAccountDiv.appendChild(reactUserAccountBaseDiv), reactUserAccountBaseDiv.appendChild(headerContainer), reactUserAccountBaseDiv.appendChild(settingsContainer), contentDiv.appendChild(userAccountDiv), containerMain.appendChild(contentDiv), contentDiv.style.cssText = "width: 100% !important; height: auto !important; border-radius: 10px !important; overflow: hidden !important; padding-bottom: 25px !important; padding-top: 25px !important; min-height: 800px !important; position: relative !important;", userAccountDiv && (userAccountDiv.style.cssText = "display: flex !important; flex-direction: column !important; align-items: center !important; justify-content: center !important; padding-left: 0px !important; padding-right: 0px !important; margin-left: auto !important; margin-right: auto !important; width: 100% !important;");
    let mobileMenuContainer = document.createElement("div");
    mobileMenuContainer.id = "rovalra-mobile-menu-container", mobileMenuContainer.style.width = "100%", settingsContainer.appendChild(mobileMenuContainer);
    let renderMobileDropdown = /* @__PURE__ */ __name(() => {
      mobileMenuContainer.innerHTML = "";
      let initialTab = new URLSearchParams(window.location.search).get("rovalra") || "info", dropdownItems = [];
      buttonData2.filter((item) => item.text === "Info" || item.text === "Credits" || item.text === "Donator Perks").forEach((item) => {
        dropdownItems.push({
          value: item.text.toLowerCase(),
          label: item.text
        });
      }), Object.keys(SETTINGS_CONFIG).forEach((sectionName) => {
        dropdownItems.push({
          value: sectionName.toLowerCase(),
          label: SETTINGS_CONFIG[sectionName].title
        });
      });
      let mobileDropdown = createDropdown({
        items: dropdownItems,
        initialValue: initialTab,
        placeholder: "Select Setting...",
        onValueChange: /* @__PURE__ */ __name(async (value) => {
          let newUrl = new URL(window.location.href);
          newUrl.searchParams.get("rovalra") !== value && (newUrl.searchParams.set("rovalra", value), history.pushState(null, "", newUrl.pathname + newUrl.search));
          let selectedItem = dropdownItems.find((item) => item.value === value);
          if (selectedItem) {
            let textSpan = mobileDropdown.trigger.querySelector(".text-truncate-split span") || mobileDropdown.trigger.querySelector("span");
            textSpan && (textSpan.textContent = selectedItem.label);
          }
          await loadTabContent(value), stripInlineStyles(document.getElementById("content-container"));
        }, "onValueChange")
      });
      mobileDropdown.element.style.width = "100%", mobileDropdown.element.style.display = "block", mobileDropdown.trigger.style.width = "100%", mobileMenuContainer.appendChild(mobileDropdown.element);
      let currentItem = dropdownItems.find((item) => item.value === initialTab);
      if (currentItem) {
        let textSpan = mobileDropdown.trigger.querySelector(".text-truncate-split span") || mobileDropdown.trigger.querySelector("span");
        textSpan && (textSpan.textContent = currentItem.label);
      }
    }, "renderMobileDropdown");
    renderMobileDropdown();
    let uiContainer = document.createElement("div");
    uiContainer.id = "rovalra-ui-container", uiContainer.style.cssText = "display: flex; flex-direction: row; gap: 10px; align-items: flex-start; position: relative; overflow: visible; width: 100%; justify-content: flex-start;", settingsContainer.appendChild(uiContainer), settingsContainer.style.cssText = "display: block; position: relative; overflow: visible; width: 100%;", settingsContainer.insertAdjacentElement("afterbegin", rovalraHeader), uiContainer.innerHTML = "";
    let contentContainer = document.createElement("div");
    contentContainer.id = "content-container", contentContainer.style.cssText = `
        width: 800px; 
        flex-shrink: 0;
        overflow-y: auto; 
        overflow-x: auto; 
        padding-left: 0px; 
        position: relative; 
        margin-top: 7px; 
        background-color: transparent; 
        min-width: 0;
    `;
    let unifiedMenu = createUnifiedMenu({ handleSearch: handleSearch2, debounce: debounce4, buttonData: buttonData2, devTabAdded, loadTabContent, REGIONS: REGIONS6, initSettings: initSettings2 });
    return rovalraIcon.addEventListener("click", () => {
      let rovalraIconClickCount = (rovalraIcon.dataset.clickCount || 0) * 1;
      rovalraIconClickCount++, rovalraIcon.dataset.clickCount = rovalraIconClickCount, rovalraIconClickCount >= 10 && !devTabAdded && (devTabAdded = !0, ensureDeveloperSettings(), addDeveloperTab({
        REGIONS: REGIONS6,
        initSettings: initSettings2,
        menuList: unifiedMenu,
        loadTabContent,
        renderMobileDropdown
      }));
    }), uiContainer.appendChild(unifiedMenu), uiContainer.appendChild(contentContainer), { rovalraHeader, settingsContainer, contentDiv, userAccountDiv };
  }
  __name(buildSettingsPage, "buildSettingsPage");
  function stripInlineStyles(container) {
    if (!container) return;
    let selectors = [".setting", ".setting-description", ".setting-controls", ".setting-label-divider", "label", "span", "div"];
    container.querySelectorAll(selectors.join(",")).forEach((el2) => {
      el2.style.color && el2.style.removeProperty("color"), el2.style.backgroundColor && el2.style.removeProperty("background-color");
    });
  }
  __name(stripInlineStyles, "stripInlineStyles");
  function createUnifiedMenu({ handleSearch: handleSearch2, debounce: debounce4, buttonData: buttonData2, devTabAdded, loadTabContent, REGIONS: REGIONS6, initSettings: initSettings2 }) {
    let menuList = document.createElement("ul");
    menuList.id = "unified-menu", menuList.className = "menu-vertical rovalra-sidebar", menuList.setAttribute("role", "tablist");
    let searchListItem = document.createElement("li");
    searchListItem.id = "search-tab", searchListItem.className = "menu-option search-container", searchListItem.style.padding = "0px", searchListItem.style.marginBottom = "10px";
    let searchInput = document.createElement("input");
    searchInput.type = "search", searchInput.id = "settings-search-input", searchInput.placeholder = "Search Settings...", searchInput.style.cssText = "width: 89%; padding: 8px; border-radius: 0px; font-size: 14px; border: 0px solid var(--rovalra-container-background-color) !important; background: transparent !important; color: var(--rovalra-main-text-color) !important;";
    let performSearch = debounce4((query) => {
      try {
        handleSearch2({
          target: {
            value: query
          }
        });
      } catch (error) {
        console.warn("RoValra: Search handler failed:", error);
      }
    }, 300);
    searchInput.addEventListener("input", (e) => {
      performSearch(e.target.value);
    }), searchInput.addEventListener("focus", () => {
      document.querySelectorAll("#unified-menu .menu-option-content").forEach((el2) => {
        el2.classList.remove("active"), el2.removeAttribute("aria-current");
      });
      let newUrl = new URL(window.location.href);
      newUrl.searchParams.get("rovalra") !== "search" && (newUrl.searchParams.set("rovalra", "search"), history.pushState(null, "", newUrl.pathname + newUrl.search));
    }), searchListItem.appendChild(searchInput), menuList.appendChild(searchListItem), buttonData2.filter((item) => item.text === "Info" || item.text === "Credits" || item.text === "Donator Perks").forEach((item) => {
      let listItem = document.createElement("li");
      listItem.id = `${item.text.toLowerCase()}-tab`, listItem.dataset.text = item.text, listItem.className = "menu-option", listItem.setAttribute("role", "tab");
      let link = document.createElement("a");
      link.className = "menu-option-content", link.href = `#!/${item.text.toLowerCase()}`;
      let span = document.createElement("span");
      span.className = "font-caption-header", span.textContent = item.text, link.appendChild(span), listItem.appendChild(link), menuList.appendChild(listItem), link.addEventListener("click", async (e) => {
        e.preventDefault();
        let newHashKey = item.text.toLowerCase(), newUrl = new URL(window.location.href);
        newUrl.searchParams.get("rovalra") !== newHashKey && (newUrl.searchParams.set("rovalra", newHashKey), history.pushState(null, "", newUrl.pathname + newUrl.search)), await loadTabContent(newHashKey), stripInlineStyles(document.getElementById("content-container"));
        let dropdownTrigger = document.querySelector("#rovalra-mobile-menu-container .rovalra-dropdown-trigger span");
        dropdownTrigger && (dropdownTrigger.textContent = item.text);
      });
    });
    let separator = document.createElement("li");
    return separator.classList.add("menu-separator"), separator.style.cssText = "height: 1px; background-color: var(--rovalra-secondary-text-color); opacity: 0.3; margin: 10px 0;", separator.setAttribute("role", "separator"), menuList.appendChild(separator), Object.keys(SETTINGS_CONFIG).forEach((sectionName) => {
      if (sectionName === "Developer" && !devTabAdded) return;
      let listItem = createSidebarItem(sectionName, SETTINGS_CONFIG[sectionName].title, loadTabContent);
      menuList.appendChild(listItem);
    }), menuList;
  }
  __name(createUnifiedMenu, "createUnifiedMenu");
  function createSidebarItem(sectionName, title, loadTabContent) {
    let listItem = document.createElement("li");
    listItem.id = `${sectionName.toLowerCase()}-tab`, listItem.dataset.section = sectionName, listItem.setAttribute("role", "tab"), listItem.classList.add("menu-option");
    let link = document.createElement("a");
    link.classList.add("menu-option-content"), link.href = `#!/${sectionName.toLowerCase()}`;
    let span = document.createElement("span");
    return span.classList.add("font-caption-header"), span.textContent = title, link.appendChild(span), listItem.appendChild(link), link.addEventListener("click", async function(e) {
      e.preventDefault(), document.querySelectorAll("#unified-menu .menu-option-content").forEach((el2) => {
        el2.classList.remove("active"), el2.removeAttribute("aria-current");
      }), this.classList.add("active"), this.setAttribute("aria-current", "page");
      let newUrl = new URL(window.location.href);
      newUrl.searchParams.get("rovalra") !== sectionName.toLowerCase() && (newUrl.searchParams.set("rovalra", sectionName.toLowerCase()), history.pushState(null, "", newUrl.pathname + newUrl.search)), await loadTabContent(sectionName), stripInlineStyles(document.getElementById("content-container"));
      let dropdownTrigger = document.querySelector("#rovalra-mobile-menu-container .rovalra-dropdown-trigger span");
      dropdownTrigger && (dropdownTrigger.textContent = title);
    }), listItem;
  }
  __name(createSidebarItem, "createSidebarItem");
  function addDeveloperTab({ menuList, loadTabContent, renderMobileDropdown }) {
    if (SETTINGS_CONFIG.Developer = {
      title: "Developer",
      settings: {
        info: {
          label: ["Developer Settings"],
          description: ["These are features used mostly to develop rovalra, if you don't know what your doing dont touch them."],
          type: "yay"
        },
        alwaysShowDeveloperSettings: {
          label: ["Always show developer settings tab"],
          description: ["This will make the developer settings tab always show. So you dont have to do the easter egg every time."],
          type: "checkbox",
          default: !1
        },
        EnableRobloxApiDocs: {
          label: "Roblox API docs",
          description: [
            "This adds documentation for Roblox apis on https://www.roblox.com/docs",
            "All the apis are captured when you browse the site.",
            "This stores all the APIs in storage."
          ],
          type: "checkbox",
          default: !1
        },
        EnablebannerTest: {
          label: ["Banner test"],
          description: ["This adds a test banner to experiences"],
          type: "checkbox",
          default: !1
        },
        impersonateRobloxStaffSetting: {
          label: ["Impersonate User Option On Profiles"],
          description: [
            "This enables the 'Impersonate User' option on peoples profile, used by Roblox internally.",
            "Pressing the 'Impersonate User' option does nothing other than error unless you are authorized to use it"
          ],
          deprecated: "Roblox removed it with the new profile overhaul",
          type: "checkbox",
          default: !1
        },
        EarlyAccessProgram: {
          label: ["Early Access Program Showcase"],
          description: [
            "This will trick Roblox into thinking you are in an early access program, making Roblox add the early access program UI to your settings",
            "This setting wont allow you to join any early access programs you werent invited to.",
            "This will also overwrite any early access programs you might already be in."
          ],
          type: "checkbox",
          default: !1
        },
        EnableVideoTest: {
          label: ["Video test"],
          description: [
            "This adds a video test for experience trailers not uploaded to youtube on https://www.roblox.com/videotest",
            "Since this feature is only supported on the client."
          ],
          type: "checkbox",
          default: !1
        },
        onboardingShown: {
          label: ["Show onboarding"],
          description: ["This will show RoValra's onboarding screen again when this setting is disabled."],
          type: "checkbox",
          default: !1
        },
        simulateRoValraServerErrors: {
          label: ["Simulate RoValra Server Errors / downtime"],
          description: ["This will simulate RoValra Server errors / downtime, useful when testing how the extension handles stuff like that."],
          type: "checkbox",
          default: !1
        },
        ShowBadgesEverywhere: {
          label: ["Show badges everywhere"],
          description: ["This is just a fun setting that will show RoValra badges on any profile"],
          type: "checkbox",
          default: !1
        },
        forceReviewPopup: {
          label: ["Force Review Popup"],
          description: ["When enabled, shows the review popup every time it's triggered, ignoring all requirements. For testing purposes."],
          type: "checkbox",
          default: !1
        },
        simulateRoValraServerLatency: {
          label: ["Simulates RoValra's APIs having latency issues"],
          description: ["Yup"],
          type: "checkbox",
          default: !1
        }
      }
    }, menuList && loadTabContent) {
      let devItem = createSidebarItem("Developer", "Developer", loadTabContent);
      devItem.style.opacity = "0", devItem.style.transition = "opacity 0.5s ease", menuList.appendChild(devItem), requestAnimationFrame(() => {
        devItem.style.opacity = "1";
      });
    }
    typeof renderMobileDropdown == "function" && renderMobileDropdown();
  }
  __name(addDeveloperTab, "addDeveloperTab");

  // src/content/core/settings/badgeSettings.js
  async function setBadgeVisibility(badgeName, isVisible) {
    try {
      await callRobloxApiJson({
        isRovalraApi: !0,
        subdomain: "apis",
        endpoint: "/v1/auth/badges/visibility",
        method: "POST",
        body: { badge: badgeName, visible: isVisible }
      });
    } catch (error) {
      console.error(`RoValra: Failed to set badge visibility for ${badgeName}`, error);
    }
  }
  __name(setBadgeVisibility, "setBadgeVisibility");
  function updateMainToggleState(mainToggle, childToggles) {
    let someChecked = childToggles.some((t) => t.checked);
    mainToggle.checked = someChecked;
  }
  __name(updateMainToggleState, "updateMainToggleState");
  async function createBadgeSettings(container) {
    try {
      let response = await callRobloxApiJson({
        isRovalraApi: !0,
        subdomain: "apis",
        endpoint: "/v1/auth/badges",
        method: "GET"
      });
      if (response.status !== "success" || !response.badges)
        return;
      let badges = response.badges, badgeKeys = Object.keys(badges).filter((key) => typeof badges[key] == "boolean" && !key.endsWith("_visible") && badges[key] === !0);
      if (badgeKeys.length === 0)
        return;
      let settingsContent = document.createElement("div");
      settingsContent.id = "setting-section-content", settingsContent.style.cssText = "padding: 5px; width: 100%;";
      let settingContainer = document.createElement("div");
      settingContainer.className = "setting", settingContainer.id = "setting-container-ShowAllBadges";
      let mainControls = document.createElement("div");
      mainControls.className = "setting-controls";
      let mainLabel = document.createElement("label");
      mainLabel.textContent = "Toggle your donation badges visibility.", mainControls.appendChild(mainLabel);
      let mainToggle = generateSettingInput("ShowAllBadges", { type: "checkbox" }), mainToggleInput = mainToggle.querySelector("input");
      mainControls.appendChild(mainToggle), settingContainer.appendChild(mainControls);
      let divider = document.createElement("div");
      divider.className = "setting-label-divider", settingContainer.appendChild(divider);
      let childToggles = [], isFirstChild = !0;
      for (let key of badgeKeys) {
        if (!isFirstChild) {
          let separator = document.createElement("div");
          separator.className = "child-setting-separator", settingContainer.appendChild(separator);
        }
        isFirstChild = !1;
        let isVisible = badges[`${key}_visible`] !== !1, badgeLabel = key.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase()), settingName = `ShowBadge_${key}`, childContainer = document.createElement("div");
        childContainer.className = "child-setting-item", childContainer.id = `setting-${settingName}`;
        let childControls = document.createElement("div");
        childControls.className = "setting-controls";
        let childLabel = document.createElement("label");
        childLabel.textContent = badgeLabel, childControls.appendChild(childLabel);
        let childToggle = generateSettingInput(settingName, { type: "checkbox" }), childInput = childToggle.querySelector("input");
        childInput.checked = isVisible, childControls.appendChild(childToggle), childContainer.appendChild(childControls), settingContainer.appendChild(childContainer), childToggles.push(childInput), childInput.addEventListener("change", async (event) => {
          let isChecked = event.target.checked;
          await setBadgeVisibility(key, isChecked), updateMainToggleState(mainToggleInput, childToggles);
        });
      }
      mainToggleInput.addEventListener("change", async (event) => {
        let isChecked = event.target.checked;
        for (let toggle of childToggles)
          toggle.checked = isChecked;
        for (let key of badgeKeys)
          await setBadgeVisibility(key, isChecked);
      }), updateMainToggleState(mainToggleInput, childToggles), settingsContent.appendChild(settingContainer), container.appendChild(settingsContent), initSettings(settingsContent);
    } catch (error) {
      console.error("RoValra: Failed to create badge settings", error);
    }
  }
  __name(createBadgeSettings, "createBadgeSettings");

  // src/content/core/settings/ui/page.js
  var isSettingsPage = !1;
  async function checkRoValraPage() {
    let rovalraTab = new URLSearchParams(window.location.search).get("rovalra");
    if (!rovalraTab) {
      isSettingsPage = !1;
      return;
    }
    document.body.classList.add("rovalra-settings-loading");
    let regionData = await getRegionData().catch((err) => (console.error("Settings: Failed to load region data.", err), { regions: {}, continents: {} }));
    if (!document.querySelector("main.container-main"))
      return;
    isSettingsPage = !0;
    async function loadTabContent(hashKey) {
      hashKey || (hashKey = "info"), document.querySelectorAll("#unified-menu .menu-option-content").forEach((el2) => {
        el2.classList.remove("active"), el2.removeAttribute("aria-current");
      });
      let targetMenuLink = document.querySelector(`#unified-menu li[id="${hashKey.toLowerCase()}-tab"] a.menu-option-content`);
      if (!targetMenuLink) {
        let capitalizedHash = hashKey.charAt(0).toUpperCase() + hashKey.slice(1);
        targetMenuLink = document.querySelector(`#unified-menu li[data-text="${capitalizedHash}"] a.menu-option-content, #unified-menu li[data-section="${capitalizedHash}"] a.menu-option-content`);
      }
      if (targetMenuLink)
        targetMenuLink.classList.add("active"), targetMenuLink.setAttribute("aria-current", "page");
      else {
        console.warn(`Menu link for hashKey "${hashKey}" not found. Defaulting to info tab.`);
        let infoLink = document.querySelector('#unified-menu li[id="info-tab"] a.menu-option-content');
        infoLink && (infoLink.classList.add("active"), infoLink.setAttribute("aria-current", "page"));
      }
      let contentContainer = document.querySelector("#content-container");
      if (!contentContainer) {
        console.error("Content container not found in loadTabContent.");
        return;
      }
      let searchInput = document.getElementById("settings-search-input");
      searchInput && (searchInput.value = "");
      let lowerHashKey = hashKey.toLowerCase(), settingsConfigKey = Object.keys(SETTINGS_CONFIG).find((k2) => k2.toLowerCase() === lowerHashKey);
      if (contentContainer.innerHTML = "", lowerHashKey === "info" || lowerHashKey === "credits" || lowerHashKey === "donator perks") {
        let buttonInfo = buttonData.find((b2) => b2.text.toLowerCase() === lowerHashKey);
        buttonInfo && await updateContent(buttonInfo, contentContainer);
      } else if (settingsConfigKey && SETTINGS_CONFIG[settingsConfigKey]) {
        let settingsContent = document.createElement("div");
        settingsContent.id = "setting-section-content", settingsContent.style.cssText = "padding: 5px; width: 100%;", settingsContent.appendChild(generateSettingsUI(settingsConfigKey, regionData.regions)), contentContainer.appendChild(settingsContent);
        let settingsContentElement = contentContainer.querySelector("#setting-section-content");
        settingsContentElement && (initSettings(settingsContentElement), await applyTheme2());
      } else {
        console.warn("Unknown hashKey for content:", hashKey, "Falling back to info page.");
        let infoButtonData = buttonData.find((b2) => b2.text.toLowerCase() === "info");
        infoButtonData && await updateContent(infoButtonData, contentContainer);
      }
      lowerHashKey === "profile" && await createBadgeSettings(contentContainer);
    }
    __name(loadTabContent, "loadTabContent");
    async function handleHashChange() {
      let rovalraTabFromParam = new URLSearchParams(window.location.search).get("rovalra"), currentHash = decodeURIComponent(window.location.hash.replace("#!/", "").replace("#!", "")) || rovalraTabFromParam || "info";
      await loadTabContent(currentHash);
    }
    __name(handleHashChange, "handleHashChange"), window.addEventListener("hashchange", handleHashChange, !1);
    let debouncedSearch = /* @__PURE__ */ __name((func, wait) => {
      let timeout;
      return /* @__PURE__ */ __name(function(...args) {
        let later = /* @__PURE__ */ __name(() => {
          clearTimeout(timeout), func(...args);
        }, "later");
        clearTimeout(timeout), timeout = setTimeout(later, wait);
      }, "executedFunction");
    }, "debouncedSearch"), { rovalraHeader, settingsContainer } = await buildSettingsPage({
      handleSearch: /* @__PURE__ */ __name((event) => handleSearch(event, regionData.regions), "handleSearch"),
      debounce: debouncedSearch,
      loadTabContent,
      buttonData,
      REGIONS: regionData.regions,
      initSettings
    });
    if (rovalraHeader && settingsContainer) {
      let unifiedMenu = document.getElementById("unified-menu");
      await loadTabContent(rovalraTab || "info"), await applyTheme2();
    }
  }
  __name(checkRoValraPage, "checkRoValraPage");

  // src/content/features/settings/index.js
  var assets2 = getAssets(), REGIONS5 = {};
  function debounce3(func, wait) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout), timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }
  __name(debounce3, "debounce");
  function getLevenshteinDistance(a, b2) {
    if (!a.length) return b2.length;
    if (!b2.length) return a.length;
    let matrix = Array.from(
      { length: b2.length + 1 },
      (_2, j2) => Array.from(
        { length: a.length + 1 },
        (_3, i) => j2 === 0 ? i : i === 0 ? j2 : 0
      )
    );
    for (let j2 = 1; j2 <= b2.length; j2++)
      for (let i = 1; i <= a.length; i++) {
        let indicator = a[i - 1] === b2[j2 - 1] ? 0 : 1;
        matrix[j2][i] = Math.min(
          matrix[j2][i - 1] + 1,
          matrix[j2 - 1][i] + 1,
          matrix[j2 - 1][i - 1] + indicator
        );
      }
    return matrix[b2.length][a.length];
  }
  __name(getLevenshteinDistance, "getLevenshteinDistance");
  async function applyTheme2() {
    document.body.classList.contains("rovalra-settings-loading") && document.body.classList.remove("rovalra-settings-loading");
  }
  __name(applyTheme2, "applyTheme");
  var debouncedApplyTheme = debounce3(applyTheme2, 50), debouncedAddPopoverButton = debounce3(addPopoverButton, 100), debouncedAddCustomButton = debounce3(
    () => addCustomButton2(debouncedAddPopoverButton),
    100
  );
  function getBadgeStyle(key) {
    let badge = BADGE_CONFIG[key];
    return !badge || !badge.style ? "" : Object.entries(badge.style).map(([k2, v2]) => `${k2.replace(/([A-Z])/g, "-$1").toLowerCase()}:${v2}`).join(";");
  }
  __name(getBadgeStyle, "getBadgeStyle");
  var donatorBadgeKeys = ["donator_1", "donator_2", "donator_3"], donatorBadgesHtml = donatorBadgeKeys.map((key) => {
    let badge = BADGE_CONFIG[key];
    if (!badge) return "";
    let styleString = getBadgeStyle(key), shortTooltip = badge.tooltip.split(".")[0];
    return `
        <div title="${badge.tooltip}" style="display: flex; align-items: center; gap: 10px; padding: 10px; background-color: var(--rovalra-container-background-color, rgba(0,0,0,0.1)); border-radius: 8px; flex: 1; min-width: 240px;">
            <img src="${badge.icon}" style="width: 32px; height: 32px; ${styleString}" />
            <span style="color: var(--rovalra-main-text-color); font-size: 14px;">${shortTooltip}</span>
        </div>
    `;
  }).join(""), buttonData = [
    {
      text: "Info",
      content: `
            <div style="padding: 8px;">
                <h2 style="margin-bottom: 10px; color: var(--rovalra-main-text-color) !important;">RoValra Information!</h2>
                <p>RoValra is an extension that's trying to make basic quality of life features free and accessible to everyone, by making everything completely open-source.</p>
                <div style="margin-top: 5px;">
                    <p>This is possible by running almost everything locally.</p>
                    <div style="margin-top: 5px;">
                        <p>And the server side features doesn't cost me anything to run which is why I can afford to make this free.</p>
                        <div style="margin-top: 5px;">
                            <p>This extension is also a project to learn, so a lot of stuff might change or get reworked overtime as I learn more.</p>
                            <div style="margin-top: 5px;">
                                <p>WE ALL LOVE GILBERT</p>
                                <div style="margin-top: 5px;">
                                    <p>If you have any feature suggestions please let me know in my Discord server or via GitHub</p>
                                    <div style="margin-top: 5px;">
                                        <p>If you find any bugs let me know in my Discord server or via GitHub</p>
                                        <div style="margin-top: 5px;">
                                            <p>If you like this extension please consider <a href="https://chromewebstore.google.com/detail/rovalra-roblox-improved/njcickgebhnpgmoodjdgohkclfplejli/reviews" target="_blank" class="rovalra-review-link">leaving a review</a>, it helps a lot \u2764\uFE0F</p>
                                        </div>
                                        <div style="margin-top: 10px; margin-bottom: 20px;">
                                            <a href="https://discord.gg/GHd5cSKJRk" target="_blank" class="rovalra-discord-link">Discord Server</a>
                                            <a href="https://github.com/NotValra/RoValra" target="_blank" class="rovalra-github-link">
                                                Github Repo
                                                <img src="${assets2.rovalraIcon}" style="width: 20px; height: 20px; margin-right: 0px; vertical-align: middle;" />
                                            </a>
                                            <a href="https://www.roblox.com/games/store-section/9452973012" target="_blank" class="rovalra-roblox-link">Support RoValra</a>
                                            <a href="https://www.tiktok.com/@valrawantbanana" target="_blank" class="rovalra-tiktok-link">TikTok: ValraWantBanana</a>
                                            <a href="https://x.com/ValraSwag" target="_blank" class="rovalra-x-link">X: ValraSwag</a>
                                        </div>
                                        <div id="export-import-buttons-container" style="border-top: 1px solid var(--rovalra-secondary-text-color); opacity: 0.8; padding-top: 15px; display: flex; justify-content: flex-start; gap: 10px;"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>`
    },
    {
      text: "Credits",
      content: `
            <div style="padding: 8px;">
                <h2 style="margin-bottom: 10px; color: var(--rovalra-main-text-color) !important;">RoValra Credits!</h2>
                <ul style="margin-top: 10px; padding-left: 0px; color: var(--rovalra-secondary-text-color);">
                    <li style="margin-bottom: 8px; list-style-type: disc; margin-left: 20px;">
                        Thanks to <b style="font-weight: bold;">everyone who</b>
                        <a href="https://github.com/NotValra/RoValra/graphs/contributors" target="_blank" class="rovalra-github-link">contributed</a>
                    </li>
                    <li style="margin-bottom: 8px; list-style-type: disc; margin-left: 20px;">
                        Thanks to <b style="font-weight: bold;">Frames</b> for somehow getting the Roblox sales and revenue on some items
                        <a href="https://github.com/workframes/roblox-owner-counts" target="_blank" class="rovalra-github-link">GitHub Repo</a>
                    </li>
                    <li style="margin-bottom: 8px; list-style-type: disc; margin-left: 20px;">
                        Thanks to <b style="font-weight: bold;">Julia</b> for making a repo with all Roblox server datacenters which I used to use to get the regions, but now I switched to my own api.
                        <a href="https://github.com/RoSeal-Extension/Top-Secret-Thing" target="_blank" class="rovalra-github-link">GitHub Repo</a>
                    </li>
                    <li style="margin-bottom: 8px; list-style-type: disc; margin-left: 20px;">
                         Thanks to <b style="font-weight: bold;">Aspect</b> for helping me out here and there when I had a bunch of dumb questions or problems.
                         <a href="https://github.com/Aspectise" target="_blank" class="rovalra-github-link">GitHub</a>
                    </li>
                    <li style="margin-bottom: 8px; list-style-type: disc; margin-left: 20px;">
                         Thanks to <b style="font-weight: bold;">l5se</b> for allowing me to use their open source region selector as a template for my extension.
                    </li>
                    <li style="margin-bottom: 8px; list-style-type: disc; margin-left: 20px;">
                        Thanks to <b style="font-weight: bold;">7_lz</b> for helping me a bunch when preparing for the Chrome Web Store release. They helped a ton and I'm very thankful.
                    </li>
                    <li style="margin-bottom: 8px; list-style-type: disc; margin-left: 20px;">
                        Thanks to <b style="font-weight: bold;">mmfw</b> for making the screenshots on the chrome web store, and general help with UI design of the extension.
                    </li>
                    <li style="margin-bottom: 8px; list-style-type: disc; margin-left: 20px;">
                        Thanks to <b style="font-weight: bold;">Coweggs</b> for coming up with the very funny name that is "RoValra" as a joke that I then ended up using.
                    </li>
                    <li style="margin-bottom: 8px; list-style-type: disc; margin-left: 20px;">
                        Thanks to <b style="font-weight: bold;">WoozyNate</b> for making the amazing game called fisch, which is where Gilbert (the logo) is from <3
                    </li>
                </ul>
            </div>`
    },
    {
      text: "Donator Perks",
      content: `
            <div style="padding: 8px;">
                <h2 style="margin-bottom: 10px; color: var(--rovalra-main-text-color) !important;">Donator Perks!</h2>
                <p>Support RoValra's development and get exclusive perks!</p>
                
                <div style="margin-top: 15px;">
                    <h3 style="color: var(--rovalra-main-text-color); margin-bottom: 5px; font-size: 18px;">How to Get Perks</h3>
                    <p>You can donate by purchasing a gamepasses in the support game.</p>
                    <div style="margin-top: 10px;">
                        <a href="https://www.roblox.com/games/store-section/9452973012" target="_blank" class="rovalra-roblox-link">Go to Donation Game</a>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <h3 style="color: var(--rovalra-main-text-color); margin-bottom: 10px; font-size: 18px;">Perk Tiers</h3>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 200px; margin-bottom: 10px; padding: 10px; background-color: var(--rovalra-container-background-color, rgba(0,0,0,0.1)); border-radius: 8px; border: 1px solid var(--rovalra-border-color, rgba(128,128,128,0.2));">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                                <img src="${BADGE_CONFIG.donator_1.icon}" style="width: 32px; height: 32px; ${getBadgeStyle("donator_1")}" />
                                <h4 style="color: var(--rovalra-main-text-color); margin: 0; font-size: 16px;">Tier 1: Supporter</h4>
                            </div>
                            <p style="color: var(--rovalra-secondary-text-color); font-size: 14px;">Donate <strong>any amount</strong></p>
                            <ul style="margin-top: 5px; padding-left: 20px; color: var(--rovalra-secondary-text-color); margin-bottom: 0;">
                                <li>Supporter 1 Badge</li>
                                <li>More coming soon.</li>
                            </ul>
                        </div>

                        <div style="flex: 1; min-width: 200px; margin-bottom: 10px; padding: 10px; background-color: var(--rovalra-container-background-color, rgba(0,0,0,0.1)); border-radius: 8px; border: 1px solid var(--rovalra-border-color, rgba(128,128,128,0.2));">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                                <img src="${BADGE_CONFIG.donator_2.icon}" style="width: 32px; height: 32px; ${getBadgeStyle("donator_2")}" />
                                <h4 style="color: var(--rovalra-main-text-color); margin: 0; font-size: 16px;">Tier 2: Super Supporter</h4>
                            </div>
                            <p style="color: var(--rovalra-secondary-text-color); font-size: 14px;">Donate <strong>200+ Robux</strong></p>
                            <ul style="margin-top: 5px; padding-left: 20px; color: var(--rovalra-secondary-text-color); margin-bottom: 0;">
                                <li>Supporter 2 Badge</li>
                                <li>+ All previous tier rewards</li>
                                <li>More coming soon.</li>
                            </ul>
                        </div>

                        <div style="flex: 1; min-width: 200px; margin-bottom: 10px; padding: 10px; background-color: var(--rovalra-container-background-color, rgba(0,0,0,0.1)); border-radius: 8px; border: 1px solid var(--rovalra-border-color, rgba(128,128,128,0.2));">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                                <img src="${BADGE_CONFIG.donator_3.icon}" style="width: 32px; height: 32px; ${getBadgeStyle("donator_3")}" />
                                <h4 style="color: var(--rovalra-main-text-color); margin: 0; font-size: 16px;">Tier 3: Mega Supporter</h4>
                            </div>
                            <p style="color: var(--rovalra-secondary-text-color); font-size: 14px;">Donate <strong>500+ Robux</strong></p>
                            <ul style="margin-top: 5px; padding-left: 20px; color: var(--rovalra-secondary-text-color); margin-bottom: 0;">
                                <li>Supporter 3 Badge</li>
                                <li>+ All previous tier rewards</li>
                                <li>More coming soon.</li>

                            </ul>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <h3 style="color: var(--rovalra-main-text-color); margin-bottom: 10px; font-size: 18px;">Available Badges</h3>
                    <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: stretch;">
                        ${donatorBadgesHtml}
                    </div>
                </div>
                
                <p style="margin-top: 15px; font-size: 12px; color: var(--rovalra-secondary-text-color);">
                    Note: Badges may take a few minutes to appear after donation. To manage badge visibility, go to the 'Profile' settings tab.
                    Donating through commissions sadly won't give a donator perks, this is a Roblox limitation.
                </p>
            </div>`
    },
    {
      text: "Settings",
      content: `
            <div id="settings-content" style="padding: 0; background-color: transparent;">
                <div id="setting-section-buttons" style="display: flex; margin-bottom: 25px;"></div>
                <div id="setting-section-content" style="padding: 5px;"></div>
            </div>`
    }
  ];
  function handleGlobalDomChange(event) {
    document.getElementById("settings-popover-menu") ? addPopoverButton() : window.rovalraPopoverButtonAdded && (window.rovalraPopoverButtonAdded = !1), debouncedAddCustomButton(), debouncedAddPopoverButton();
    let mutationsList = event.detail?.mutationsList;
    if (!mutationsList) return;
    mutationsList.some(
      (mutation) => mutation.type === "childList" && mutation.addedNodes.length > 0 && Array.from(mutation.addedNodes).some(
        (node) => node.nodeType === Node.ELEMENT_NODE && (node.matches(
          "[data-theme-dependent], .setting, .menu-option, #content-container"
        ) || node.querySelector(
          "[data-theme-dependent], .setting, .menu-option, #content-container"
        ))
      )
    ) && debouncedApplyTheme();
  }
  __name(handleGlobalDomChange, "handleGlobalDomChange");
  async function updateContent(buttonInfo, contentContainer) {
    if (typeof buttonInfo != "object" || buttonInfo === null || !buttonInfo.content)
      return;
    let lowerText = buttonInfo.text.toLowerCase(), sanitizeConfig = { ADD_URI_SCHEMES: ["chrome-extension"] };
    if (lowerText === "info" || lowerText === "credits" || lowerText === "donator perks" ? contentContainer.innerHTML = `
            <div id="settings-content" style="padding: 0; background-color: transparent !important;"> 
                <div id="setting-section-content" style="padding: 5px;"> 
                    <div id="info-credits-background-wrapper" class="setting" style="margin-bottom: 15px;">
                        ${buttonInfo.content}
                    </div> 
                </div> 
            </div>` : contentContainer.innerHTML = safeHtml(
      buttonInfo.content,
      sanitizeConfig
    ), lowerText === "info") {
      let buttonContainer = contentContainer.querySelector(
        "#export-import-buttons-container"
      );
      buttonContainer && buttonContainer.appendChild(createExportImportButtons());
    }
    let rovalraHeader = document.querySelector(
      "#react-user-account-base > h1"
    );
    rovalraHeader && rovalraHeader.style.setProperty(
      "color",
      "var(--rovalra-main-text-color)",
      "important"
    );
  }
  __name(updateContent, "updateContent");
  async function handleSearch(event) {
    let query = event.target && event.target.value ? event.target.value.toLowerCase().trim() : "", contentContainer = document.querySelector("#content-container");
    if (!contentContainer) return;
    if (document.querySelectorAll("#unified-menu .menu-option-content").forEach((el2) => {
      el2.classList.remove("active"), el2.removeAttribute("aria-current");
    }), query.length < 2) {
      contentContainer.innerHTML = purify.sanitize(
        '<div id="settings-content" style="padding: 15px; text-align: center; color: var(--rovalra-main-text-color);">Please enter at least 2 characters to search.</div>'
      ), await applyTheme2();
      return;
    }
    let searchResults = [], queryNoSpaces = query.replace(/\s+/g, "");
    for (let categoryName in SETTINGS_CONFIG) {
      let category = SETTINGS_CONFIG[categoryName];
      for (let [settingName, settingDef] of Object.entries(
        category.settings
      )) {
        let label = (Array.isArray(settingDef.label) ? settingDef.label.join(" ") : settingDef.label || "").toLowerCase(), description = (Array.isArray(settingDef.description) ? settingDef.description.join(" ") : settingDef.description || "").toLowerCase(), fullText = `${label} ${description}`, isMatch = fullText.includes(query) || fullText.replace(/\s+/g, "").includes(queryNoSpaces);
        if (!isMatch) {
          let words = fullText.split(/\s+/), threshold = query.length > 5 ? 2 : 1;
          isMatch = words.some(
            (word) => getLevenshteinDistance(query, word) <= threshold
          );
        }
        if (!isMatch && settingDef.childSettings)
          for (let childDef of Object.values(
            settingDef.childSettings
          )) {
            let childLabel = (Array.isArray(childDef.label) ? childDef.label.join(" ") : childDef.label || "").toLowerCase(), childDesc = (Array.isArray(childDef.description) ? childDef.description.join(" ") : childDef.description || "").toLowerCase();
            if (`${childLabel} ${childDesc}`.includes(query)) {
              isMatch = !0;
              break;
            }
          }
        isMatch && !searchResults.some((res) => res.name === settingName) && searchResults.push({
          category: category.title,
          name: settingName,
          config: settingDef
        });
      }
    }
    if (searchResults.length === 0)
      contentContainer.innerHTML = safeHtml`<div id="settings-content" style="padding: 15px; text-align: center; color: var(--rovalra-main-text-color);">No settings found for "${query}".</div>`;
    else {
      let groupedResults = searchResults.reduce((acc, setting) => (acc[setting.category] || (acc[setting.category] = []), acc[setting.category].push(setting), acc), {});
      contentContainer.innerHTML = "";
      let resultsWrapper = document.createElement("div");
      resultsWrapper.id = "setting-section-content", resultsWrapper.style.padding = "5px";
      for (let categoryTitle in groupedResults) {
        let header = document.createElement("h2");
        header.className = "settings-category-header", header.style.cssText = "margin-left: 5px; margin-bottom: 10px; color: var(--rovalra-main-text-color);", header.textContent = categoryTitle, resultsWrapper.appendChild(header);
        for (let setting of groupedResults[categoryTitle]) {
          let settingElement = generateSingleSettingHTML(
            setting.name,
            setting.config,
            REGIONS5
          );
          if (settingElement instanceof Node)
            resultsWrapper.appendChild(settingElement);
          else {
            let tempDiv = document.createElement("div");
            for (tempDiv.innerHTML = safeHtml(settingElement); tempDiv.firstChild; )
              resultsWrapper.appendChild(tempDiv.firstChild);
          }
        }
      }
      contentContainer.appendChild(resultsWrapper);
    }
    await initSettings(contentContainer), await applyTheme2();
  }
  __name(handleSearch, "handleSearch");
  document.addEventListener("click", (event) => {
    let target = event.target;
    if (target.id === "export-rovalra-settings") return exportSettings();
    if (target.id === "import-rovalra-settings") return importSettings();
    if (!target.matches(".tab-button, .setting-section-button")) {
      if (target.matches('input[type="checkbox"]')) {
        let settingName = target.dataset.settingName;
        settingName && handleSaveSettings(settingName, target.checked).then(() => {
          let settingsContent = document.querySelector(
            "#setting-section-content"
          );
          settingsContent && loadSettings().then(
            (currentSettings) => updateConditionalSettingsVisibility(
              settingsContent,
              currentSettings
            )
          );
        });
      } else if (target.matches("select")) {
        let settingName = target.dataset.settingName;
        settingName && handleSaveSettings(settingName, target.value).then(() => {
          let settingsContent = document.querySelector(
            "#setting-section-content"
          );
          settingsContent && loadSettings().then(
            (currentSettings) => updateConditionalSettingsVisibility(
              settingsContent,
              currentSettings
            )
          );
        });
      }
    }
  });
  function onPopoverRemoved() {
    window.rovalraPopoverButtonAdded = !1;
  }
  __name(onPopoverRemoved, "onPopoverRemoved");
  async function initializeExtension() {
    try {
      REGIONS5 = (await getRegionData()).regions;
    } catch (e) {
      console.warn("Failed to load region data:", e);
    }
    await applyTheme2(), await buildSettingsKey(), addCustomButton2(debouncedAddPopoverButton), addPopoverButton(), initializeSettingsEventListeners(), document.addEventListener("roblox-dom-changed", handleGlobalDomChange), observeElement("#settings-popover-menu", addPopoverButton, {
      onRemove: onPopoverRemoved
    }), observeElement(
      'ul.menu-vertical[role="tablist"]',
      () => addCustomButton2(debouncedAddPopoverButton)
    ), await checkRoValraPage();
  }
  __name(initializeExtension, "initializeExtension");
  function init52() {
    document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", initializeExtension) : initializeExtension();
  }
  __name(init52, "init");
  window.addEventListener("beforeunload", () => {
    document.removeEventListener("roblox-dom-changed", handleGlobalDomChange);
  });
  document.addEventListener("DOMContentLoaded", function() {
    let PreferredRegionEnabled = document.getElementById(
      "PreferredRegionEnabled"
    ), preferredRegionSelect = document.getElementById(
      "preferredRegionSelect"
    ), regionSettingDiv = document.getElementById(
      "setting-preferred-region"
    );
    function updateRegionSelectVisibility() {
      if (PreferredRegionEnabled && regionSettingDiv) {
        let isEnabled2 = PreferredRegionEnabled.checked;
        regionSettingDiv.style.display = isEnabled2 ? "flex" : "none", preferredRegionSelect && (preferredRegionSelect.disabled = !isEnabled2);
      }
    }
    __name(updateRegionSelectVisibility, "updateRegionSelectVisibility"), PreferredRegionEnabled && PreferredRegionEnabled.addEventListener("change", function() {
      updateRegionSelectVisibility(), handleSaveSettings("PreferredRegionEnabled", this.checked);
    }), preferredRegionSelect && (preferredRegionSelect.addEventListener("change", function() {
      handleSaveSettings("robloxPreferredRegion", this.value);
    }), preferredRegionSelect.options.length === 0 && Object.keys(REGIONS5).forEach((regionCode) => {
      let option = document.createElement("option");
      option.value = regionCode, option.textContent = getFullRegionName(regionCode), preferredRegionSelect.appendChild(option);
    })), updateRegionSelectVisibility();
  });
  function initializeHeartbeatSpoofer() {
    let originalFetch = window.fetch, pulseInterval = null, spoofingMode = "off", sendSpoofedHeartbeat = /* @__PURE__ */ __name(async () => {
      let locationInfoPayload;
      if (spoofingMode === "studio")
        locationInfoPayload = { studioLocationInfo: { placeId: 0 } };
      else
        return;
      let spoofedPulseRequest = {
        clientSideTimestampEpochMs: Date.now(),
        locationInfo: locationInfoPayload,
        sessionInfo: { sessionId: crypto.randomUUID() }
      };
      try {
        await callRobloxApi({
          subdomain: "apis",
          endpoint: "/user-heartbeats-api/pulse",
          method: "POST",
          body: spoofedPulseRequest,
          headers: { "RoValra-Internal": "true" }
        }), console.log(
          `RoValra: Spoofed heartbeat sent. Mode: ${spoofingMode}`
        );
      } catch (error) {
        console.error("RoValra: Failed to send spoofed heartbeat.", error);
      }
    }, "sendSpoofedHeartbeat"), startSpoofingTimer = /* @__PURE__ */ __name(() => {
      pulseInterval || (console.log(`RoValra: Starting spoofer timer (${spoofingMode}).`), pulseInterval = setInterval(async () => {
        spoofingMode === "studio" && sendSpoofedHeartbeat();
      }, 3e4));
    }, "startSpoofingTimer"), stopSpoofingTimer = /* @__PURE__ */ __name(() => {
      pulseInterval && (console.log("RoValra: Stopping spoofer timer."), clearInterval(pulseInterval), pulseInterval = null);
    }, "stopSpoofingTimer"), updateSpoofingMode = /* @__PURE__ */ __name((settings) => {
      chrome.runtime.sendMessage({
        action: "updateOfflineRule",
        enabled: settings.spoofAsOffline
      }), chrome.runtime.sendMessage({
        action: "updateEarlyAccessRule",
        enabled: settings.EarlyAccessProgram
      }), settings.spoofAsOffline ? spoofingMode = "offline" : settings.spoofAsStudio ? spoofingMode = "studio" : spoofingMode = "off", spoofingMode === "studio" ? startSpoofingTimer() : stopSpoofingTimer();
    }, "updateSpoofingMode"), relevantSettings = [
      "spoofAsStudio",
      "spoofAsOffline",
      "EarlyAccessProgram"
    ];
    chrome.storage.local.get(relevantSettings, updateSpoofingMode), chrome.storage.onChanged.addListener((changes) => {
      relevantSettings.some((setting) => changes[setting]) && chrome.storage.local.get(relevantSettings, (result) => {
        if (changes.LaunchDelay) {
          let toggle = document.querySelector(
            "#LaunchDelay-enabled"
          );
          toggle && (toggle.checked = changes.LaunchDelay.newValue > 0, updateConditionalSettingsVisibility(
            document.body,
            result
          ));
        }
        updateSpoofingMode(result);
      });
    }), window.fetch = async function(...args) {
      let url = args[0] ? args[0].toString() : "", isInternal = !1;
      if (args.length > 1 && args[1] && args[1].headers) {
        let newOptions = { ...args[1] }, hasHeader = !1;
        newOptions.headers instanceof Headers ? newOptions.headers.get("RoValra-Internal") === "true" && (hasHeader = !0, newOptions.headers = new Headers(newOptions.headers), newOptions.headers.delete("RoValra-Internal")) : typeof newOptions.headers == "object" && !Array.isArray(newOptions.headers) && newOptions.headers["RoValra-Internal"] === "true" && (hasHeader = !0, newOptions.headers = { ...newOptions.headers }, delete newOptions.headers["RoValra-Internal"]), hasHeader && (isInternal = !0, args[1] = newOptions);
      }
      return url.includes("apis.roblox.com/user-heartbeats-api/pulse") && spoofingMode !== "off" && !isInternal ? new Response(null, { status: 200, statusText: "OK" }) : originalFetch.apply(this, args);
    }, console.log("RoValra: Proactive heartbeat spoofer initialized.");
  }
  __name(initializeHeartbeatSpoofer, "initializeHeartbeatSpoofer");
  function manageSingletonExecution() {
    let KEYS = {
      ID: "rovalra_singleton_leader_id",
      SEEN: "rovalra_singleton_last_seen"
    }, INTERVAL = 5e3, LEASE = 1e4, instanceId = crypto.randomUUID(), isLeader = !1, timerId = null, featuresInitialized = !1, toggleFeatures = /* @__PURE__ */ __name((shouldRun) => {
      shouldRun && !featuresInitialized ? (console.log(
        "RoValra: Leader instance. Initializing singleton features."
      ), initializeHeartbeatSpoofer(), featuresInitialized = !0) : !shouldRun && featuresInitialized && (featuresInitialized = !1, console.log("RoValra: No longer leader."));
    }, "toggleFeatures"), resetLoop = /* @__PURE__ */ __name((nextFn) => {
      timerId && clearInterval(timerId), timerId = setInterval(nextFn, INTERVAL);
    }, "resetLoop"), attemptToBecomeLeader = /* @__PURE__ */ __name(() => {
      isLeader = !0;
      let info = { [KEYS.ID]: instanceId, [KEYS.SEEN]: Date.now() };
      chrome.storage.local.set(info, () => {
        toggleFeatures(!0), resetLoop(renewLease);
      });
    }, "attemptToBecomeLeader"), renewLease = /* @__PURE__ */ __name(() => {
      if (isLeader) {
        if (typeof chrome > "u" || !chrome.storage || !chrome.storage.local) {
          isLeader = !1, toggleFeatures(!1), resetLoop(checkForLeader);
          return;
        }
        chrome.storage.local.get(KEYS.ID, (result) => {
          chrome.runtime?.lastError || result[KEYS.ID] !== instanceId ? (isLeader = !1, toggleFeatures(!1), resetLoop(checkForLeader)) : chrome.storage.local.set({ [KEYS.SEEN]: Date.now() });
        });
      }
    }, "renewLease"), checkForLeader = /* @__PURE__ */ __name(() => {
      chrome.storage.local.get([KEYS.ID, KEYS.SEEN], (result) => {
        let lastSeen = result[KEYS.SEEN], isLeaseActive = lastSeen && Date.now() - lastSeen < LEASE;
        (!result[KEYS.ID] || !isLeaseActive) && attemptToBecomeLeader();
      });
    }, "checkForLeader");
    window.addEventListener("beforeunload", () => {
      isLeader && chrome.storage.local.remove([KEYS.ID, KEYS.SEEN]);
    }), checkForLeader(), resetLoop(checkForLeader);
  }
  __name(manageSingletonExecution, "manageSingletonExecution");
  manageSingletonExecution();
  loadDatacenterMap();

  // src/content/features/create.roblox.com/download.js
  function saveAsFile(data, fileName, mimeType) {
    let blob = new Blob([data], { type: mimeType }), url = URL.createObjectURL(blob), a = document.createElement("a");
    a.href = url, a.download = fileName, document.body.appendChild(a), a.click(), document.body.removeChild(a), URL.revokeObjectURL(url);
  }
  __name(saveAsFile, "saveAsFile");
  async function downloadAsset(assetId) {
    let assetLocation = null, assetTypeId = null;
    try {
      let response = await callRobloxApi({
        subdomain: "assetdelivery",
        endpoint: "/v2/assets/batch",
        method: "POST",
        body: [{
          requestId: assetId.toString(),
          assetId
        }],
        sanitize: !1
      });
      if (response.ok) {
        let data = await response.json();
        if (data && data.length > 0) {
          let item = data[0];
          item.locations && item.locations.length > 0 && (assetLocation = item.locations[0].location), assetTypeId = item.assetTypeId;
        }
      }
    } catch (e) {
      console.error("[RoValra DL] Failed to fetch asset location:", e);
    }
    if (assetLocation)
      try {
        let response = await fetch(assetLocation);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        let arrayBuffer = await response.arrayBuffer(), ext = {
          1: "png",
          3: "ogg",
          4: "mesh",
          9: "rbxl",
          10: "rbxm",
          11: "png",
          12: "png",
          13: "png",
          24: "rbxm",
          38: "rbxm",
          40: "mesh"
        }[assetTypeId] || "bin";
        saveAsFile(arrayBuffer, `${assetId}.${ext}`, "application/octet-stream");
        return;
      } catch (e) {
        console.error("[RoValra DL] Failed to process raw asset:", e);
      }
    let asset = (await checkAssetsInBatch([assetId]))[0];
    if (!asset || !asset.isValid || !asset.root)
      return;
    let serializedData, fileExtension;
    if (asset.format === "RBXM")
      serializedData = asset.root, fileExtension = "rbxm";
    else if (asset.format === "XML")
      serializedData = JSON.stringify(asset.root, null, 2), fileExtension = "rbxmx";
    else {
      console.error(`Unknown asset format: ${asset.format}`);
      return;
    }
    saveAsFile(serializedData, `${assetId}.${fileExtension}`, "application/octet-stream");
  }
  __name(downloadAsset, "downloadAsset");
  function addButton(buttonContainer) {
    let assetId = getAssetIdFromUrl();
    if (!assetId) {
      let match = window.location.pathname.match(/\/store\/asset\/(\d+)/);
      match && (assetId = match[1]);
    }
    if (!assetId || document.getElementById("rovalra-download-asset-btn"))
      return;
    let targetContainer = buttonContainer.firstElementChild || buttonContainer, assets3 = getAssets(), downloadButton = document.createElement("button");
    downloadButton.id = "rovalra-download-asset-btn", Object.assign(downloadButton.style, {
      display: "flex",
      alignItems: "center",
      background: "transparent",
      border: "none",
      cursor: "pointer",
      padding: "0",
      marginRight: "10px",
      color: "inherit",
      fontWeight: "bold",
      fontSize: "14px",
      fontFamily: "inherit"
    });
    let icon = document.createElement("div");
    Object.assign(icon.style, {
      width: "24px",
      height: "24px",
      marginRight: "4px",
      backgroundColor: "currentColor",
      webkitMask: `url("${assets3.downloadIcon}") no-repeat center / contain`,
      mask: `url("${assets3.downloadIcon}") no-repeat center / contain`
    });
    let text2 = document.createElement("span");
    text2.textContent = "Download", downloadButton.appendChild(icon), downloadButton.appendChild(text2), downloadButton.addEventListener("mouseenter", () => {
      text2.style.textDecoration = "underline";
    }), downloadButton.addEventListener("mouseleave", () => {
      text2.style.textDecoration = "none";
    }), downloadButton.onclick = () => {
      downloadAsset(assetId);
    }, targetContainer.prepend(downloadButton);
  }
  __name(addButton, "addButton");
  function init53() {
    window.location.href.includes("/store/asset/") && chrome.storage.local.get({ DownloadCreateEnabled: !0 }, (result) => {
      result.DownloadCreateEnabled && observeElement('[data-testid="assetButtonsTestId"]', (buttonContainer) => {
        addButton(buttonContainer);
      });
    });
  }
  __name(init53, "init");

  // src/content/index.js
  var pageLoaded = !1, lastPath = window.location.pathname, featureRoutes = [
    // Generic features that run on most pages
    {
      paths: ["*"],
      features: [init52, init25, init3, init4, init2, init5, init6, init, init8, init9, init10, init11, init13, init14, init15, init7, init50]
    },
    // pretty much just the 40% method
    {
      paths: ["/catalog", "/bundles", "/game-pass", "/games"],
      features: [init21]
    },
    // Catalog and bundle pages
    {
      paths: ["/catalog", "/bundles"],
      features: [init22, init20, init23]
    },
    // Group pages
    {
      paths: ["/communities/"],
      features: [init38, init39, init40, init41]
    },
    // Game pages
    {
      paths: ["/games/"],
      features: [
        init30,
        initServerIdExtraction,
        init24,
        init26,
        init27,
        init28,
        init31,
        init29,
        init32,
        initRecentServers,
        init49,
        init33,
        init34
      ]
    },
    // avatar
    {
      paths: ["/my/avatar"],
      features: [init16, init17, init18, init19]
    },
    // User profile pages
    {
      paths: ["/users/"],
      features: [
        init43,
        init42,
        init44,
        init45,
        init46,
        init47,
        init48,
        init51
      ]
    },
    // Transactions page
    { paths: ["/transactions"], features: [init35, init36, init37] },
    // API Docs
    {
      paths: ["/docs"],
      features: [init12]
    },
    // create
    {
      paths: ["/store/asset"],
      features: [init53]
    }
  ];
  function runFeaturesForPage() {
    let path = window.location.pathname, normalizedPath = path.replace(/^\/[a-z]{2}(?:-[a-z]{2})?\//, "/");
    featureRoutes.forEach((route) => {
      route.paths.some((p) => p === "*" || path.startsWith(p) || normalizedPath.startsWith(p)) && route.features && Array.isArray(route.features) && route.features.forEach((init54) => {
        try {
          init54();
        } catch (error) {
          console.error("Mania Ext: Feature init failed", error);
        }
      });
    });
  }
  __name(runFeaturesForPage, "runFeaturesForPage");
  async function initializePage() {
    if (window.top !== window.self || pageLoaded) return;
    pageLoaded = !0, initializeObserver();
    let observerStatus = startObserving(), onDomReady = /* @__PURE__ */ __name(async () => {
      detectTheme().then((theme) => dispatchThemeEvent(theme)), runFeaturesForPage();
    }, "onDomReady");
    document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", onDomReady) : onDomReady(), console.log("%cMania Ext Initialized", "font-size: 1.5em; color: #FF4500;", `(Observer: ${observerStatus})`);
  }
  __name(initializePage, "initializePage");
  function handleUrlChange() {
    let currentPath = window.location.pathname;
    currentPath !== lastPath && (console.log(`%cMania Ext: URL changed from ${lastPath} to ${currentPath}`, "color: #FF4500;"), lastPath = currentPath, runFeaturesForPage(), detectTheme().then((theme) => dispatchThemeEvent(theme)));
  }
  __name(handleUrlChange, "handleUrlChange");
  function setupUrlChangeListeners() {
    let originalPushState = history.pushState, originalReplaceState = history.replaceState;
    history.pushState = function(...args) {
      originalPushState.apply(this, args), handleUrlChange();
    }, history.replaceState = function(...args) {
      originalReplaceState.apply(this, args), handleUrlChange();
    }, window.addEventListener("popstate", handleUrlChange);
    let urlCheckInterval = setInterval(() => {
      window.location.pathname !== lastPath && handleUrlChange();
    }, 500);
  }
  __name(setupUrlChangeListeners, "setupUrlChangeListeners");
  initializePage();
  setupUrlChangeListeners();
})();
